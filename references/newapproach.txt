Engineered sci-fi tube redesign with immersive game mechanics.Alright, the user wants to implement:

Test tube visual improvements (glass-like appearance)
Liquid inside the tubes
Bubbling/heating effect when powering up
Tube shattering when released
Tube rebuilding for next round
Coin drop splash effect
Full screen integration (no separation between top/bottom)

They're using Cursor to implement, so I need to give clear, structured instructions.
Let me break this down into phases:
Phase 1: Layout Fix & Full Screen Integration

Remove the hard split between TopArea and BottomArea
Make Three.js scene fill entire viewport
Overlay player cards at bottom with absolute positioning

Phase 2: Test Tube Visual Upgrade

Make tubes look like glass (transparent, refractive)
Add liquid cylinder inside each tube
Improve materials and lighting

Phase 3: Particle Systems

Bubble particles for heating effect
Glass shard particles for shattering
Splash particles for coin landing

Phase 4: Animations

Tube shatter animation
Tube rebuild animation
Liquid heating/rising animation
Coin splash on impact

Phase 5: State Management

Track tube states (intact, shattering, shattered, rebuilding)
Trigger effects based on player actions

Let me organize this into clear, implementable chunks for Cursor.Phase 1: Full Screen Integration & Layout Fix
Changes to PhysicsGameScreen.jsx
Replace the entire component structure to make Three.js fill the screen:
jsxconst FullScreenContainer = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #000000;
  overflow: hidden;
`

const ThreeJSCanvas = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
`

const UIOverlay = styled.div`
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 280px;
  z-index: 10;
  pointer-events: none;
  
  > * {
    pointer-events: auto;
  }
`

const TopUIOverlay = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: auto;
  z-index: 10;
  pointer-events: none;
  padding: 2rem;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  
  > * {
    pointer-events: auto;
  }
`
Update the return JSX:
jsxreturn (
  <FullScreenContainer>
    <ThreeJSCanvas>
      <SimpleCoinTubes
        players={gameState.players || {}}
        playerOrder={gameState.playerOrder || []}
        onCoinLanded={handleCoinLanded}
        onPowerChange={handlePowerChange}
      />
    </ThreeJSCanvas>

    {phase === 'round_active' && (
      <TopUIOverlay>
        <RoundIndicator>
          <div className="round-text">
            ðŸŽ¯ ROUND {gameState.currentRound}
          </div>
        </RoundIndicator>

        <TimerDisplay urgent={urgent}>
          {turnTimer}s
        </TimerDisplay>
      </TopUIOverlay>
    )}

    <UIOverlay>
      <SimplePlayerCards
        players={gameState.players || {}}
        playerOrder={gameState.playerOrder || []}
        currentPlayerAddress={address}
        onChoiceSelect={handleChoiceSelect}
        onFlipCoin={handleFlipCoin}
        onChangeCoin={handleChangeCoin}
        onPowerStart={handlePowerStart}
        onPowerEnd={handlePowerEnd}
        disabled={phase !== 'round_active' || currentPlayer?.hasFired}
      />
    </UIOverlay>

    {showCoinSelector && (
      <Modal onClick={() => setShowCoinSelector(false)}>
        <ModalContent onClick={(e) => e.stopPropagation()}>
          <CloseButton onClick={() => setShowCoinSelector(false)}>Ã—</CloseButton>
          <h2 style={{ color: '#FFD700', textAlign: 'center', marginBottom: '1rem' }}>
            Choose Your Coin
          </h2>
          <CoinSelector
            selectedCoin={gameState.players?.[selectedPlayerAddr?.toLowerCase()]?.coin}
            onCoinSelect={handleCoinSelect}
            showCustomOption={true}
          />
        </ModalContent>
      </Modal>
    )}
  </FullScreenContainer>
)
Add new handlers:
jsxconst [powerLevel, setPowerLevel] = useState(0)

const handlePowerStart = useCallback((playerAddr) => {
  if (window.startTubeHeating) {
    window.startTubeHeating(playerAddr)
  }
}, [])

const handlePowerEnd = useCallback((playerAddr, power) => {
  if (window.shatterTube) {
    window.shatterTube(playerAddr)
  }
  handleFlipCoin(playerAddr, power)
}, [handleFlipCoin])

const handlePowerChange = useCallback((power) => {
  setPowerLevel(power)
}, [])

Phase 2: Test Tube Visual Upgrade
Changes to SimpleCoinTubes.jsx
Add these new refs and state at the top:
jsxconst liquidMeshesRef = useRef(new Map())
const bubbleSystemsRef = useRef(new Map())
const glassShardSystemsRef = useRef(new Map())
const tubeStatesRef = useRef(new Map()) // 'intact', 'heating', 'shattering', 'shattered', 'rebuilding'
Replace the createTubes function:
jsxconst createTubes = (scene) => {
  const tubeWidth = 140
  const tubeHeight = 500
  const tubeRadius = 70
  const spacing = 320
  const startX = -((spacing * 5) / 2)

  for (let i = 0; i < 6; i++) {
    const x = startX + (i * spacing)

    // Glass tube - transparent material
    const tubeGeometry = new THREE.CylinderGeometry(tubeRadius, tubeRadius, tubeHeight, 32, 1, true)
    const glassMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x88ccff,
      transparent: true,
      opacity: 0.3,
      roughness: 0.1,
      metalness: 0.1,
      transmission: 0.9,
      thickness: 0.5,
      envMapIntensity: 1,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
      side: THREE.DoubleSide
    })
    
    const tube = new THREE.Mesh(tubeGeometry, glassMaterial)
    tube.position.set(x, 0, 0)
    tube.rotation.x = 0 // Vertical orientation
    scene.add(tube)

    // Tube rim (top and bottom)
    const rimGeometry = new THREE.TorusGeometry(tubeRadius, 3, 16, 32)
    const rimMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      metalness: 0.8,
      roughness: 0.2,
      emissive: 0x00ffff,
      emissiveIntensity: 0.3
    })
    
    const topRim = new THREE.Mesh(rimGeometry, rimMaterial)
    topRim.position.set(x, tubeHeight / 2, 0)
    topRim.rotation.x = Math.PI / 2
    scene.add(topRim)
    
    const bottomRim = new THREE.Mesh(rimGeometry, rimMaterial)
    bottomRim.position.set(x, -tubeHeight / 2, 0)
    bottomRim.rotation.x = Math.PI / 2
    scene.add(bottomRim)

    // Liquid inside tube
    const liquidHeight = 150
    const liquidGeometry = new THREE.CylinderGeometry(tubeRadius - 5, tubeRadius - 5, liquidHeight, 32)
    const liquidMaterial = new THREE.MeshStandardMaterial({
      color: 0xff1493, // Pink/purple liquid
      transparent: true,
      opacity: 0.7,
      metalness: 0.3,
      roughness: 0.3,
      emissive: 0xff1493,
      emissiveIntensity: 0.2
    })
    
    const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial)
    liquid.position.set(x, -(tubeHeight / 2) + (liquidHeight / 2), 0)
    scene.add(liquid)

    // Burner platform (placeholder for now)
    const platformGeometry = new THREE.CylinderGeometry(tubeRadius + 10, tubeRadius + 10, 10, 32)
    const platformMaterial = new THREE.MeshStandardMaterial({
      color: 0x333333,
      metalness: 0.7,
      roughness: 0.3
    })
    const platform = new THREE.Mesh(platformGeometry, platformMaterial)
    platform.position.set(x, -(tubeHeight / 2) - 20, 0)
    scene.add(platform)

    tubesRef.current[i] = { 
      x, 
      tubeHeight, 
      tubeRadius,
      tube, 
      topRim,
      bottomRim,
      liquid,
      platform,
      liquidBaseHeight: liquidHeight,
      liquidBaseY: -(tubeHeight / 2) + (liquidHeight / 2)
    }

    liquidMeshesRef.current.set(i, liquid)
    tubeStatesRef.current.set(i, 'intact')
  }
}

Phase 3: Particle Systems
Add after createTubes function:
jsx// Create bubble particle system for heating effect
const createBubbleSystem = (x, y, tubeRadius) => {
  const particleCount = 50
  const geometry = new THREE.BufferGeometry()
  const positions = new Float32Array(particleCount * 3)
  const velocities = []
  const lifetimes = []

  for (let i = 0; i < particleCount; i++) {
    positions[i * 3] = x + (Math.random() - 0.5) * tubeRadius * 1.5
    positions[i * 3 + 1] = y
    positions[i * 3 + 2] = (Math.random() - 0.5) * tubeRadius * 1.5
    
    velocities.push({
      x: (Math.random() - 0.5) * 0.5,
      y: Math.random() * 2 + 1,
      z: (Math.random() - 0.5) * 0.5
    })
    
    lifetimes.push(Math.random())
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))

  const material = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 5,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending
  })

  const particles = new THREE.Points(geometry, material)
  particles.visible = false

  return {
    mesh: particles,
    velocities,
    lifetimes,
    active: false
  }
}

// Create glass shard system for shattering
const createGlassShardSystem = (x, y, tubeRadius, tubeHeight) => {
  const shardCount = 80
  const shards = []

  for (let i = 0; i < shardCount; i++) {
    // Random triangle shard
    const size = Math.random() * 15 + 5
    const geometry = new THREE.BufferGeometry()
    const vertices = new Float32Array([
      0, 0, 0,
      size, 0, 0,
      size * 0.5, size, 0
    ])
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))

    const material = new THREE.MeshPhysicalMaterial({
      color: 0x88ccff,
      transparent: true,
      opacity: 0.6,
      roughness: 0.1,
      metalness: 0.1,
      transmission: 0.8,
      side: THREE.DoubleSide
    })

    const shard = new THREE.Mesh(geometry, material)
    
    // Position along tube surface
    const angle = (i / shardCount) * Math.PI * 2
    const heightPos = (Math.random() - 0.5) * tubeHeight
    shard.position.set(
      x + Math.cos(angle) * tubeRadius,
      heightPos,
      Math.sin(angle) * tubeRadius
    )

    // Random rotation
    shard.rotation.set(
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2
    )

    // Velocity (explode outward)
    const velocity = {
      x: Math.cos(angle) * (Math.random() * 3 + 2),
      y: Math.random() * 2 - 1,
      z: Math.sin(angle) * (Math.random() * 3 + 2)
    }

    // Rotation velocity
    const rotVelocity = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2,
      z: (Math.random() - 0.5) * 0.2
    }

    shard.visible = false

    shards.push({
      mesh: shard,
      velocity,
      rotVelocity,
      lifetime: 0
    })
  }

  return shards
}

Phase 4: Animation Functions
Add these functions before the return statement:
jsx// Start heating animation
window.startTubeHeating = (playerAddr) => {
  const tubeIndex = playerOrder.indexOf(playerAddr)
  if (tubeIndex === -1) return

  const tubeData = tubesRef.current[tubeIndex]
  const liquid = liquidMeshesRef.current.get(tubeIndex)
  
  if (!liquid) return

  tubeStatesRef.current.set(tubeIndex, 'heating')

  // Create bubble system if doesn't exist
  if (!bubbleSystemsRef.current.has(tubeIndex)) {
    const bubbleSystem = createBubbleSystem(
      tubeData.x,
      tubeData.liquidBaseY,
      tubeData.tubeRadius
    )
    sceneRef.current.add(bubbleSystem.mesh)
    bubbleSystemsRef.current.set(tubeIndex, bubbleSystem)
  }

  const bubbleSystem = bubbleSystemsRef.current.get(tubeIndex)
  bubbleSystem.active = true
  bubbleSystem.mesh.visible = true

  // Animate liquid rising and bubbling
  const startTime = Date.now()
  const animate = () => {
    if (tubeStatesRef.current.get(tubeIndex) !== 'heating') return

    const elapsed = Date.now() - startTime
    const progress = Math.min(elapsed / 3000, 1)

    // Rise liquid
    const newHeight = tubeData.liquidBaseHeight * (1 + progress * 0.3)
    liquid.scale.y = 1 + progress * 0.3
    liquid.position.y = tubeData.liquidBaseY + (progress * 30)

    // Pulse liquid color
    const intensity = 0.2 + Math.sin(elapsed * 0.005) * 0.1
    liquid.material.emissiveIntensity = intensity

    // Update bubbles
    const positions = bubbleSystem.mesh.geometry.attributes.position.array
    for (let i = 0; i < bubbleSystem.velocities.length; i++) {
      positions[i * 3] += bubbleSystem.velocities[i].x
      positions[i * 3 + 1] += bubbleSystem.velocities[i].y
      positions[i * 3 + 2] += bubbleSystem.velocities[i].z

      bubbleSystem.lifetimes[i] += 0.01

      // Reset bubble if too high or lifetime exceeded
      if (positions[i * 3 + 1] > tubeData.liquidBaseY + 100 || bubbleSystem.lifetimes[i] > 1) {
        positions[i * 3] = tubeData.x + (Math.random() - 0.5) * tubeData.tubeRadius * 1.5
        positions[i * 3 + 1] = tubeData.liquidBaseY
        positions[i * 3 + 2] = (Math.random() - 0.5) * tubeData.tubeRadius * 1.5
        bubbleSystem.lifetimes[i] = 0
      }
    }
    bubbleSystem.mesh.geometry.attributes.position.needsUpdate = true

    requestAnimationFrame(animate)
  }
  animate()
}

// Shatter tube animation
window.shatterTube = (playerAddr) => {
  const tubeIndex = playerOrder.indexOf(playerAddr)
  if (tubeIndex === -1) return

  const tubeData = tubesRef.current[tubeIndex]
  tubeStatesRef.current.set(tubeIndex, 'shattering')

  // Hide tube
  tubeData.tube.visible = false
  tubeData.topRim.visible = false
  tubeData.bottomRim.visible = false

  // Stop bubbles
  const bubbleSystem = bubbleSystemsRef.current.get(tubeIndex)
  if (bubbleSystem) {
    bubbleSystem.active = false
    bubbleSystem.mesh.visible = false
  }

  // Create and animate glass shards
  if (!glassShardSystemsRef.current.has(tubeIndex)) {
    const shards = createGlassShardSystem(
      tubeData.x,
      0,
      tubeData.tubeRadius,
      tubeData.tubeHeight
    )
    shards.forEach(shard => sceneRef.current.add(shard.mesh))
    glassShardSystemsRef.current.set(tubeIndex, shards)
  }

  const shards = glassShardSystemsRef.current.get(tubeIndex)
  shards.forEach(shard => {
    shard.mesh.visible = true
    shard.lifetime = 0
  })

  // Animate shards
  const startTime = Date.now()
  const duration = 2000

  const animate = () => {
    const elapsed = Date.now() - startTime
    if (elapsed > duration) {
      tubeStatesRef.current.set(tubeIndex, 'shattered')
      shards.forEach(shard => shard.mesh.visible = false)
      return
    }

    const progress = elapsed / duration

    shards.forEach(shard => {
      // Apply velocity
      shard.mesh.position.x += shard.velocity.x
      shard.mesh.position.y += shard.velocity.y
      shard.mesh.position.z += shard.velocity.z

      // Apply gravity
      shard.velocity.y -= 0.05

      // Rotation
      shard.mesh.rotation.x += shard.rotVelocity.x
      shard.mesh.rotation.y += shard.rotVelocity.y
      shard.mesh.rotation.z += shard.rotVelocity.z

      // Fade out
      shard.mesh.material.opacity = 0.6 * (1 - progress)
    })

    requestAnimationFrame(animate)
  }
  animate()

  // Schedule rebuild
  setTimeout(() => {
    rebuildTube(tubeIndex)
  }, 3000)
}

// Rebuild tube animation
const rebuildTube = (tubeIndex) => {
  const tubeData = tubesRef.current[tubeIndex]
  tubeStatesRef.current.set(tubeIndex, 'rebuilding')

  // Reset liquid
  const liquid = liquidMeshesRef.current.get(tubeIndex)
  liquid.scale.y = 1
  liquid.position.y = tubeData.liquidBaseY
  liquid.material.emissiveIntensity = 0.2

  // Animate tube rebuild (fade in)
  let opacity = 0
  const animate = () => {
    opacity += 0.02
    if (opacity >= 0.3) {
      opacity = 0.3
      tubeData.tube.visible = true
      tubeData.topRim.visible = true
      tubeData.bottomRim.visible = true
      tubeStatesRef.current.set(tubeIndex, 'intact')
      return
    }

    tubeData.tube.material.opacity = opacity
    tubeData.tube.visible = true
    tubeData.topRim.visible = true
    tubeData.bottomRim.visible = true

    requestAnimationFrame(animate)
  }
  animate()
}

Phase 5: Player Card Updates
Changes to SimplePlayerCards.jsx
Update the FlipButton section to include power-up mechanics:
jsx{!slot.player.choice ? (
  <div style={{ display: 'flex', gap: '0.5rem', width: '100%' }}>
    <FlipButton
      onClick={() => onChoiceSelect('heads')}
      style={{ flex: 1, background: 'linear-gradient(135deg, #FFD700, #FFA500)' }}
      disabled={disabled}
    >
      Heads
    </FlipButton>
    <FlipButton
      onClick={() => onChoiceSelect('tails')}
      style={{ flex: 1, background: 'linear-gradient(135deg, #C0C0C0, #A0A0A0)' }}
      disabled={disabled}
    >
      Tails
    </FlipButton>
  </div>
) : !slot.player.hasFired ? (
  <>
    <PowerMeter>
      <PowerFill style={{ width: `${powerLevel}%` }} />
    </PowerMeter>
    <FlipButton
      onMouseDown={() => {
        startPowerUp(slot.playerAddr)
      }}
      onMouseUp={() => {
        stopPowerUp(slot.playerAddr)
      }}
      onTouchStart={() => {
        startPowerUp(slot.playerAddr)
      }}
      onTouchEnd={() => {
        stopPowerUp(slot.playerAddr)
      }}
      disabled={disabled}
    >
      ðŸš€ HOLD TO POWER
    </FlipButton>
  </>
) : (
  <FlipButton disabled>
    âœ… Flipped!
  </FlipButton>
)}
Add power meter styled components:
jsxconst PowerMeter = styled.div`
  width: 100%;
  height: 20px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 10px;
  border: 2px solid #00ffff;
  overflow: hidden;
  position: relative;
`

const PowerFill = styled.div`
  height: 100%;
  background: linear-gradient(90deg, 
    #00ff88 0%, 
    #00ffff 30%, 
    #ffff00 60%, 
    #ff8800 80%, 
    #ff0000 100%
  );
  transition: width 0.05s linear;
  box-shadow: 0 0 10px currentColor;
`
Add power-up logic:
jsxconst [powerLevel, setPowerLevel] = useState(0)
const powerIntervalRef = useRef(null)

const startPowerUp = (playerAddr) => {
  if (onPowerStart) onPowerStart(playerAddr)
  
  setPowerLevel(0)
  powerIntervalRef.current = setInterval(() => {
    setPowerLevel(prev => {
      if (prev >= 100) {
        stopPowerUp(playerAddr)
        return 100
      }
      return prev + 2
    })
  }, 50)
}

const stopPowerUp = (playerAddr) => {
  if (powerIntervalRef.current) {
    clearInterval(powerIntervalRef.current)
    powerIntervalRef.current = null
  }
  
  const finalPower = powerLevel
  if (onPowerEnd) onPowerEnd(playerAddr, finalPower)
  setPowerLevel(0)
}

Summary of Changes
This gives you:

âœ… Full screen Three.js with overlaid UI
âœ… Glass test tubes with liquid inside
âœ… Bubbling effect when powering up
âœ… Tube shattering into glass shards
âœ… Tube rebuilding for next round
âœ… Power meter for charging

Next Steps After Implementation:

Fine-tune colors and timing
Add splash effect for coin landing
Add burner flame effect (can use plane + animated gradient for now)
Polish animations

Want me to break any section down further or shall we proceed with implementation?