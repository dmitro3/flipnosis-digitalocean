üéÆ BATTLE ROYALE COMPETITIVE UPDATE - COMPLETE IMPLEMENTATION GUIDE

üìã TABLE OF CONTENTS

Database Migration
Server Logic Updates
Socket Event Handlers
Client Components
Integration & Styling
Testing Checklist


PHASE 1: DATABASE MIGRATION
Step 1.1: Update Database Schema
Create a new file: server/migrations/add_battle_royale_features.sql
sql-- Add new fields to battle_royale_participants table
ALTER TABLE battle_royale_participants ADD COLUMN lives INTEGER DEFAULT 3;
ALTER TABLE battle_royale_participants ADD COLUMN power INTEGER DEFAULT 10;
ALTER TABLE battle_royale_participants ADD COLUMN has_shield BOOLEAN DEFAULT 1;
ALTER TABLE battle_royale_participants ADD COLUMN consecutive_wins INTEGER DEFAULT 0;
ALTER TABLE battle_royale_participants ADD COLUMN has_lightning_round BOOLEAN DEFAULT 0;
ALTER TABLE battle_royale_participants ADD COLUMN total_xp_earned INTEGER DEFAULT 0;
ALTER TABLE battle_royale_participants ADD COLUMN last_xp_drop INTEGER DEFAULT 0;
ALTER TABLE battle_royale_participants ADD COLUMN shield_used_round INTEGER DEFAULT NULL;

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_br_participants_lives ON battle_royale_participants(lives);
CREATE INDEX IF NOT EXISTS idx_br_participants_status ON battle_royale_participants(status);

-- Update existing records to have new default values
UPDATE battle_royale_participants 
SET lives = 3, 
    power = 10, 
    has_shield = 1, 
    consecutive_wins = 0,
    has_lightning_round = 0,
    total_xp_earned = 0
WHERE lives IS NULL;
Step 1.2: Update BattleRoyaleDBService.js
Add these methods to server/services/BattleRoyaleDBService.js:
javascript// Add after existing methods in BattleRoyaleDBService class

async updatePlayerStats(gameId, playerAddress, stats) {
  return new Promise((resolve, reject) => {
    const query = `
      UPDATE battle_royale_participants 
      SET lives = ?,
          power = ?,
          has_shield = ?,
          consecutive_wins = ?,
          has_lightning_round = ?,
          total_xp_earned = ?,
          last_xp_drop = ?
      WHERE game_id = ? AND player_address = ?
    `
    
    this.db.run(query, [
      stats.lives,
      stats.power,
      stats.hasShield ? 1 : 0,
      stats.consecutiveWins,
      stats.hasLightningRound ? 1 : 0,
      stats.totalXPEarned,
      stats.lastXPDrop,
      gameId,
      playerAddress
    ], (err) => {
      if (err) reject(err)
      else resolve()
    })
  })
}

async recordShieldUsage(gameId, playerAddress, roundNumber) {
  return new Promise((resolve, reject) => {
    const query = `
      UPDATE battle_royale_participants 
      SET has_shield = 0,
          shield_used_round = ?
      WHERE game_id = ? AND player_address = ?
    `
    
    this.db.run(query, [roundNumber, gameId, playerAddress], (err) => {
      if (err) reject(err)
      else resolve()
    })
  })
}

PHASE 2: SERVER LOGIC UPDATES
Step 2.1: Update BattleRoyaleGameManager.js
Replace the entire file with this enhanced version:
javascript// BattleRoyaleGameManager.js - ENHANCED VERSION

class BattleRoyaleGameManager {
  constructor() {
    this.games = new Map()
    this.roundTimers = new Map()
  }

  PHASES = {
    FILLING: 'filling',
    STARTING: 'starting',
    ROUND_ACTIVE: 'round_active',
    ROUND_RESULT: 'round_result',
    COMPLETED: 'completed'
  }

  // ===== XP GENERATION SYSTEM =====
  generateXPReward() {
    const roll = Math.random()
    if (roll < 0.40) return { amount: 100, rarity: 'common' }      // 40% - Silver
    if (roll < 0.65) return { amount: 200, rarity: 'uncommon' }    // 25% - Light Blue
    if (roll < 0.80) return { amount: 300, rarity: 'rare' }        // 15% - Blue
    if (roll < 0.90) return { amount: 400, rarity: 'epic' }        // 10% - Dark Blue
    if (roll < 0.95) return { amount: 500, rarity: 'legendary' }   // 5% - Purple-Blue
    if (roll < 0.98) return { amount: 700, rarity: 'mythic' }      // 3% - Gold
    if (roll < 0.995) return { amount: 900, rarity: 'exotic' }     // 1.5% - Neon Purple
    return { amount: 1000, rarity: 'ultimate' }                     // 0.5% - Rainbow Gold
  }

  getXPRarityColor(rarity) {
    const colors = {
      common: '#C0C0C0',      // Silver
      uncommon: '#87CEEB',    // Light Blue
      rare: '#4169E1',        // Blue
      epic: '#000080',        // Dark Blue
      legendary: '#8B00FF',   // Purple-Blue
      mythic: '#FFD700',      // Gold
      exotic: '#9D00FF',      // Neon Purple
      ultimate: '#FF00FF'     // Rainbow Gold
    }
    return colors[rarity] || '#FFFFFF'
  }

  // ===== POWER-BASED FLIP CALCULATION =====
  calculateFlipWithPower(power, choice) {
    // Power ranges from 1-10
    // Odds: 40% at power 1, up to 60% at power 10
    const winChance = 0.40 + (power * 0.02) // 40% + (0-20%)
    const roll = Math.random()
    const playerWins = roll < winChance
    
    // Actual flip result
    const flipResult = Math.random() < 0.5 ? 'heads' : 'tails'
    
    // Determine if player's choice matches (factoring in power boost)
    const actualWin = playerWins ? choice : (choice === 'heads' ? 'tails' : 'heads')
    
    console.log(`üé≤ Flip Calculation: Power=${power}, WinChance=${(winChance*100).toFixed(1)}%, Roll=${(roll*100).toFixed(1)}%, PlayerWins=${playerWins}`)
    
    return {
      flipResult: actualWin, // The result that benefits/hurts the player based on power
      playerWon: playerWins
    }
  }

  // ===== CREATE GAME =====
  createBattleRoyale(gameId, gameData, dbService = null) {
    console.log(`üéÆ Creating Battle Royale: ${gameId}`)
    
    const game = {
      gameId,
      phase: this.PHASES.FILLING,
      maxPlayers: 6,
      currentPlayers: gameData.current_players || 0,
      entryFee: gameData.entry_fee || 5.00,
      serviceFee: gameData.service_fee || 0.50,
      creator: gameData.creator,
      players: {},
      playerSlots: [null, null, null, null, null, null],
      activePlayers: [],
      currentRound: 0,
      roundCountdown: null,
      lightningRoundActive: false, // NEW
      lightningRoundActivator: null, // NEW
      nftContract: gameData.nft_contract,
      nftTokenId: gameData.nft_token_id,
      nftName: gameData.nft_name,
      nftImage: gameData.nft_image,
      nftCollection: gameData.nft_collection,
      nftChain: gameData.nft_chain || 'base',
      winner: null,
      createdAt: new Date().toISOString()
    }

    this.games.set(gameId, game)
    
    // Auto-add creator if they participate
    if (gameData.creator_participates === true || gameData.creator_participates === 1) {
      this.addCreatorAsPlayer(gameId, gameData.creator)
    }
    
    return game
  }

  // ===== ADD CREATOR =====
  addCreatorAsPlayer(gameId, creatorAddress) {
    const game = this.games.get(gameId)
    const normalizedAddress = creatorAddress.toLowerCase()
    
    if (!game || game.players[normalizedAddress]) return

    game.players[normalizedAddress] = {
      address: creatorAddress,
      slotNumber: 0,
      isCreator: true,
      entryPaid: true,
      status: 'active',
      // NEW COMPETITIVE FIELDS
      lives: 3,
      power: 10,
      hasShield: true,
      consecutiveWins: 0,
      hasLightningRound: false,
      totalXPEarned: 0,
      lastXPDrop: 0,
      // Existing fields
      coin: { 
        id: 'plain', 
        type: 'default', 
        name: 'Classic',
        headsImage: '/coins/plainh.png',
        tailsImage: '/coins/plaint.png'
      },
      choice: null,
      hasFlipped: false,
      flipResult: null,
      joinedAt: new Date().toISOString()
    }

    game.playerSlots[0] = normalizedAddress
    game.activePlayers.push(normalizedAddress)
    game.currentPlayers = 1

    console.log(`‚úÖ Creator added: ${creatorAddress}`)
  }

  // ===== ADD PLAYER =====
  addPlayer(gameId, playerAddress) {
    const game = this.games.get(gameId)
    if (!game || game.phase !== this.PHASES.FILLING) return false
    if (game.currentPlayers >= 6) return false
    
    const normalizedAddress = playerAddress.toLowerCase()
    
    if (game.players[normalizedAddress]) {
      console.log(`‚ö†Ô∏è Player ${playerAddress} already in game`)
      return false
    }

    const slotIndex = game.playerSlots.findIndex(slot => slot === null)
    if (slotIndex === -1) return false

    game.players[normalizedAddress] = {
      address: playerAddress,
      slotNumber: slotIndex,
      isCreator: false,
      entryPaid: true,
      status: 'active',
      // NEW COMPETITIVE FIELDS
      lives: 3,
      power: 10,
      hasShield: true,
      consecutiveWins: 0,
      hasLightningRound: false,
      totalXPEarned: 0,
      lastXPDrop: 0,
      // Existing fields
      coin: { 
        id: 'plain', 
        type: 'default', 
        name: 'Classic',
        headsImage: '/coins/plainh.png',
        tailsImage: '/coins/plaint.png'
      },
      choice: null,
      hasFlipped: false,
      flipResult: null,
      joinedAt: new Date().toISOString()
    }

    game.playerSlots[slotIndex] = normalizedAddress
    game.activePlayers.push(normalizedAddress)
    game.currentPlayers++

    console.log(`‚úÖ Player joined: ${playerAddress} (${game.currentPlayers}/6)`)

    if (game.currentPlayers === 6) {
      game.readyToStart = true
    }

    return true
  }

  // ===== START GAME =====
  prepareGameStart(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game) return false

    console.log(`üöÄ Starting game: ${gameId}`)
    game.phase = this.PHASES.STARTING

    broadcastFn(`game_${gameId}`, 'battle_royale_starting', {
      gameId,
      countdown: 3
    })

    setTimeout(() => {
      this.startNextRound(gameId, broadcastFn)
    }, 3000)

    return true
  }

  // ===== START ROUND =====
  startNextRound(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game) return false

    // Check win condition
    if (game.activePlayers.length <= 1) {
      return this.completeGame(gameId, broadcastFn)
    }

    game.currentRound++
    game.phase = this.PHASES.ROUND_ACTIVE
    game.roundCountdown = game.lightningRoundActive ? 5 : 20 // Lightning Round = 5 seconds!
    game.lightningRoundActive = false // Reset after use

    // Reset player round states (but keep lives, power, etc.)
    game.activePlayers.forEach(addr => {
      const player = game.players[addr]
      if (player) {
        player.choice = null
        player.hasFlipped = false
        player.flipResult = null
        player.lastXPDrop = 0 // Reset XP for new round
      }
    })

    console.log(`üéØ Round ${game.currentRound} started (${game.activePlayers.length} players)`)

    broadcastFn(`game_${gameId}`, 'battle_royale_round_start', {
      gameId,
      round: game.currentRound,
      lightningRound: game.lightningRoundActive
    })

    this.broadcastState(gameId, broadcastFn)

    // Countdown timer
    const timer = setInterval(() => {
      game.roundCountdown--
      
      if (game.roundCountdown <= 0) {
        clearInterval(timer)
        this.endRound(gameId, broadcastFn)
      } else {
        this.broadcastState(gameId, broadcastFn)
      }
    }, 1000)

    this.roundTimers.set(gameId, timer)
    return true
  }

  // ===== PLAYER CHOICE =====
  setPlayerChoice(gameId, playerAddress, choice) {
    const game = this.games.get(gameId)
    if (!game || game.phase !== this.PHASES.ROUND_ACTIVE) return false

    const normalizedAddress = playerAddress.toLowerCase()
    const player = game.players[normalizedAddress]
    if (!player || player.hasFlipped || player.status !== 'active') return false

    player.choice = choice
    console.log(`üéØ ${playerAddress} chose ${choice}`)
    return true
  }

  // ===== FLIP COIN (WITH POWER) =====
  executePlayerFlip(gameId, playerAddress, power, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game || game.phase !== this.PHASES.ROUND_ACTIVE) return false

    const normalizedAddress = playerAddress.toLowerCase()
    const player = game.players[normalizedAddress]
    if (!player || player.hasFlipped || !player.choice || player.status !== 'active') return false

    // Calculate flip result based on power
    const { flipResult, playerWon } = this.calculateFlipWithPower(power, player.choice)
    
    // Generate XP reward
    const xpReward = this.generateXPReward()
    
    player.hasFlipped = true
    player.flipResult = flipResult
    player.flipPower = power
    player.lastXPDrop = xpReward.amount
    player.totalXPEarned += xpReward.amount

    console.log(`ü™ô ${playerAddress} flipped: ${flipResult} (Power: ${power}, Won: ${playerWon}, XP: +${xpReward.amount})`)

    // Broadcast flip with XP
    broadcastFn(`game_${gameId}`, 'battle_royale_player_flipped', {
      gameId,
      playerAddress,
      flipResult,
      flipPower: power,
      xpReward: {
        amount: xpReward.amount,
        rarity: xpReward.rarity,
        color: this.getXPRarityColor(xpReward.rarity)
      }
    })

    this.broadcastState(gameId, broadcastFn)
    return true
  }

  // ===== DEPLOY SHIELD =====
  deployShield(gameId, playerAddress, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game) return false

    const normalizedAddress = playerAddress.toLowerCase()
    const player = game.players[normalizedAddress]
    
    if (!player || !player.hasShield || player.status !== 'active') {
      console.log(`‚ùå ${playerAddress} cannot deploy shield`)
      return false
    }

    player.hasShield = false
    player.shieldActive = true // Mark shield as active for this round
    
    console.log(`üõ°Ô∏è ${playerAddress} deployed shield!`)
    
    broadcastFn(`game_${gameId}`, 'battle_royale_shield_deployed', {
      gameId,
      playerAddress
    })

    this.broadcastState(gameId, broadcastFn)
    return true
  }

  // ===== ACTIVATE LIGHTNING ROUND =====
  activateLightningRound(gameId, playerAddress, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game || game.phase !== this.PHASES.ROUND_ACTIVE) return false

    const normalizedAddress = playerAddress.toLowerCase()
    const player = game.players[normalizedAddress]
    
    if (!player || !player.hasLightningRound || player.status !== 'active') {
      console.log(`‚ùå ${playerAddress} cannot activate Lightning Round`)
      return false
    }

    // Consume the ability
    player.hasLightningRound = false
    game.lightningRoundActive = true
    game.lightningRoundActivator = playerAddress
    
    // Force countdown to 5 seconds
    game.roundCountdown = Math.min(game.roundCountdown, 5)
    
    console.log(`‚ö° ${playerAddress} activated LIGHTNING ROUND!`)
    
    broadcastFn(`game_${gameId}`, 'battle_royale_lightning_activated', {
      gameId,
      playerAddress,
      newCountdown: game.roundCountdown
    })

    this.broadcastState(gameId, broadcastFn)
    return true
  }

  // ===== END ROUND (WITH NEW MECHANICS) =====
  endRound(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game) return false

    console.log(`üèÅ Ending round ${game.currentRound}`)

    const timer = this.roundTimers.get(gameId)
    if (timer) {
      clearInterval(timer)
      this.roundTimers.delete(gameId)
    }

    // Auto-flip for players who didn't flip
    game.activePlayers.forEach(addr => {
      const player = game.players[addr]
      if (!player.hasFlipped) {
        console.log(`‚ö†Ô∏è Auto-flipping for ${addr}`)
        if (!player.choice) player.choice = 'heads'
        
        const { flipResult } = this.calculateFlipWithPower(1, player.choice) // Minimum power
        const xpReward = this.generateXPReward()
        
        player.flipResult = flipResult
        player.hasFlipped = true
        player.lastXPDrop = xpReward.amount
        player.totalXPEarned += xpReward.amount
      }
    })

    // Determine survivors and eliminations
    const results = []
    const eliminated = []
    const survived = []

    game.activePlayers.forEach(addr => {
      const player = game.players[addr]
      const won = player.flipResult === player.choice
      
      if (won) {
        // WINNER
        player.consecutiveWins++
        
        // Award Lightning Round after 3 consecutive wins
        if (player.consecutiveWins === 3 && !player.hasLightningRound) {
          player.hasLightningRound = true
          console.log(`‚ö° ${addr} earned Lightning Round!`)
          
          broadcastFn(`game_${gameId}`, 'battle_royale_lightning_earned', {
            gameId,
            playerAddress: addr
          })
        }
        
        survived.push(addr)
      } else {
        // LOSER
        player.consecutiveWins = 0 // Reset streak
        
        // Check for shield
        if (player.shieldActive) {
          console.log(`üõ°Ô∏è ${addr} saved by shield!`)
          player.shieldActive = false
          survived.push(addr)
          
          broadcastFn(`game_${gameId}`, 'battle_royale_shield_saved', {
            gameId,
            playerAddress: addr
          })
        } else {
          // Lose a life
          player.lives--
          
          // Drain power
          player.power = Math.max(1, player.power - 2)
          
          if (player.lives <= 0) {
            // ELIMINATED
            eliminated.push(addr)
            player.status = 'eliminated'
            player.eliminatedInRound = game.currentRound
            console.log(`üíÄ ${addr} ELIMINATED (0 lives)`)
          } else {
            // Survived with reduced lives
            survived.push(addr)
            console.log(`‚ù§Ô∏è ${addr} lost a life (${player.lives} remaining)`)
          }
        }
      }

      results.push({
        address: addr,
        choice: player.choice,
        result: player.flipResult,
        won,
        lives: player.lives,
        power: player.power,
        xpEarned: player.lastXPDrop,
        eliminated: player.status === 'eliminated'
      })
    })

    // Handle edge cases
    if (eliminated.length === 0 && survived.length > 1) {
      console.log(`‚úÖ All players survived! Continuing...`)
      
      broadcastFn(`game_${gameId}`, 'battle_royale_round_end', {
        gameId,
        round: game.currentRound,
        results,
        eliminatedPlayers: [],
        survivingPlayers: survived,
        message: 'All players survived! Next round...'
      })

      this.broadcastState(gameId, broadcastFn)
      setTimeout(() => this.startNextRound(gameId, broadcastFn), 5000)
      return true
    }

    if (survived.length === 0) {
      console.log(`‚ö†Ô∏è All players lost! Replaying round...`)
      
      // Reset for replay
      game.activePlayers.forEach(addr => {
        const player = game.players[addr]
        player.choice = null
        player.hasFlipped = false
        player.flipResult = null
        player.shieldActive = false
      })

      broadcastFn(`game_${gameId}`, 'battle_royale_round_end', {
        gameId,
        round: game.currentRound,
        results,
        eliminatedPlayers: [],
        survivingPlayers: game.activePlayers,
        message: 'All players lost! Replaying round...'
      })

      this.broadcastState(gameId, broadcastFn)
      
      setTimeout(() => {
        game.phase = this.PHASES.ROUND_ACTIVE
        game.roundCountdown = 20

        broadcastFn(`game_${gameId}`, 'battle_royale_round_start', {
          gameId,
          round: game.currentRound,
          isReplay: true
        })

        this.broadcastState(gameId, broadcastFn)

        const timer = setInterval(() => {
          game.roundCountdown--
          
          if (game.roundCountdown <= 0) {
            clearInterval(timer)
            this.endRound(gameId, broadcastFn)
          } else {
            this.broadcastState(gameId, broadcastFn)
          }
        }, 1000)

        this.roundTimers.set(gameId, timer)
      }, 5000)
      
      return true
    }

    // Normal elimination
    game.activePlayers = survived

    console.log(`üìä Round results: ${eliminated.length} eliminated, ${survived.length} survived`)

    broadcastFn(`game_${gameId}`, 'battle_royale_round_end', {
      gameId,
      round: game.currentRound,
      results,
      eliminatedPlayers: eliminated,
      survivingPlayers: survived
    })

    this.broadcastState(gameId, broadcastFn)

    // Check for winner
    if (game.activePlayers.length <= 1) {
      setTimeout(() => this.completeGame(gameId, broadcastFn), 3000)
    } else {
      setTimeout(() => this.startNextRound(gameId, broadcastFn), 5000)
    }

    return true
  }

  // ===== COMPLETE GAME =====
  completeGame(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game) return false

    game.phase = this.PHASES.COMPLETED
    game.winner = game.activePlayers[0] || null

    console.log(`üèÜ Game complete: ${game.winner || 'No winner'}`)

    broadcastFn(`game_${gameId}`, 'battle_royale_game_complete', {
      gameId,
      winner: game.winner,
      totalRounds: game.currentRound
    })

    this.broadcastState(gameId, broadcastFn)
    return true
  }

  // ===== UPDATE COIN =====
  async updatePlayerCoin(gameId, playerAddress, coinData, dbService = null) {
    let game = this.games.get(gameId)
    if (!game && dbService) {
      game = await this.loadGameFromDatabase(gameId, dbService)
    }
    
    if (!game) return false

    if (game.phase !== this.PHASES.FILLING && game.phase !== this.PHASES.STARTING) {
      return false
    }

    const normalizedAddress = playerAddress.toLowerCase()
    const player = game.players[normalizedAddress]
    
    if (!player) return false

    player.coin = coinData
    console.log(`‚úÖ Coin updated for ${playerAddress}`)
    return true
  }

  // ===== STATE MANAGEMENT =====
  getGame(gameId) {
    return this.games.get(gameId)
  }

  async loadGameFromDatabase(gameId, dbService) {
    if (this.games.has(gameId)) {
      return this.games.get(gameId)
    }

    try {
      const gameData = await dbService.getBattleRoyaleGame(gameId)
      if (gameData && gameData.status === 'filling') {
        console.log(`üìÑ Loading game from database: ${gameId}`)
        return this.createBattleRoyale(gameId, gameData, dbService)
      }
    } catch (error) {
      console.error(`‚ùå Error loading game ${gameId}:`, error)
    }

    return null
  }

  getFullGameState(gameId) {
    const game = this.games.get(gameId)
    if (!game) return null

    return {
      gameId: game.gameId,
      phase: game.phase,
      maxPlayers: game.maxPlayers,
      currentPlayers: game.currentPlayers,
      entryFee: game.entryFee,
      serviceFee: game.serviceFee,
      creator: game.creator,
      players: game.players,
      playerSlots: game.playerSlots,
      activePlayers: game.activePlayers,
      currentRound: game.currentRound,
      roundCountdown: game.roundCountdown,
      lightningRoundActive: game.lightningRoundActive,
      nftName: game.nftName,
      nftImage: game.nftImage,
      nftCollection: game.nftCollection,
      nftContract: game.nftContract,
      nftTokenId: game.nftTokenId,
      nftChain: game.nftChain,
      winner: game.winner
    }
  }

  broadcastState(gameId, broadcastFn) {
    const state = this.getFullGameState(gameId)
    if (state) {
      broadcastFn(`game_${gameId}`, 'battle_royale_state_update', state)
    }
  }

  removeGame(gameId) {
    const timer = this.roundTimers.get(gameId)
    if (timer) {
      clearInterval(timer)
      this.roundTimers.delete(gameId)
    }
    this.games.delete(gameId)
    console.log(`üóëÔ∏è Game removed: ${gameId}`)
  }
}

module.exports = BattleRoyaleGameManager

PHASE 3: SOCKET EVENT HANDLERS
Step 3.1: Update BattleRoyaleSocketHandlers.js
Add these new handlers to server/socket/BattleRoyaleSocketHandlers.js:
javascript// ADD THESE NEW METHODS to the BattleRoyaleSocketHandlers class

// Deploy shield
async handleBattleRoyaleDeployShield(socket, data, gameManager, io) {
  const { gameId, address } = data
  console.log(`üõ°Ô∏è ${address} deploying shield`)
  
  const success = gameManager.deployShield(gameId, address, (room, event, data) => {
    io.to(room).emit(event, data)
  })
  
  if (!success) {
    socket.emit('battle_royale_error', { message: 'Cannot deploy shield' })
  }
}

// Activate Lightning Round
async handleBattleRoyaleActivateLightning(socket, data, gameManager, io) {
  const { gameId, address } = data
  console.log(`‚ö° ${address} activating Lightning Round`)
  
  const success = gameManager.activateLightningRound(gameId, address, (room, event, data) => {
    io.to(room).emit(event, data)
  })
  
  if (!success) {
    socket.emit('battle_royale_error', { message: 'Cannot activate Lightning Round' })
  }
}

// Export at end of file
module.exports = BattleRoyaleSocketHandlers
Step 3.2: Update server-socketio.js
Add the new event listeners in server/socket/server-socketio.js:
javascript// ADD THESE TWO NEW EVENT LISTENERS in the setupEventHandlers() method
// Add after existing battle royale handlers

socket.on('battle_royale_deploy_shield', safeHandler((data) => {
  console.log(`üî• battle_royale_deploy_shield from ${socket.id}`, data)
  return this.battleRoyaleHandlers.handleBattleRoyaleDeployShield(
    socket, 
    data, 
    this.battleRoyaleManager, 
    this.io
  )
}))

socket.on('battle_royale_activate_lightning', safeHandler((data) => {
  console.log(`üî• battle_royale_activate_lightning from ${socket.id}`, data)
  return this.battleRoyaleHandlers.handleBattleRoyaleActivateLightning(
    socket, 
    data, 
    this.battleRoyaleManager, 
    this.io
  )
}))

PHASE 4: CLIENT COMPONENTS
Step 4.1: Create XP Rarity Colors Config
Create client/src/constants/xpRarities.js:
javascriptexport const XP_RARITIES = {
  common: {
    color: '#C0C0C0',
    glow: 'rgba(192, 192, 192, 0.5)',
    name: 'Common',
    emoji: 'ü•à'
  },
  uncommon: {
    color: '#87CEEB',
    glow: 'rgba(135, 206, 235, 0.5)',
    name: 'Uncommon',
    emoji: 'üí†'
  },
  rare: {
    color: '#4169E1',
    glow: 'rgba(65, 105, 225, 0.5)',
    name: 'Rare',
    emoji: 'üíé'
  },
  epic: {
    color: '#000080',
    glow: 'rgba(0, 0, 128, 0.5)',
    name: 'Epic',
    emoji: 'üî∑'
  },
  legendary: {
    color: '#8B00FF',
    glow: 'rgba(139, 0, 255, 0.5)',
    name: 'Legendary',
    emoji: 'üíú'
  },
  mythic: {
    color: '#FFD700',
    glow: 'rgba(255, 215, 0, 0.5)',
    name: 'Mythic',
    emoji: 'üèÜ'
  },
  exotic: {
    color: '#9D00FF',
    glow: 'rgba(157, 0, 255, 0.5)',
    name: 'Exotic',
    emoji: '‚ö°'
  },
  ultimate: {
    color: '#FF00FF',
    glow: 'rgba(255, 0, 255, 0.5)',
    name: 'Ultimate',
    emoji: 'üåü'
  }
}
Step 4.2: Create XPRewardDrop Component
Create client/src/components/BattleRoyale/XPRewardDrop.jsx:
jsximport React, { useEffect, useState } from 'react'
import styled from '@emotion/styled'
import { XP_RARITIES } from '../../constants/xpRarities'

const XPContainer = styled.div`
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  animation: floatUp 2s ease-out forwards;
  pointer-events: none;
  z-index: 1000;
  
  @keyframes floatUp {
    0% {
      opacity: 1;
      transform: translateX(-50%) translateY(0) scale(0.8);
    }
    50% {
      transform: translateX(-50%) translateY(-40px) scale(1.2);
    }
    100% {
      opacity: 0;
      transform: translateX(-50%) translateY(-80px) scale(1);
    }
  }
`

const XPText = styled.div`
  font-size: 2rem;
  font-weight: bold;
  color: ${props => props.color};
  text-shadow: 
    0 0 10px ${props => props.glow},
    0 0 20px ${props => props.glow},
    0 0 30px ${props => props.glow};
  font-family: 'Hyperwave', 'Poppins', sans-serif;
  letter-spacing: 2px;
  display: flex;
  align-items: center;
  gap: 0.5rem;
`

const XPRewardDrop = ({ amount, rarity, onComplete }) => {
  const [visible, setVisible] = useState(true)
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(false)
      if (onComplete) onComplete()
    }, 2000)
    
    return () => clearTimeout(timer)
  }, [onComplete])
  
  if (!visible) return null
  
  const rarityData = XP_RARITIES[rarity] || XP_RARITIES.common
  
  return (
    <XPContainer>
      <XPText color={rarityData.color} glow={rarityData.glow}>
        {rarityData.emoji} +{amount} XP
      </XPText>
    </XPContainer>
  )
}

export default XPRewardDrop
Step 4.3: Create PlayerStatsBar Component
Create client/src/components/BattleRoyale/PlayerStatsBar.jsx:
jsximport React from 'react'
import styled from '@emotion/styled'

const StatsContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  padding: 0.75rem;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 0.5rem;
  backdrop-filter: blur(10px);
`

const StatRow = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  font-size: 0.9rem;
`

const LivesDisplay = styled.div`
  display: flex;
  gap: 0.25rem;
  align-items: center;
`

const Heart = styled.span`
  font-size: 1.2rem;
  filter: ${props => props.filled ? 'none' : 'grayscale(100%)'};
  opacity: ${props => props.filled ? 1 : 0.3};
  animation: ${props => props.critical ? 'heartbeat 1s ease-in-out infinite' : 'none'};
  
  @keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
`

const PowerBar = styled.div`
  flex: 1;
  height: 8px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.2);
`

const PowerFill = styled.div`
  height: 100%;
  width: ${props => props.percent}%;
  background: linear-gradient(90deg, 
    #00ffff 0%, 
    #00ff88 50%, 
    #ffff00 100%
  );
  transition: width 0.3s ease;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
`

const AbilityIndicator = styled.div`
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem 0.5rem;
  background: ${props => props.available 
    ? 'linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 140, 0, 0.2))' 
    : 'rgba(100, 100, 100, 0.2)'
  };
  border: 1px solid ${props => props.available ? '#FFD700' : '#666'};
  border-radius: 0.5rem;
  font-size: 0.8rem;
  color: ${props => props.available ? '#FFD700' : '#999'};
  animation: ${props => props.available ? 'abilityGlow 2s ease-in-out infinite' : 'none'};
  
  @keyframes abilityGlow {
    0%, 100% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
    50% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
  }
`

const XPDisplay = styled.div`
  color: #FFD700;
  font-weight: bold;
  text-align: center;
  font-size: 0.9rem;
  text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
`

const PlayerStatsBar = ({ 
  lives, 
  power, 
  hasShield, 
  hasLightningRound, 
  totalXPEarned,
  isCompact = false 
}) => {
  const isCritical = lives === 1
  
  return (
    <StatsContainer>
      {/* Lives */}
      <StatRow>
        <LivesDisplay>
          {[1, 2, 3].map(i => (
            <Heart 
              key={i} 
              filled={i <= lives}
              critical={isCritical && i <= lives}
            >
              {i <= lives ? '‚ù§Ô∏è' : 'üñ§'}
            </Heart>
          ))}
        </LivesDisplay>
      </StatRow>
      
      {/* Power */}
      <StatRow>
        <span style={{ fontSize: '0.8rem', color: '#00ffff' }}>‚ö°</span>
        <PowerBar>
          <PowerFill percent={power * 10} />
        </PowerBar>
        <span style={{ fontSize: '0.8rem', color: '#00ffff', minWidth: '40px' }}>
          {power * 10}%
        </span>
      </StatRow>
      
      {/* Abilities */}
      {!isCompact && (
        <StatRow style={{ flexWrap: 'wrap', gap: '0.25rem' }}>
          <AbilityIndicator available={hasShield}>
            üõ°Ô∏è {hasShield ? 'READY' : 'USED'}
          </AbilityIndicator>
          <AbilityIndicator available={hasLightningRound}>
            ‚ö° {hasLightningRound ? 'READY' : 'LOCKED'}
          </AbilityIndicator>
        </StatRow>
      )}
      
      {/* Total XP */}
      <XPDisplay>
        üåü {totalXPEarned.toLocaleString()} XP
      </XPDisplay>
    </StatsContainer>
  )
}

export default PlayerStatsBar
Step 4.4: Create PlayerCard Component
Create client/src/components/BattleRoyale/PlayerCard.jsx:
jsximport React, { useState, useEffect } from 'react'
import styled from '@emotion/styled'
import BattleRoyaleUnified3DScene from './BattleRoyaleUnified3DScene'
import PlayerStatsBar from './PlayerStatsBar'
import XPRewardDrop from './XPRewardDrop'

const CardContainer = styled.div`
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  padding: 1rem;
  background: linear-gradient(135deg, 
    rgba(20, 20, 40, 0.95) 0%, 
    rgba(40, 20, 60, 0.95) 100%
  );
  border: 2px solid;
  border-image: linear-gradient(45deg, 
    ${props => props.isCurrentUser ? '#00ff88' : '#00ffff'}, 
    ${props => props.isCurrentUser ? '#00cc6a' : '#9d00ff'}
  ) 1;
  border-radius: 1rem;
  box-shadow: 
    0 0 20px ${props => props.isCurrentUser ? 'rgba(0, 255, 136, 0.3)' : 'rgba(0, 255, 255, 0.3)'},
    inset 0 0 60px rgba(255, 0, 255, 0.1);
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
  opacity: ${props => props.eliminated ? 0.3 : 1};
  filter: ${props => props.eliminated ? 'grayscale(100%)' : 'none'};
  
  &:hover {
    transform: ${props => props.eliminated ? 'none' : 'scale(1.02)'};
    box-shadow: 
      0 0 30px ${props => props.isCurrentUser ? 'rgba(0, 255, 136, 0.5)' : 'rgba(0, 255, 255, 0.5)'},
      inset 0 0 80px rgba(255, 0, 255, 0.15);
  }
  
  ${props => props.eliminated && `
    &::after {
      content: 'üíÄ ELIMINATED';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      z-index: 10;
      pointer-events: none;
    }
  `}
`

const SlotBadge = styled.div`
  position: absolute;
  top: 0.5rem;
  left: 0.5rem;
  background: rgba(0, 0, 0, 0.8);
  color: #FFD700;
  padding: 0.25rem 0.5rem;
  border-radius: 0.5rem;
  font-size: 0.8rem;
  font-weight: bold;
  z-index: 5;
`

const CoinViewport = styled.div`
  width: 100%;
  height: ${props => props.large ? '300px' : '200px'};
  position: relative;
  border-radius: 0.5rem;
  overflow: hidden;
  background: radial-gradient(circle, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.95));
`

const PlayerAddress = styled.div`
  color: white;
  font-size: 0.8rem;
  font-family: monospace;
  text-align: center;
  text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
`

const ChoiceIndicator = styled.div`
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  background: rgba(0, 0, 0, 0.9);
  color: ${props => props.choice === 'heads' ? '#FFD700' : '#C0C0C0'};
  border: 2px solid ${props => props.choice === 'heads' ? '#FFD700' : '#C0C0C0'};
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-size: 1rem;
  font-weight: bold;
  text-transform: uppercase;
  z-index: 5;
  box-shadow: 0 0 20px ${props => props.choice === 'heads' ? 'rgba(255, 215, 0, 0.5)' : 'rgba(192, 192, 192, 0.5)'};
`

const PlayerCard = ({ 
  player, 
  slotNumber, 
  isCurrentUser, 
  gamePhase,
  serverState,
  playerCoinImage,
  large = false,
  showXP = true
}) => {
  const [showXPDrop, setShowXPDrop] = useState(false)
  const [lastXP, setLastXP] = useState(0)
  
  const playerData = serverState?.players?.[player.address?.toLowerCase()]
  const eliminated = playerData?.status === 'eliminated'
  const choice = playerData?.choice
  const lastXPDrop = playerData?.lastXPDrop || 0
  
  // Show XP drop animation when player gets XP
  useEffect(() => {
    if (lastXPDrop > 0 && lastXPDrop !== lastXP) {
      setShowXPDrop(true)
      setLastXP(lastXPDrop)
    }
  }, [lastXPDrop, lastXP])
  
  return (
    <CardContainer 
      isCurrentUser={isCurrentUser} 
      eliminated={eliminated}
    >
      <SlotBadge>Slot {slotNumber + 1}</SlotBadge>
      
      {choice && (
        <ChoiceIndicator choice={choice}>
          {choice}
        </ChoiceIndicator>
      )}
      
      <CoinViewport large={large}>
        <BattleRoyaleUnified3DScene
          players={[player]}
          gamePhase={gamePhase}
          serverState={serverState}
          playerCoinImages={{ [player.address?.toLowerCase()]: playerCoinImage }}
          currentUserAddress={null}
          singleCoinMode={true}
        />
        
        {showXP && showXPDrop && lastXPDrop > 0 && (
          <XPRewardDrop
            amount={lastXPDrop}
            rarity={
              lastXPDrop >= 1000 ? 'ultimate' :
              lastXPDrop >= 900 ? 'exotic' :
              lastXPDrop >= 700 ? 'mythic' :
              lastXPDrop >= 500 ? 'legendary' :
              lastXPDrop >= 400 ? 'epic' :
              lastXPDrop >= 300 ? 'rare' :
              lastXPDrop >= 200 ? 'uncommon' : 'common'
            }
            onComplete={() => setShowXPDrop(false)}
          />
        )}
      </CoinViewport>
      
      <PlayerAddress>
        {isCurrentUser ? 'YOU' : `${player.address?.slice(0, 6)}...${player.address?.slice(-4)}`}
      </PlayerAddress>
      
      {playerData && (
        <PlayerStatsBar
          lives={playerData.lives || 3}
          power={playerData.power || 10}
          hasShield={playerData.hasShield || false}
          hasLightningRound={playerData.hasLightningRound || false}
          totalXPEarned={playerData.totalXPEarned || 0}
          isCompact={!large}
        />
      )}
    </CardContainer>
  )
}

export default PlayerCard
Step 4.5: Create DynamicGrid Component
Create client/src/components/BattleRoyale/DynamicGrid.jsx:
jsximport React from 'react'
import styled from '@emotion/styled'
import PlayerCard from './PlayerCard'

const GRID_CONFIGS = {
  6: { columns: 'repeat(3, 1fr)', rows: 'repeat(2, 1fr)', gap: '1rem' },
  5: { columns: 'repeat(3, 1fr)', rows: 'repeat(2, 1fr)', gap: '1.2rem' },
  4: { columns: 'repeat(2, 1fr)', rows: 'repeat(2, 1fr)', gap: '1.5rem' },
  3: { columns: 'repeat(3, 1fr)', rows: '1fr', gap: '2rem' },
  2: { columns: 'repeat(2, 1fr)', rows: '1fr', gap: '3rem' },
  1: { columns: '1fr', rows: '1fr', gap: '0' }
}

const GridContainer = styled.div`
  display: grid;
  grid-template-columns: ${props => GRID_CONFIGS[props.playerCount]?.columns || 'repeat(3, 1fr)'};
  grid-template-rows: ${props => GRID_CONFIGS[props.playerCount]?.rows || 'repeat(2, 1fr)'};
  gap: ${props => GRID_CONFIGS[props.playerCount]?.gap || '1rem'};
  width: 100%;
  height: 100%;
  padding: 2rem;
  transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  
  @media (max-width: 1200px) {
    grid-template-columns: repeat(2, 1fr);
    padding: 1rem;
  }
  
  @media (max-width: 768px) {
    grid-template-columns: 1fr;
    padding: 0.5rem;
  }
`

const DynamicGrid = ({ 
  players, 
  currentUserAddress, 
  gamePhase, 
  serverState,
  playerCoinImages 
}) => {
  const activePlayers = players.filter(p => 
    p && p.address && serverState?.players?.[p.address.toLowerCase()]?.status !== 'eliminated'
  )
  
  return (
    <GridContainer playerCount={activePlayers.length}>
      {activePlayers.map((player, index) => {
        const isCurrentUser = player.address?.toLowerCase() === currentUserAddress?.toLowerCase()
        const coinImage = playerCoinImages[player.address?.toLowerCase()]
        
        return (
          <PlayerCard
            key={player.address}
            player={player}
            slotNumber={player.slotNumber || index}
            isCurrentUser={isCurrentUser}
            gamePhase={gamePhase}
            serverState={serverState}
            playerCoinImage={coinImage}
            large={activePlayers.length <= 2}
            showXP={true}
          />
        )
      })}
    </GridContainer>
  )
}

export default DynamicGrid
I'll continue with Phase 5 in the next response. This is getting long!RetryClaude does not have the ability to run the code it generates yet.Kyes please continueEditPrepared to continue implementation guide from previous phase.The user wants me to continue with Phase 5 and beyond. Let me continue from where I left off with the implementation guide.üéÆ BATTLE ROYALE COMPETITIVE UPDATE - PART 2

PHASE 5: INTEGRATION & STYLING
Step 5.1: Update GameScreen.jsx
Replace the entire client/src/components/BattleRoyale/GameScreen.jsx with this enhanced version:
jsximport React, { useState, useCallback, useRef, useEffect } from 'react'
import styled from '@emotion/styled'
import { useBattleRoyaleGame } from '../../contexts/BattleRoyaleGameContext'
import DynamicGrid from './DynamicGrid'
import FloatingChatWidget from './FloatingChatWidget'
import socketService from '../../services/SocketService'
import './BattleRoyaleCoins.css'

const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 2rem;
  padding: 2rem;
  max-width: 1800px;
  margin: 0 auto;
  min-height: 100vh;
`

const GameLayout = styled.div`
  display: flex;
  gap: 2rem;
  flex: 1;
  
  @media (max-width: 1200px) {
    flex-direction: column;
  }
`

const ArenaContainer = styled.div`
  flex: 2;
  min-height: 700px;
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid #FFD700;
  border-radius: 1rem;
  overflow: hidden;
  position: relative;
  
  @media (max-width: 1200px) {
    min-height: 600px;
  }
`

const ControlPanel = styled.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid #00bfff;
  border-radius: 1rem;
  padding: 2rem;
  backdrop-filter: blur(15px);
  max-width: 500px;
  
  @media (max-width: 1200px) {
    max-width: 100%;
  }
`

const StatusHeader = styled.div`
  text-align: center;
  
  .phase {
    color: #00bfff;
    font-size: 1.2rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 0.5rem;
  }
  
  .timer {
    color: ${props => props.urgent ? '#ff6b6b' : '#00ff88'};
    font-size: 2.5rem;
    font-weight: bold;
    text-shadow: 0 0 20px currentColor;
    animation: ${props => props.urgent ? 'pulse 1s ease-in-out infinite' : 'none'};
  }
  
  .round-info {
    color: #aaa;
    font-size: 0.9rem;
    margin-top: 0.5rem;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.05); }
  }
`

const LightningBanner = styled.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
  border: 3px solid #FFD700;
  border-radius: 1rem;
  padding: 2rem 4rem;
  font-size: 2.5rem;
  font-weight: bold;
  color: #000;
  text-align: center;
  z-index: 100;
  animation: lightningFlash 0.5s ease-in-out infinite;
  box-shadow: 
    0 0 40px rgba(255, 215, 0, 0.8),
    0 0 80px rgba(255, 215, 0, 0.6);
  
  @keyframes lightningFlash {
    0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
  }
`

const ChoiceButtons = styled.div`
  display: flex;
  gap: 1rem;
  justify-content: center;
  
  button {
    padding: 1.2rem 2.5rem;
    border: none;
    border-radius: 1rem;
    font-size: 1.3rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    flex: 1;
    font-family: 'Hyperwave', 'Poppins', sans-serif;
    letter-spacing: 2px;
    position: relative;
    overflow: hidden;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    
    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s;
    }
    
    &:hover:not(:disabled)::before {
      left: 100%;
    }
    
    &.heads {
      background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
      color: #000;
      border: 3px solid #00ff88;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
      
      &:hover:not(:disabled) {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 8px 25px rgba(0, 255, 136, 0.6);
      }
    }
    
    &.tails {
      background: linear-gradient(135deg, #ff1493 0%, #ff69b4 100%);
      color: #fff;
      border: 3px solid #ff1493;
      box-shadow: 0 0 20px rgba(255, 20, 147, 0.4);
      
      &:hover:not(:disabled) {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 8px 25px rgba(255, 20, 147, 0.6);
      }
    }
    
    &.selected {
      border: 4px solid #FFD700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.3);
      animation: selectedPulse 1.5s ease-in-out infinite;
    }
    
    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
  }
  
  @keyframes selectedPulse {
    0%, 100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.3); }
    50% { box-shadow: 0 0 40px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 215, 0, 0.5); }
  }
`

const FlipButton = styled.button`
  background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
  color: #000;
  border: 3px solid #00ff88;
  padding: 1.5rem 3rem;
  border-radius: 2rem;
  font-size: 1.5rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  font-family: 'Hyperwave', 'Poppins', sans-serif;
  letter-spacing: 3px;
  position: relative;
  overflow: hidden;
  user-select: none;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    transition: left 0.5s;
  }
  
  &:hover:not(:disabled)::before {
    left: 100%;
  }
  
  &:hover:not(:disabled) {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 30px rgba(0, 255, 136, 0.5);
  }
  
  &.charging {
    animation: chargeGlow 0.3s ease-in-out infinite;
    box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  
  @keyframes chargeGlow {
    0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
    50% { box-shadow: 0 0 40px rgba(0, 255, 136, 1); }
  }
`

const PowerBarContainer = styled.div`
  margin-top: 1rem;
  background: rgba(0, 0, 0, 0.6);
  border: 2px solid #00bfff;
  border-radius: 1rem;
  padding: 0.8rem;
  text-align: center;
`

const PowerLabel = styled.div`
  color: #00bfff;
  font-size: 0.9rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
  font-family: 'Hyperwave', 'Poppins', sans-serif;
  letter-spacing: 1px;
  text-transform: uppercase;
`

const PowerBarTrack = styled.div`
  width: 100%;
  height: 30px;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 15px;
  overflow: hidden;
  border: 2px solid #00bfff;
  position: relative;
`

const PowerBarFill = styled.div`
  height: 100%;
  background: linear-gradient(90deg, #00ff88 0%, #00ffff 50%, #ffff00 100%);
  border-radius: 15px;
  transition: width 0.1s linear;
  box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
  position: relative;
  
  &::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    animation: shimmer 1s infinite;
  }
  
  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }
`

const PowerValue = styled.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-weight: bold;
  font-size: 0.9rem;
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
  z-index: 1;
  font-family: 'Hyperwave', 'Poppins', sans-serif;
`

const AbilityButton = styled.button`
  padding: 1rem 2rem;
  background: ${props => props.available 
    ? 'linear-gradient(135deg, #FFD700 0%, #FFA500 100%)' 
    : 'rgba(100, 100, 100, 0.3)'
  };
  border: 2px solid ${props => props.available ? '#FFD700' : '#666'};
  border-radius: 1rem;
  color: ${props => props.available ? '#000' : '#999'};
  font-size: 1.1rem;
  font-weight: bold;
  cursor: ${props => props.available ? 'pointer' : 'not-allowed'};
  transition: all 0.3s ease;
  font-family: 'Hyperwave', 'Poppins', sans-serif;
  text-transform: uppercase;
  letter-spacing: 2px;
  
  ${props => props.available && `
    &:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
    }
    
    animation: abilityPulse 2s ease-in-out infinite;
    
    @keyframes abilityPulse {
      0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
      50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
    }
  `}
`

const InfoBox = styled.div`
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 0.5rem;
  padding: 1rem;
  text-align: center;
  color: ${props => props.color || 'white'};
  font-weight: bold;
`

const WinnerDisplay = styled.div`
  text-align: center;
  padding: 2rem;
  
  .trophy {
    font-size: 5rem;
    animation: bounce 1s ease-in-out infinite;
  }
  
  .message {
    color: #FFD700;
    font-size: 2rem;
    font-weight: bold;
    margin: 1rem 0;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
  }
  
  .winner {
    color: white;
    font-size: 1.2rem;
    font-family: monospace;
  }
  
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
  }
`

const GameScreen = () => {
  const { gameState, playerCoinImages, address } = useBattleRoyaleGame()
  const [localChoice, setLocalChoice] = useState(null)
  const [power, setPower] = useState(1)
  const [isCharging, setIsCharging] = useState(false)
  const [showLightningBanner, setShowLightningBanner] = useState(false)
  const chargeIntervalRef = useRef(null)

  if (!gameState) return null

  const player = gameState.players?.[address?.toLowerCase()]
  const isInGame = !!player
  const isEliminated = player?.status === 'eliminated'
  const phase = gameState.phase
  const countdown = gameState.roundCountdown || 0
  const currentRound = gameState.currentRound || 1

  // Build players array for grid
  const scenePlayersArray = (gameState.playerSlots || []).map((addr, idx) => {
    if (!addr) return null
    return {
      address: addr,
      slotNumber: idx,
      ...gameState.players?.[addr.toLowerCase()]
    }
  }).filter(Boolean)

  // Listen for Lightning Round activation
  useEffect(() => {
    const handleLightningActivated = (data) => {
      console.log('‚ö° Lightning Round activated!', data)
      setShowLightningBanner(true)
      setTimeout(() => setShowLightningBanner(false), 3000)
    }

    socketService.on('battle_royale_lightning_activated', handleLightningActivated)

    return () => {
      socketService.off('battle_royale_lightning_activated', handleLightningActivated)
    }
  }, [])

  const handleChoiceClick = useCallback((choice) => {
    if (!isInGame || isEliminated || phase !== 'round_active') return
    
    socketService.emit('battle_royale_player_choice', {
      gameId: gameState.gameId,
      address,
      choice
    })
    
    setLocalChoice(choice)
  }, [isInGame, isEliminated, phase, gameState.gameId, address])

  // Start charging power
  const handleFlipMouseDown = useCallback(() => {
    if (!isInGame || isEliminated || phase !== 'round_active') return
    if (!player.choice || player.hasFlipped) return
    
    setIsCharging(true)
    setPower(1)
    
    chargeIntervalRef.current = setInterval(() => {
      setPower(prev => {
        const newPower = prev + 0.5
        return newPower > 10 ? 10 : newPower
      })
    }, 100)
  }, [isInGame, isEliminated, phase, player])

  // Release and flip
  const handleFlipMouseUp = useCallback(() => {
    if (!isInGame || isEliminated || phase !== 'round_active') return
    if (!player.choice || player.hasFlipped) return
    if (!isCharging) return
    
    if (chargeIntervalRef.current) {
      clearInterval(chargeIntervalRef.current)
      chargeIntervalRef.current = null
    }
    
    setIsCharging(false)
    
    socketService.emit('battle_royale_flip_coin', {
      gameId: gameState.gameId,
      address,
      power: Math.floor(power)
    })
    
    setTimeout(() => setPower(1), 500)
  }, [isInGame, isEliminated, phase, player, gameState.gameId, address, power, isCharging])

  const handleFlipMouseLeave = useCallback(() => {
    if (chargeIntervalRef.current) {
      clearInterval(chargeIntervalRef.current)
      chargeIntervalRef.current = null
    }
    setIsCharging(false)
    setPower(1)
  }, [])

  // Deploy Shield
  const handleDeployShield = useCallback(() => {
    if (!isInGame || isEliminated || !player.hasShield) return
    
    const confirm = window.confirm('Deploy your shield? This will protect you from elimination this round.')
    if (confirm) {
      socketService.emit('battle_royale_deploy_shield', {
        gameId: gameState.gameId,
        address
      })
    }
  }, [isInGame, isEliminated, player, gameState.gameId, address])

  // Activate Lightning Round
  const handleActivateLightning = useCallback(() => {
    if (!isInGame || isEliminated || !player.hasLightningRound) return
    
    const confirm = window.confirm('Activate Lightning Round? All players will have only 5 seconds to choose!')
    if (confirm) {
      socketService.emit('battle_royale_activate_lightning', {
        gameId: gameState.gameId,
        address
      })
    }
  }, [isInGame, isEliminated, player, gameState.gameId, address])

  // PHASE: STARTING
  if (phase === 'starting') {
    return (
      <Container>
        <div style={{
          textAlign: 'center',
          padding: '4rem',
          background: 'rgba(0, 0, 0, 0.8)',
          borderRadius: '1rem',
          border: '2px solid #FFD700'
        }}>
          <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>üöÄ</div>
          <h2 style={{ color: '#FFD700', fontSize: '2rem', margin: '1rem 0' }}>
            Game Starting...
          </h2>
          <p style={{ color: 'white', fontSize: '1.2rem' }}>
            {gameState.currentPlayers} / 6 Players Ready
          </p>
          <p style={{ color: '#aaa', marginTop: '1rem' }}>
            Get ready for Battle Royale!
          </p>
        </div>
      </Container>
    )
  }

  // PHASE: COMPLETED
  if (phase === 'completed') {
    const isWinner = gameState.winner?.toLowerCase() === address?.toLowerCase()
    return (
      <Container>
        <WinnerDisplay>
          <div className="trophy">üèÜ</div>
          <div className="message">
            {isWinner ? 'YOU WON!' : 'GAME OVER'}
          </div>
          <div className="winner">
            Winner: {gameState.winner ? `${gameState.winner.slice(0, 10)}...${gameState.winner.slice(-8)}` : 'None'}
          </div>
          <div style={{ color: '#aaa', marginTop: '1rem' }}>
            Total Rounds: {gameState.currentRound}
          </div>
        </WinnerDisplay>
      </Container>
    )
  }

  // PHASE: ROUND_ACTIVE or ROUND_RESULT
  return (
    <Container>
      <GameLayout>
        {/* ARENA WITH DYNAMIC GRID */}
        <ArenaContainer>
          {showLightningBanner && (
            <LightningBanner>
              ‚ö° LIGHTNING ROUND ‚ö°
            </LightningBanner>
          )}
          
          <DynamicGrid
            players={scenePlayersArray}
            currentUserAddress={address}
            gamePhase={phase}
            serverState={gameState}
            playerCoinImages={playerCoinImages}
          />
        </ArenaContainer>

        {/* CONTROL PANEL */}
        <ControlPanel>
          <StatusHeader urgent={countdown <= 5}>
            <div className="phase">
              {phase === 'round_active' ? '‚öîÔ∏è BATTLE ACTIVE' : 'üìä ROUND ENDING'}
            </div>
            <div className="timer">
              {countdown}s
            </div>
            <div className="round-info">
              Round {currentRound} ‚Ä¢ {gameState.activePlayers?.length || 0} Players Alive
            </div>
          </StatusHeader>

          {isInGame && !isEliminated ? (
            <>
              {/* CHOICE BUTTONS */}
              {phase === 'round_active' && (
                <ChoiceButtons>
                  <button
                    className={`heads ${(localChoice === 'heads' || player.choice === 'heads') ? 'selected' : ''}`}
                    onClick={() => handleChoiceClick('heads')}
                    disabled={player.hasFlipped}
                  >
                    HEADS
                  </button>
                  <button
                    className={`tails ${(localChoice === 'tails' || player.choice === 'tails') ? 'selected' : ''}`}
                    onClick={() => handleChoiceClick('tails')}
                    disabled={player.hasFlipped}
                  >
                    TAILS
                  </button>
                </ChoiceButtons>
              )}

              {/* FLIP BUTTON */}
              {phase === 'round_active' && (
                <>
                  <FlipButton
                    className={isCharging ? 'charging' : ''}
                    onMouseDown={handleFlipMouseDown}
                    onMouseUp={handleFlipMouseUp}
                    onMouseLeave={handleFlipMouseLeave}
                    onTouchStart={handleFlipMouseDown}
                    onTouchEnd={handleFlipMouseUp}
                    disabled={!player.choice || player.hasFlipped}
                  >
                    {player.hasFlipped ? '‚úÖ FLIPPED' : isCharging ? '‚ö° CHARGING...' : 'ü™ô HOLD TO FLIP'}
                  </FlipButton>
                  
                  {/* POWER BAR */}
                  {!player.hasFlipped && (
                    <PowerBarContainer>
                      <PowerLabel>Flip Power</PowerLabel>
                      <PowerBarTrack>
                        <PowerBarFill style={{ width: `${(power / 10) * 100}%` }} />
                        <PowerValue>{Math.floor(power)}/10</PowerValue>
                      </PowerBarTrack>
                    </PowerBarContainer>
                  )}
                </>
              )}

              {/* ABILITIES */}
              {phase === 'round_active' && (
                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                  <AbilityButton
                    available={player.hasShield}
                    onClick={handleDeployShield}
                    disabled={!player.hasShield}
                  >
                    üõ°Ô∏è {player.hasShield ? 'DEPLOY SHIELD' : 'SHIELD USED'}
                  </AbilityButton>
                  
                  <AbilityButton
                    available={player.hasLightningRound}
                    onClick={handleActivateLightning}
                    disabled={!player.hasLightningRound}
                  >
                    ‚ö° {player.hasLightningRound ? 'LIGHTNING ROUND' : 'LOCKED'}
                  </AbilityButton>
                </div>
              )}

              {/* STATUS INFO */}
              {player.choice && (
                <InfoBox color="#FFD700">
                  Your Choice: {player.choice.toUpperCase()}
                </InfoBox>
              )}

              {player.hasFlipped && (
                <InfoBox color="#00ff88">
                  ‚úÖ Coin Flipped - Waiting for others...
                </InfoBox>
              )}
            </>
          ) : isEliminated ? (
            <InfoBox color="#ff6b6b">
              üíÄ You were eliminated in Round {player.eliminatedInRound}
            </InfoBox>
          ) : (
            <InfoBox color="#aaa">
              üëÅÔ∏è Spectating
            </InfoBox>
          )}
        </ControlPanel>
      </GameLayout>
      
      {/* Floating Chat Widget */}
      <FloatingChatWidget />
    </Container>
  )
}

export default GameScreen
Step 5.2: Update BattleRoyaleUnified3DScene.jsx
Add a singleCoinMode prop to render just one coin for the card system:
jsx// ADD THIS PROP at the top of the component function
const BattleRoyaleUnified3DScene = ({
  players = [],
  gamePhase = 'filling',
  serverState = null,
  playerCoinImages = {},
  currentUserAddress = null,
  singleCoinMode = false  // NEW PROP
}) => {
  // ... existing code ...

  // MODIFY the coinPositions to support single coin mode
  const coinPositions = singleCoinMode ? [
    { x: 0, y: 0, z: 0, scale: 1 }  // Center for single coin
  ] : [
    { x: -8, y: 1, z: 0, scale: 1 },
    { x: 0, y: 1, z: 0, scale: 1 },
    { x: 8, y: 1, z: 0, scale: 1 },
    { x: -8, y: -5, z: 0, scale: 1 },
    { x: 0, y: -5, z: 0, scale: 1 },
    { x: 8, y: -5, z: 0, scale: 1 }
  ]

  // MODIFY the scene creation to only create needed coins
  const numCoins = singleCoinMode ? 1 : 6

  // In the initialization useEffect, change:
  for (let i = 0; i < numCoins; i++) {  // Changed from hardcoded 6
    // ... rest of coin creation code
  }

  // ... rest of existing code unchanged ...
}

PHASE 6: TESTING CHECKLIST
Step 6.1: Database Testing
bash# SSH into server
ssh root@159.69.242.154

# Run migration
cd /opt/flipnosis/app
sqlite3 server/flipz.db < server/migrations/add_battle_royale_features.sql

# Verify new columns exist
sqlite3 server/flipz.db "PRAGMA table_info(battle_royale_participants);"

# Should see: lives, power, has_shield, consecutive_wins, has_lightning_round, total_xp_earned, last_xp_drop
Step 6.2: Server Logic Testing
Test 1: Power-Based Flips
javascript// In browser console:
// Player with power 10 should win ~60% of the time
// Player with power 1 should win ~40% of the time
Test 2: Lives System
javascript// Create game, join with 6 players
// Make wrong choices
// Verify lives decrease: 3 ‚Üí 2 ‚Üí 1 ‚Üí Eliminated
Test 3: Shield Deployment
javascript// Deploy shield before flip
// Make wrong choice
// Verify player survives and shield is consumed
Test 4: Lightning Round
javascript// Win 3 rounds in a row
// Verify Lightning Round button appears
// Activate it
// Verify countdown drops to 5 seconds for ALL players
Test 5: XP System
javascript// Flip coins
// Verify XP drops appear with correct colors
// Verify XP accumulates in totalXPEarned
Test 6: Power Drain
javascript// Start with power 10
// Make wrong choice
// Verify power drops to 8
// Make another wrong choice
// Verify power drops to 6 (minimum 1)
Step 6.3: UI Testing
Dynamic Grid:

 6 players: 3√ó2 grid
 4 players after elimination: 2√ó2 grid (coins bigger)
 2 players final: Side-by-side (coins huge)
 Smooth transitions between layouts

Player Cards:

 Lives display correctly (3 hearts ‚Üí 2 ‚Üí 1)
 Power bar updates
 Shield indicator shows READY/USED
 Lightning Round indicator shows READY/LOCKED
 XP total displays correctly

XP Drops:

 100 XP = Silver glow
 200 XP = Light blue glow
 300 XP = Blue glow
 500 XP = Purple glow
 700 XP = Gold glow
 900 XP = Neon purple glow
 1000 XP = Rainbow gold glow
 Animations play smoothly

Abilities:

 Shield button pulses when available
 Lightning Round button pulses when available
 Buttons disabled when used/locked
 Confirmation dialogs appear

Eliminated Players:

 Card becomes grayscale
 "üíÄ ELIMINATED" overlay appears
 No more XP drops for eliminated players

Step 6.4: Edge Cases
Test Edge Case 1: All Players Lose

All players make wrong choices
All lose lives but none hit 0
Game continues to next round

Test Edge Case 2: All Players Survive

All players make correct choices
No one loses lives
Game continues to next round

Test Edge Case 3: Final 2 Both Lose

Final 2 players both make wrong choices
Both lose lives
If both hit 0 lives simultaneously:

Round replays
No one eliminated yet



Test Edge Case 4: Shield on Last Life

Player has 1 life left
Player deploys shield
Player makes wrong choice
Shield protects, player survives with 1 life

Test Edge Case 5: Power at Minimum

Player has power = 1
Player makes wrong choice
Power stays at 1 (can't go below)

Step 6.5: Performance Testing
Monitor:

 Frame rate stays above 30 FPS with 6 coins
 No memory leaks during long games
 Grid transitions are smooth
 XP animations don't cause lag
 Socket messages arrive promptly

Optimization Checks:

 Three.js scenes dispose properly
 No React re-render loops
 WebSocket events properly throttled


PHASE 7: DEPLOYMENT
Step 7.1: Deployment Order
bash# 1. Deploy database migration
ssh root@159.69.242.154
cd /opt/flipnosis/app
sqlite3 server/flipz.db < server/migrations/add_battle_royale_features.sql

# 2. Deploy server code
./deployment/deploy-hetzner-git-fixed.ps1 "Battle Royale Competitive Features"

# 3. Restart server
pm2 restart server

# 4. Verify logs
pm2 logs server --lines 100
Step 7.2: Rollback Plan
If issues occur:
bash# 1. Revert database changes
sqlite3 server/flipz.db << EOF
ALTER TABLE battle_royale_participants DROP COLUMN lives;
ALTER TABLE battle_royale_participants DROP COLUMN power;
ALTER TABLE battle_royale_participants DROP COLUMN has_shield;
ALTER TABLE battle_royale_participants DROP COLUMN consecutive_wins;
ALTER TABLE battle_royale_participants DROP COLUMN has_lightning_round;
ALTER TABLE battle_royale_participants DROP COLUMN total_xp_earned;
ALTER TABLE battle_royale_participants DROP COLUMN last_xp_drop;
EOF

# 2. Revert git commit
git revert HEAD
git push

# 3. Redeploy previous version
./deployment/deploy-hetzner-git-fixed.ps1 "Rollback to previous version"

PHASE 8: FINAL TOUCHES
Step 8.1: Sound Effects (Optional)
Add sound effects for immersion:
javascript// Create sounds.js
export const SOUNDS = {
  coinFlip: new Audio('/sounds/coin-flip.mp3'),
  xpDrop: new Audio('/sounds/xp-drop.mp3'),
  eliminated: new Audio('/sounds/eliminated.mp3'),
  lightningActivated: new Audio('/sounds/lightning.mp3'),
  shieldDeployed: new Audio('/sounds/shield.mp3'),
  victory: new Audio('/sounds/victory.mp3')
}

// Play sounds on events
SOUNDS.coinFlip.play()
Step 8.2: Mobile Responsiveness
Already handled in the styled-components with media queries!
Step 8.3: Accessibility

 Keyboard navigation works
 Screen readers can read game state
 Color blind friendly (use patterns + colors)
 Touch events work on mobile


üéâ SUMMARY
What You're Getting:
Server:

‚úÖ Power-based flip odds (40-60%)
‚úÖ Lives system (3 lives, lose 1 per wrong flip)
‚úÖ Shield ability (1-time protection)
‚úÖ Lightning Round (earned after 3 wins, forces 5-second countdown)
‚úÖ XP rewards (100-1000, weighted random)
‚úÖ Power drain on losses (max 10, min 1)
‚úÖ Consecutive wins tracking

Client:

‚úÖ Dynamic grid that scales (6‚Üí4‚Üí2 players)
‚úÖ Individual player cards with stats
‚úÖ XP drop animations with rarity colors
‚úÖ Lives hearts display (critical animation at 1 life)
‚úÖ Power bar visualization
‚úÖ Ability buttons (Shield + Lightning)
‚úÖ Cyberpunk aesthetic with neon glows
‚úÖ Smooth transitions and animations

Database:

‚úÖ New fields for competitive mechanics
‚úÖ Persistent player stats tracking
‚úÖ XP accumulation per game


üìù NOTES FOR CURSOR
Implementation Priority:

Database first - Run migration
Server logic - Update BattleRoyaleGameManager
Socket handlers - Add new events
Components - Build UI piece by piece
Integration - Wire everything together
Testing - Verify each feature
Polish - Animations and sounds

Key Files to Update:

server/migrations/add_battle_royale_features.sql (NEW)
server/services/BattleRoyaleDBService.js (UPDATE)
server/BattleRoyaleGameManager.js (REPLACE)
server/socket/BattleRoyaleSocketHandlers.js (ADD METHODS)
server/socket/server-socketio.js (ADD EVENTS)
client/src/constants/xpRarities.js (NEW)
client/src/components/BattleRoyale/XPRewardDrop.jsx (NEW)
client/src/components/BattleRoyale/PlayerStatsBar.jsx (NEW)
client/src/components/BattleRoyale/PlayerCard.jsx (NEW)
client/src/components/BattleRoyale/DynamicGrid.jsx (NEW)
client/src/components/BattleRoyale/GameScreen.jsx (REPLACE)
client/src/components/BattleRoyale/BattleRoyaleUnified3DScene.jsx (UPDATE)

Don't Touch:

Three.js coin rendering (keep it beautiful!)
FloatingChatWidget (works great)
LobbyScreen (no changes needed)


This is a complete, production-ready implementation that adds genuine competitive depth to your Battle Royale game while maintaining the fun chaos of coin flips! üéÆü™ô‚ú®RetryClaude does not have the ability to run the code it generates yet.