üöÄ COMPLETE 3D PHYSICS BATTLE ROYALE TRANSFORMATION
üì¶ STEP 1: Install Dependencies
bashnpm install cannon-es three@latest

üèóÔ∏è ARCHITECTURE OVERVIEW
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         CLIENT                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ LobbyScreen.jsx (unchanged) ‚Üí PhysicsGameScreen.jsx         ‚îÇ
‚îÇ    ‚îú‚îÄ PhysicsScene.jsx (3D environment)                     ‚îÇ
‚îÇ    ‚îú‚îÄ CannonController.jsx (aim/power/fire)                 ‚îÇ
‚îÇ    ‚îú‚îÄ PlayerLifeBoxes.jsx (6 boxes at bottom)               ‚îÇ
‚îÇ    ‚îî‚îÄ CoinLandingCamera.jsx (close-up views)                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ÜïÔ∏è WebSocket
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         SERVER                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ PhysicsGameManager.js                                        ‚îÇ
‚îÇ    ‚îú‚îÄ Cannon.js physics world (60fps)                       ‚îÇ
‚îÇ    ‚îú‚îÄ Turn management (30s per player)                      ‚îÇ
‚îÇ    ‚îú‚îÄ Collision detection                                   ‚îÇ
‚îÇ    ‚îú‚îÄ Result calculation (which face up)                    ‚îÇ
‚îÇ    ‚îî‚îÄ Lives management                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üìÅ NEW FILE: server/PhysicsGameManager.jsPhysicsGameManager.js
// PhysicsGameManager.js - Server-side 3D Physics Battle Royale Manager
const CANNON = require('cannon-es')

class PhysicsGameManager {
  constructor() {
    this.games = new Map() // gameId -> PhysicsGameState
    this.worlds = new Map() // gameId -> CANNON.World
  }

  PHASES = {
    LOBBY: 'lobby',
    GAME_STARTING: 'game_starting',
    PLAYER_TURN: 'player_turn',
    COIN_FLYING: 'coin_flying',
    COIN_LANDING: 'coin_landing',
    TURN_RESULT: 'turn_result',
    GAME_OVER: 'game_over'
  }

  // ===== CREATE GAME =====
  createPhysicsGame(gameId, gameData) {
    console.log(`üéÆ Creating Physics Battle Royale: ${gameId}`)
    
    // Initialize Cannon.js physics world
    const world = new CANNON.World()
    world.gravity.set(0, -20, 0) // Gravity pointing down
    world.broadphase = new CANNON.NaiveBroadphase()
    world.solver.iterations = 10
    
    // Create ground plane (invisible, just for physics)
    const groundBody = new CANNON.Body({
      mass: 0, // static
      shape: new CANNON.Plane(),
      position: new CANNON.Vec3(0, -10, 0)
    })
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
    world.addBody(groundBody)
    
    // Create obstacles (planets, asteroids, etc.)
    this.createObstacles(world)
    
    const game = {
      gameId,
      phase: this.PHASES.LOBBY,
      maxPlayers: 2, // Start with 2, scale to 6
      currentPlayers: 0,
      entryFee: gameData.entry_fee || 5.00,
      serviceFee: gameData.service_fee || 0.50,
      creator: gameData.creator,
      players: {}, // address -> PlayerState
      playerOrder: [], // Turn order
      currentTurnIndex: 0,
      currentTurnPlayer: null,
      turnTimer: 30,
      activeCoin: null, // Currently flying coin
      obstacles: [], // Obstacle positions for client
      nftContract: gameData.nft_contract,
      nftTokenId: gameData.nft_token_id,
      nftName: gameData.nft_name,
      nftImage: gameData.nft_image,
      nftCollection: gameData.nft_collection,
      winner: null,
      createdAt: new Date().toISOString()
    }

    this.games.set(gameId, game)
    this.worlds.set(gameId, world)
    
    // Add creator as first player
    if (gameData.creator) {
      this.addPlayer(gameId, gameData.creator)
    }
    
    return game
  }

  // ===== CREATE OBSTACLES =====
  createObstacles(world) {
    const obstacles = []
    
    // Create 15 random obstacles in the space
    for (let i = 0; i < 15; i++) {
      const radius = 2 + Math.random() * 3 // Random size between 2-5 units
      const x = (Math.random() - 0.5) * 40 // Spread across X
      const y = 10 + Math.random() * 60 // Height from 10 to 70
      const z = (Math.random() - 0.5) * 40 // Spread across Z
      
      const obstacleBody = new CANNON.Body({
        mass: 0, // Static obstacles
        shape: new CANNON.Sphere(radius),
        position: new CANNON.Vec3(x, y, z),
        material: new CANNON.Material({ friction: 0.3, restitution: 0.7 })
      })
      
      world.addBody(obstacleBody)
      
      obstacles.push({
        id: `obstacle_${i}`,
        type: 'sphere',
        radius,
        position: { x, y, z }
      })
    }
    
    return obstacles
  }

  // ===== ADD PLAYER =====
  addPlayer(gameId, playerAddress) {
    const game = this.games.get(gameId)
    if (!game || game.currentPlayers >= game.maxPlayers) return false
    
    const normalizedAddress = playerAddress.toLowerCase()
    if (game.players[normalizedAddress]) return false

    game.players[normalizedAddress] = {
      address: playerAddress,
      lives: 3,
      isActive: true,
      choice: null, // heads or tails
      coin: { 
        id: 'plain', 
        type: 'default', 
        name: 'Classic',
        headsImage: '/coins/plainh.png',
        tailsImage: '/coins/plaint.png'
      },
      cannonPosition: { x: (game.currentPlayers - 0.5) * 10, y: 0, z: 0 }, // Spread out
      joinedAt: new Date().toISOString()
    }

    game.playerOrder.push(normalizedAddress)
    game.currentPlayers++

    console.log(`‚úÖ Player joined: ${playerAddress} (${game.currentPlayers}/${game.maxPlayers})`)
    return true
  }

  // ===== START GAME =====
  startGame(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game || game.currentPlayers < 2) return false

    console.log(`üöÄ Starting physics game: ${gameId}`)
    game.phase = this.PHASES.GAME_STARTING

    broadcastFn(`game_${gameId}`, 'physics_game_starting', {
      gameId,
      countdown: 3
    })

    setTimeout(() => {
      this.startNextTurn(gameId, broadcastFn)
    }, 3000)

    return true
  }

  // ===== START TURN =====
  startNextTurn(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game) return false

    // Check for winner
    const activePlayers = Object.values(game.players).filter(p => p.isActive)
    if (activePlayers.length <= 1) {
      return this.endGame(gameId, broadcastFn)
    }

    // Find next active player
    let attempts = 0
    while (attempts < game.playerOrder.length) {
      const playerAddr = game.playerOrder[game.currentTurnIndex]
      const player = game.players[playerAddr]
      
      if (player && player.isActive) {
        game.currentTurnPlayer = playerAddr
        game.phase = this.PHASES.PLAYER_TURN
        game.turnTimer = 30
        player.choice = null // Reset choice
        
        console.log(`üéØ Turn started for: ${playerAddr}`)
        
        broadcastFn(`game_${gameId}`, 'physics_turn_start', {
          gameId,
          playerAddress: playerAddr,
          timeLimit: 30
        })

        this.broadcastState(gameId, broadcastFn)
        
        // Start turn timer
        const timerInterval = setInterval(() => {
          game.turnTimer--
          
          if (game.turnTimer <= 0) {
            clearInterval(timerInterval)
            // Auto-fire with random values if player didn't act
            this.fireCoin(gameId, playerAddr, 0, 5, broadcastFn)
          } else {
            this.broadcastState(gameId, broadcastFn)
          }
        }, 1000)
        
        return true
      }
      
      game.currentTurnIndex = (game.currentTurnIndex + 1) % game.playerOrder.length
      attempts++
    }

    // No active players found (shouldn't happen)
    return this.endGame(gameId, broadcastFn)
  }

  // ===== SET CHOICE =====
  setChoice(gameId, playerAddress, choice) {
    const game = this.games.get(gameId)
    if (!game || game.phase !== this.PHASES.PLAYER_TURN) return false
    
    const normalizedAddress = playerAddress.toLowerCase()
    if (normalizedAddress !== game.currentTurnPlayer) return false
    
    const player = game.players[normalizedAddress]
    if (!player) return false
    
    player.choice = choice
    console.log(`‚úÖ ${playerAddress} chose ${choice}`)
    return true
  }

  // ===== FIRE COIN =====
  fireCoin(gameId, playerAddress, angle, power, broadcastFn) {
    const game = this.games.get(gameId)
    const world = this.worlds.get(gameId)
    if (!game || !world || game.phase !== this.PHASES.PLAYER_TURN) return false
    
    const normalizedAddress = playerAddress.toLowerCase()
    if (normalizedAddress !== game.currentTurnPlayer) return false
    
    const player = game.players[normalizedAddress]
    if (!player || !player.choice) return false

    console.log(`üöÄ ${playerAddress} firing coin: angle=${angle}, power=${power}`)
    
    game.phase = this.PHASES.COIN_FLYING
    
    // Create coin physics body
    const coinRadius = 1.5
    const coinThickness = 0.2
    const coinShape = new CANNON.Cylinder(coinRadius, coinRadius, coinThickness, 32)
    
    const coinBody = new CANNON.Body({
      mass: 1,
      shape: coinShape,
      position: new CANNON.Vec3(
        player.cannonPosition.x,
        player.cannonPosition.y + 2,
        player.cannonPosition.z
      ),
      material: new CANNON.Material({ friction: 0.3, restitution: 0.8 })
    })
    
    // Calculate launch velocity
    const powerScale = power * 2 // power 1-10 ‚Üí velocity 2-20
    const angleRad = (angle * Math.PI) / 180
    
    coinBody.velocity.set(
      Math.sin(angleRad) * powerScale * 0.3, // X component (horizontal)
      powerScale, // Y component (upward)
      0 // Z component
    )
    
    // Add random spin
    coinBody.angularVelocity.set(
      Math.random() * 10 - 5,
      Math.random() * 10 - 5,
      Math.random() * 10 - 5
    )
    
    world.addBody(coinBody)
    
    game.activeCoin = {
      body: coinBody,
      playerAddress: normalizedAddress,
      startTime: Date.now(),
      lastBroadcast: 0
    }
    
    broadcastFn(`game_${gameId}`, 'physics_coin_fired', {
      gameId,
      playerAddress,
      angle,
      power
    })
    
    // Start physics simulation loop
    this.startPhysicsLoop(gameId, broadcastFn)
    
    return true
  }

  // ===== PHYSICS SIMULATION LOOP =====
  startPhysicsLoop(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    const world = this.worlds.get(gameId)
    if (!game || !world) return

    const fixedTimeStep = 1 / 60 // 60 FPS
    let lastTime = Date.now()
    
    const simulationLoop = () => {
      if (game.phase !== this.PHASES.COIN_FLYING) {
        return // Stop loop
      }
      
      const currentTime = Date.now()
      const deltaTime = (currentTime - lastTime) / 1000
      lastTime = currentTime
      
      // Step physics world
      world.step(fixedTimeStep, deltaTime, 3)
      
      if (!game.activeCoin) return
      
      const coinBody = game.activeCoin.body
      
      // Broadcast position every 50ms (20 updates/sec)
      if (currentTime - game.activeCoin.lastBroadcast > 50) {
        broadcastFn(`game_${gameId}`, 'physics_coin_position', {
          gameId,
          position: {
            x: coinBody.position.x,
            y: coinBody.position.y,
            z: coinBody.position.z
          },
          rotation: {
            x: coinBody.quaternion.x,
            y: coinBody.quaternion.y,
            z: coinBody.quaternion.z,
            w: coinBody.quaternion.w
          },
          velocity: {
            x: coinBody.velocity.x,
            y: coinBody.velocity.y,
            z: coinBody.velocity.z
          }
        })
        
        game.activeCoin.lastBroadcast = currentTime
      }
      
      // Check if coin has landed (velocity near zero and below certain height)
      const velocity = Math.sqrt(
        coinBody.velocity.x ** 2 +
        coinBody.velocity.y ** 2 +
        coinBody.velocity.z ** 2
      )
      
      if (velocity < 0.5 && coinBody.position.y < 5) {
        // Coin has landed!
        this.handleCoinLanded(gameId, broadcastFn)
        return
      }
      
      // Check timeout (max 10 seconds)
      if (currentTime - game.activeCoin.startTime > 10000) {
        this.handleCoinLanded(gameId, broadcastFn)
        return
      }
      
      // Continue loop
      setTimeout(simulationLoop, 16) // ~60fps
    }
    
    simulationLoop()
  }

  // ===== COIN LANDED =====
  handleCoinLanded(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    const world = this.worlds.get(gameId)
    if (!game || !game.activeCoin) return

    console.log(`üéØ Coin landed in game ${gameId}`)
    
    game.phase = this.PHASES.COIN_LANDING
    
    const coinBody = game.activeCoin.body
    const playerAddress = game.activeCoin.playerAddress
    const player = game.players[playerAddress]
    
    // Determine which face is up based on rotation
    const result = this.determineCoinFace(coinBody.quaternion)
    
    // Remove coin from physics world
    world.removeBody(coinBody)
    
    console.log(`üé≤ Result: ${result}, Player chose: ${player.choice}`)
    
    // Check if player won or lost
    const won = result === player.choice
    
    if (!won) {
      player.lives--
      if (player.lives <= 0) {
        player.isActive = false
      }
    }
    
    // Broadcast result
    broadcastFn(`game_${gameId}`, 'physics_coin_landed', {
      gameId,
      playerAddress,
      result,
      won,
      livesRemaining: player.lives,
      eliminated: !player.isActive
    })
    
    this.broadcastState(gameId, broadcastFn)
    
    // Clear active coin
    game.activeCoin = null
    
    // Move to next turn after 3 seconds
    setTimeout(() => {
      game.currentTurnIndex = (game.currentTurnIndex + 1) % game.playerOrder.length
      this.startNextTurn(gameId, broadcastFn)
    }, 3000)
  }

  // ===== DETERMINE COIN FACE =====
  determineCoinFace(quaternion) {
    // Convert quaternion to up vector
    const upVector = new CANNON.Vec3(0, 1, 0)
    quaternion.vmult(upVector, upVector)
    
    // If Y component is positive, heads is up
    // If Y component is negative, tails is up
    return upVector.y > 0 ? 'heads' : 'tails'
  }

  // ===== END GAME =====
  endGame(gameId, broadcastFn) {
    const game = this.games.get(gameId)
    if (!game) return false

    game.phase = this.PHASES.GAME_OVER
    
    // Find winner
    const activePlayers = Object.values(game.players).filter(p => p.isActive)
    game.winner = activePlayers.length > 0 ? activePlayers[0].address : null

    console.log(`üèÜ Game over: ${game.winner || 'No winner'}`)

    broadcastFn(`game_${gameId}`, 'physics_game_over', {
      gameId,
      winner: game.winner
    })

    this.broadcastState(gameId, broadcastFn)
    return true
  }

  // ===== UPDATE COIN =====
  updatePlayerCoin(gameId, playerAddress, coinData) {
    const game = this.games.get(gameId)
    if (!game) return false
    
    const normalizedAddress = playerAddress.toLowerCase()
    const player = game.players[normalizedAddress]
    if (!player) return false
    
    player.coin = coinData
    console.log(`‚úÖ Coin updated for ${playerAddress}`)
    return true
  }

  // ===== STATE MANAGEMENT =====
  getGame(gameId) {
    return this.games.get(gameId)
  }

  getFullGameState(gameId) {
    const game = this.games.get(gameId)
    if (!game) return null

    return {
      gameId: game.gameId,
      phase: game.phase,
      maxPlayers: game.maxPlayers,
      currentPlayers: game.currentPlayers,
      entryFee: game.entryFee,
      serviceFee: game.serviceFee,
      creator: game.creator,
      players: game.players,
      playerOrder: game.playerOrder,
      currentTurnPlayer: game.currentTurnPlayer,
      turnTimer: game.turnTimer,
      obstacles: game.obstacles,
      nftName: game.nftName,
      nftImage: game.nftImage,
      nftCollection: game.nftCollection,
      nftContract: game.nftContract,
      nftTokenId: game.nftTokenId,
      winner: game.winner
    }
  }

  broadcastState(gameId, broadcastFn) {
    const state = this.getFullGameState(gameId)
    if (state) {
      broadcastFn(`game_${gameId}`, 'physics_state_update', state)
    }
  }

  // ===== CLEANUP =====
  removeGame(gameId) {
    const world = this.worlds.get(gameId)
    if (world) {
      // Clean up physics world
      world.bodies.forEach(body => world.removeBody(body))
      this.worlds.delete(gameId)
    }
    this.games.delete(gameId)
    console.log(`üóëÔ∏è Physics game removed: ${gameId}`)
  }
}

module.exports = PhysicsGameManager

üìÅ NEW FILE: client/PhysicsGameScreen.jsxPhysicsGameScreen.jsx
import React, { useState, useEffect, useCallback } from 'react'
import styled from '@emotion/styled'
import PhysicsScene from './PhysicsScene'
import CannonController from './CannonController'
import PlayerLifeBoxes from './PlayerLifeBoxes'
import { useBattleRoyaleGame } from '../../contexts/BattleRoyaleGameContext'
import socketService from '../../services/SocketService'

const Container = styled.div`
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100vw;
  background: #000;
  overflow: hidden;
`

const SceneContainer = styled.div`
  flex: 1;
  position: relative;
  width: 100%;
`

const PlayerBoxesContainer = styled.div`
  height: 200px;
  width: 100%;
  background: rgba(0, 0, 20, 0.9);
  border-top: 2px solid #00ffff;
`

const TurnIndicator = styled.div`
  position: absolute;
  top: 2rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.9);
  border: 3px solid ${props => props.isYourTurn ? '#00ff88' : '#ff1493'};
  padding: 1rem 3rem;
  border-radius: 2rem;
  color: white;
  font-size: 1.5rem;
  font-weight: bold;
  text-align: center;
  z-index: 100;
  box-shadow: 0 0 30px ${props => props.isYourTurn ? 'rgba(0, 255, 136, 0.5)' : 'rgba(255, 20, 147, 0.5)'};
`

const TimerDisplay = styled.div`
  position: absolute;
  top: 2rem;
  right: 2rem;
  background: rgba(0, 0, 0, 0.9);
  border: 2px solid ${props => props.urgent ? '#ff6b6b' : '#00bfff'};
  padding: 1rem 2rem;
  border-radius: 1rem;
  color: white;
  font-size: 2rem;
  font-weight: bold;
  z-index: 100;
  animation: ${props => props.urgent ? 'pulse 1s ease-in-out infinite' : 'none'};
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.8; }
  }
`

const GameOverOverlay = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  
  .trophy {
    font-size: 6rem;
    margin-bottom: 2rem;
  }
  
  .message {
    font-size: 3rem;
    font-weight: bold;
    color: ${props => props.isWinner ? '#FFD700' : '#ff6b6b'};
    margin-bottom: 1rem;
    text-shadow: 0 0 20px currentColor;
  }
  
  .winner {
    font-size: 1.5rem;
    color: white;
    font-family: monospace;
  }
`

const PhysicsGameScreen = () => {
  const { gameState, address, makeChoice } = useBattleRoyaleGame()
  const [localChoice, setLocalChoice] = useState(null)
  const [coinPositions, setCoinPositions] = useState([])
  const [cameraTarget, setCameraTarget] = useState(null)
  
  if (!gameState) return null
  
  const phase = gameState.phase
  const isMyTurn = gameState.currentTurnPlayer?.toLowerCase() === address?.toLowerCase()
  const currentPlayer = gameState.players?.[address?.toLowerCase()]
  const turnTimer = gameState.turnTimer || 0
  const urgent = turnTimer <= 10
  
  // Listen for coin position updates
  useEffect(() => {
    const handleCoinPosition = (data) => {
      setCoinPositions(prev => [...prev, {
        position: data.position,
        rotation: data.rotation,
        timestamp: Date.now()
      }])
      
      // Update camera target to follow coin
      setCameraTarget(data.position)
    }
    
    const handleCoinLanded = (data) => {
      console.log('üéØ Coin landed:', data)
      setCameraTarget(null)
      
      // Clear coin trail
      setTimeout(() => {
        setCoinPositions([])
      }, 3000)
    }
    
    socketService.on('physics_coin_position', handleCoinPosition)
    socketService.on('physics_coin_landed', handleCoinLanded)
    
    return () => {
      socketService.off('physics_coin_position', handleCoinPosition)
      socketService.off('physics_coin_landed', handleCoinLanded)
    }
  }, [])
  
  const handleChoiceSelect = useCallback((choice) => {
    if (!isMyTurn) return
    setLocalChoice(choice)
    makeChoice(choice)
  }, [isMyTurn, makeChoice])
  
  const handleFireCoin = useCallback((angle, power) => {
    if (!isMyTurn || !currentPlayer?.choice) return
    
    socketService.emit('physics_fire_coin', {
      gameId: gameState.gameId,
      address,
      angle,
      power
    })
  }, [isMyTurn, currentPlayer, gameState.gameId, address])
  
  // PHASE: GAME OVER
  if (phase === 'game_over') {
    const isWinner = gameState.winner?.toLowerCase() === address?.toLowerCase()
    return (
      <Container>
        <GameOverOverlay isWinner={isWinner}>
          <div className="trophy">{isWinner ? 'üèÜ' : 'üíÄ'}</div>
          <div className="message">
            {isWinner ? 'VICTORY!' : 'GAME OVER'}
          </div>
          <div className="winner">
            Winner: {gameState.winner ? `${gameState.winner.slice(0, 10)}...${gameState.winner.slice(-8)}` : 'None'}
          </div>
        </GameOverOverlay>
      </Container>
    )
  }
  
  return (
    <Container>
      {/* TURN INDICATOR */}
      {phase === 'player_turn' && (
        <TurnIndicator isYourTurn={isMyTurn}>
          {isMyTurn ? 'üéØ YOUR TURN!' : `‚è≥ ${gameState.currentTurnPlayer?.slice(0, 8)}'s Turn`}
        </TurnIndicator>
      )}
      
      {/* TIMER */}
      {phase === 'player_turn' && (
        <TimerDisplay urgent={urgent}>
          {turnTimer}s
        </TimerDisplay>
      )}
      
      {/* 3D SCENE */}
      <SceneContainer>
        <PhysicsScene
          obstacles={gameState.obstacles || []}
          players={gameState.players || {}}
          coinPositions={coinPositions}
          cameraTarget={cameraTarget}
          currentPlayerAddress={address}
          isMyTurn={isMyTurn}
        />
        
        {/* CANNON CONTROLLER - Only show on your turn */}
        {isMyTurn && phase === 'player_turn' && (
          <CannonController
            onChoiceSelect={handleChoiceSelect}
            onFire={handleFireCoin}
            selectedChoice={localChoice || currentPlayer?.choice}
            disabled={!currentPlayer?.choice}
          />
        )}
      </SceneContainer>
      
      {/* PLAYER LIFE BOXES AT BOTTOM */}
      <PlayerBoxesContainer>
        <PlayerLifeBoxes
          players={gameState.players || {}}
          playerOrder={gameState.playerOrder || []}
          currentPlayerAddress={address}
          currentTurnPlayer={gameState.currentTurnPlayer}
        />
      </PlayerBoxesContainer>
    </Container>
  )
}

export default PhysicsGameScreen

üìÅ NEW FILE: client/PhysicsScene.jsxPhysicsScene.jsx
import React, { useEffect, useRef } from 'react'
import * as THREE from 'three'

const PhysicsScene = ({ 
  obstacles = [], 
  players = {}, 
  coinPositions = [],
  cameraTarget = null,
  currentPlayerAddress = null,
  isMyTurn = false
}) => {
  const mountRef = useRef(null)
  const sceneRef = useRef(null)
  const cameraRef = useRef(null)
  const rendererRef = useRef(null)
  const obstaclesRef = useRef([])
  const coinRef = useRef(null)
  const animationIdRef = useRef(null)
  const cameraBasePositionRef = useRef({ x: 0, y: 5, z: 30 })
  
  // Initialize scene
  useEffect(() => {
    if (!mountRef.current) return
    
    console.log('üé¨ Initializing Physics Scene')
    
    // Scene setup
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(0x000011) // Dark blue space
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      60,
      mountRef.current.clientWidth / mountRef.current.clientHeight,
      0.1,
      1000
    )
    camera.position.set(0, 5, 30)
    camera.lookAt(0, 20, 0)
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false })
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    
    mountRef.current.appendChild(renderer.domElement)
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404080, 1.5)
    scene.add(ambientLight)
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5)
    directionalLight.position.set(10, 50, 10)
    directionalLight.castShadow = true
    directionalLight.shadow.camera.left = -50
    directionalLight.shadow.camera.right = 50
    directionalLight.shadow.camera.top = 50
    directionalLight.shadow.camera.bottom = -50
    scene.add(directionalLight)
    
    // Point lights for atmosphere
    const pointLight1 = new THREE.PointLight(0x00ffff, 2, 100)
    pointLight1.position.set(-20, 30, 10)
    scene.add(pointLight1)
    
    const pointLight2 = new THREE.PointLight(0xff00ff, 2, 100)
    pointLight2.position.set(20, 30, -10)
    scene.add(pointLight2)
    
    // Create starfield
    const starGeometry = new THREE.BufferGeometry()
    const starMaterial = new THREE.PointsMaterial({ 
      color: 0xffffff, 
      size: 0.5, 
      sizeAttenuation: true 
    })
    
    const starVertices = []
    for (let i = 0; i < 1000; i++) {
      const x = (Math.random() - 0.5) * 200
      const y = (Math.random() - 0.5) * 200
      const z = (Math.random() - 0.5) * 200
      starVertices.push(x, y, z)
    }
    
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3))
    const stars = new THREE.Points(starGeometry, starMaterial)
    scene.add(stars)
    
    // Create obstacles (planets, asteroids)
    obstacles.forEach((obstacle, index) => {
      let geometry, material
      
      if (obstacle.type === 'sphere') {
        geometry = new THREE.SphereGeometry(obstacle.radius, 32, 32)
        
        // Varied planet colors
        const colors = [0xff6b6b, 0x6b9eff, 0x9eff6b, 0xff6bff, 0xffff6b, 0x6bffff]
        const color = colors[index % colors.length]
        
        material = new THREE.MeshStandardMaterial({ 
          color, 
          metalness: 0.3, 
          roughness: 0.7,
          emissive: color,
          emissiveIntensity: 0.2
        })
      }
      
      const mesh = new THREE.Mesh(geometry, material)
      mesh.position.set(obstacle.position.x, obstacle.position.y, obstacle.position.z)
      mesh.castShadow = true
      mesh.receiveShadow = true
      
      scene.add(mesh)
      obstaclesRef.current.push(mesh)
    })
    
    // Store references
    sceneRef.current = scene
    cameraRef.current = camera
    rendererRef.current = renderer
    
    // Animation loop
    const animate = () => {
      if (!sceneRef.current || !rendererRef.current || !cameraRef.current) return
      
      // Slowly rotate starfield
      if (stars) {
        stars.rotation.y += 0.0002
      }
      
      // Smoothly move camera to target
      if (cameraTarget && isMyTurn) {
        // Follow coin up
        const targetPos = new THREE.Vector3(
          cameraTarget.x,
          cameraTarget.y - 5,
          cameraTarget.z + 15
        )
        
        camera.position.lerp(targetPos, 0.05)
        camera.lookAt(cameraTarget.x, cameraTarget.y, cameraTarget.z)
      } else {
        // Return to base position
        const basePos = new THREE.Vector3(
          cameraBasePositionRef.current.x,
          cameraBasePositionRef.current.y,
          cameraBasePositionRef.current.z
        )
        
        camera.position.lerp(basePos, 0.02)
        camera.lookAt(0, 20, 0)
      }
      
      renderer.render(scene, camera)
      animationIdRef.current = requestAnimationFrame(animate)
    }
    
    animate()
    
    // Resize handler
    const handleResize = () => {
      if (!mountRef.current || !camera || !renderer) return
      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight
      camera.updateProjectionMatrix()
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight)
    }
    
    window.addEventListener('resize', handleResize)
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize)
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current)
      }
      
      obstaclesRef.current.forEach(obstacle => {
        if (obstacle.geometry) obstacle.geometry.dispose()
        if (obstacle.material) obstacle.material.dispose()
      })
      
      if (renderer) {
        renderer.dispose()
        if (mountRef.current) {
          mountRef.current.removeChild(renderer.domElement)
        }
      }
      
      sceneRef.current = null
      cameraRef.current = null
      rendererRef.current = null
    }
  }, [obstacles])
  
  // Update coin position from server
  useEffect(() => {
    if (!sceneRef.current || coinPositions.length === 0) return
    
    const latestPosition = coinPositions[coinPositions.length - 1]
    
    // Create or update coin mesh
    if (!coinRef.current) {
      const coinGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32)
      const coinMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffd700, 
        metalness: 0.8, 
        roughness: 0.2,
        emissive: 0xffd700,
        emissiveIntensity: 0.3
      })
      
      const coin = new THREE.Mesh(coinGeometry, coinMaterial)
      coin.castShadow = true
      sceneRef.current.add(coin)
      coinRef.current = coin
    }
    
    // Update position and rotation
    coinRef.current.position.set(
      latestPosition.position.x,
      latestPosition.position.y,
      latestPosition.position.z
    )
    
    coinRef.current.quaternion.set(
      latestPosition.rotation.x,
      latestPosition.rotation.y,
      latestPosition.rotation.z,
      latestPosition.rotation.w
    )
    
  }, [coinPositions])
  
  // Clean up coin when positions are cleared
  useEffect(() => {
    if (coinPositions.length === 0 && coinRef.current && sceneRef.current) {
      sceneRef.current.remove(coinRef.current)
      coinRef.current.geometry.dispose()
      coinRef.current.material.dispose()
      coinRef.current = null
    }
  }, [coinPositions.length])
  
  return (
    <div
      ref={mountRef}
      style={{
        width: '100%',
        height: '100%',
        position: 'absolute',
        top: 0,
        left: 0
      }}
    />
  )
}

export default PhysicsScene

üìÅ NEW FILE: client/CannonController.jsxCannonController.jsx
import React, { useState, useRef, useEffect } from 'react'
import styled from '@emotion/styled'

const ControlPanel = styled.div`
  position: absolute;
  bottom: 220px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 20, 0.95);
  border: 3px solid #00ffff;
  border-radius: 2rem;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  min-width: 400px;
  box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  z-index: 50;
`

const ChoiceButtons = styled.div`
  display: flex;
  gap: 1rem;
  justify-content: center;
  
  button {
    flex: 1;
    padding: 1rem 2rem;
    border: none;
    border-radius: 1rem;
    font-size: 1.2rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    
    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s;
    }
    
    &:hover:not(:disabled)::before {
      left: 100%;
    }
    
    &.heads {
      background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
      color: #000;
      border: 3px solid #FFD700;
    }
    
    &.tails {
      background: linear-gradient(135deg, #C0C0C0 0%, #A0A0A0 100%);
      color: #000;
      border: 3px solid #C0C0C0;
    }
    
    &.selected {
      border-width: 4px;
      box-shadow: 0 0 30px currentColor, inset 0 0 20px rgba(255, 255, 255, 0.3);
      animation: selectedPulse 1.5s ease-in-out infinite;
    }
    
    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  }
  
  @keyframes selectedPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
`

const AngleControl = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  
  label {
    color: #00ffff;
    font-weight: bold;
    text-align: center;
  }
  
  input {
    width: 100%;
    cursor: pointer;
  }
  
  .angle-display {
    text-align: center;
    color: white;
    font-size: 1.5rem;
    font-weight: bold;
  }
`

const PowerMeter = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  
  label {
    color: #00ffff;
    font-weight: bold;
    text-align: center;
  }
  
  .power-bar {
    width: 100%;
    height: 40px;
    background: rgba(0, 0, 0, 0.8);
    border-radius: 20px;
    overflow: hidden;
    border: 2px solid #00ffff;
    position: relative;
  }
  
  .power-fill {
    height: 100%;
    background: linear-gradient(90deg, #00ff88 0%, #00ffff 50%, #ffff00 100%);
    transition: width 0.1s linear;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
  }
  
  .power-value {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 1.2rem;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
  }
`

const FireButton = styled.button`
  background: linear-gradient(135deg, #ff1493 0%, #ff69b4 100%);
  color: white;
  border: 3px solid #ff1493;
  padding: 1.5rem 3rem;
  border-radius: 2rem;
  font-size: 1.5rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    transition: left 0.5s;
  }
  
  &:hover:not(:disabled)::before {
    left: 100%;
  }
  
  &:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 10px 30px rgba(255, 20, 147, 0.5);
  }
  
  &.charging {
    animation: chargeGlow 0.3s ease-in-out infinite;
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  
  @keyframes chargeGlow {
    0%, 100% { box-shadow: 0 0 20px rgba(255, 20, 147, 0.6); }
    50% { box-shadow: 0 0 40px rgba(255, 20, 147, 1); }
  }
`

const CannonController = ({ 
  onChoiceSelect, 
  onFire, 
  selectedChoice = null, 
  disabled = false 
}) => {
  const [angle, setAngle] = useState(0) // -45 to 45 degrees
  const [power, setPower] = useState(5) // 1 to 10
  const [isCharging, setIsCharging] = useState(false)
  const chargeIntervalRef = useRef(null)
  
  const handleChoiceClick = (choice) => {
    if (disabled) return
    onChoiceSelect(choice)
  }
  
  const handleAngleChange = (e) => {
    setAngle(parseInt(e.target.value))
  }
  
  // Auto-charge power on mouse down
  const handleFireMouseDown = () => {
    if (disabled || !selectedChoice) return
    
    setIsCharging(true)
    setPower(1)
    
    chargeIntervalRef.current = setInterval(() => {
      setPower(prev => {
        const newPower = prev + 0.5
        return newPower > 10 ? 10 : newPower
      })
    }, 100)
  }
  
  // Fire on mouse up
  const handleFireMouseUp = () => {
    if (disabled || !selectedChoice || !isCharging) return
    
    if (chargeIntervalRef.current) {
      clearInterval(chargeIntervalRef.current)
      chargeIntervalRef.current = null
    }
    
    setIsCharging(false)
    
    // Fire with current angle and power
    onFire(angle, Math.floor(power))
    
    // Reset
    setTimeout(() => setPower(5), 500)
  }
  
  // Cancel charge on mouse leave
  const handleFireMouseLeave = () => {
    if (chargeIntervalRef.current) {
      clearInterval(chargeIntervalRef.current)
      chargeIntervalRef.current = null
    }
    setIsCharging(false)
    setPower(5)
  }
  
  // Cleanup
  useEffect(() => {
    return () => {
      if (chargeIntervalRef.current) {
        clearInterval(chargeIntervalRef.current)
      }
    }
  }, [])
  
  return (
    <ControlPanel>
      {/* Choice Selection */}
      <ChoiceButtons>
        <button
          className={`heads ${selectedChoice === 'heads' ? 'selected' : ''}`}
          onClick={() => handleChoiceClick('heads')}
          disabled={disabled}
        >
          HEADS
        </button>
        <button
          className={`tails ${selectedChoice === 'tails' ? 'selected' : ''}`}
          onClick={() => handleChoiceClick('tails')}
          disabled={disabled}
        >
          TAILS
        </button>
      </ChoiceButtons>
      
      {/* Angle Control */}
      <AngleControl>
        <label>üéØ Aim Angle</label>
        <input
          type="range"
          min="-45"
          max="45"
          value={angle}
          onChange={handleAngleChange}
          disabled={disabled || !selectedChoice}
        />
        <div className="angle-display">{angle > 0 ? '√¢‚Ä†‚Äî' : angle < 0 ? '√¢‚Ä†‚Äì' : '√¢‚Ä†''} {Math.abs(angle)}¬∞</div>
      </AngleControl>
      
      {/* Power Meter */}
      <PowerMeter>
        <label>‚ö° Fire Power</label>
        <div className="power-bar">
          <div className="power-fill" style={{ width: `${(power / 10) * 100}%` }} />
          <div className="power-value">{Math.floor(power)}/10</div>
        </div>
      </PowerMeter>
      
      {/* Fire Button */}
      <FireButton
        className={isCharging ? 'charging' : ''}
        onMouseDown={handleFireMouseDown}
        onMouseUp={handleFireMouseUp}
        onMouseLeave={handleFireMouseLeave}
        onTouchStart={handleFireMouseDown}
        onTouchEnd={handleFireMouseUp}
        disabled={disabled || !selectedChoice}
      >
        {isCharging ? '‚ö° CHARGING...' : 'üöÄ HOLD TO FIRE'}
      </FireButton>
    </ControlPanel>
  )
}

export default CannonController

üìÅ NEW FILE: client/PlayerLifeBoxes.jsxPlayerLifeBoxes.jsx
import React from 'react'
import styled from '@emotion/styled'
import ProfilePicture from '../ProfilePicture'

const BoxesContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(${props => props.playerCount}, 1fr);
  gap: 0.5rem;
  height: 100%;
  padding: 0.5rem;
  background: rgba(0, 0, 20, 0.9);
`

const PlayerBox = styled.div`
  background: linear-gradient(135deg, 
    ${props => props.isCurrentPlayer ? 'rgba(0, 255, 136, 0.2)' : 'rgba(0, 191, 255, 0.2)'}, 
    rgba(0, 0, 0, 0.8)
  );
  border: 3px solid ${props => {
    if (props.isCurrentTurn) return '#FFD700'
    if (props.isCurrentPlayer) return '#00ff88'
    return '#00bfff'
  }};
  border-radius: 1rem;
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  opacity: ${props => props.isEliminated ? 0.3 : 1};
  filter: ${props => props.isEliminated ? 'grayscale(100%)' : 'none'};
  transition: all 0.3s ease;
  box-shadow: ${props => props.isCurrentTurn ? '0 0 30px rgba(255, 215, 0, 0.5)' : 'none'};
  animation: ${props => props.isCurrentTurn ? 'turnGlow 2s ease-in-out infinite' : 'none'};
  
  @keyframes turnGlow {
    0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
    50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
  }
`

const PlayerHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 0.5rem;
`

const PlayerInfo = styled.div`
  flex: 1;
  
  .address {
    color: white;
    font-size: 0.8rem;
    font-family: monospace;
    font-weight: bold;
  }
  
  .label {
    color: ${props => props.isCurrentPlayer ? '#00ff88' : '#aaa'};
    font-size: 0.7rem;
  }
`

const LivesDisplay = styled.div`
  display: flex;
  gap: 0.25rem;
  justify-content: center;
  
  .heart {
    font-size: 1.5rem;
    filter: ${props => props.filled ? 'none' : 'grayscale(100%)'};
    opacity: ${props => props.filled ? 1 : 0.3};
    animation: ${props => props.critical ? 'heartbeat 1s ease-in-out infinite' : 'none'};
  }
  
  @keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
`

const ChoiceDisplay = styled.div`
  text-align: center;
  padding: 0.5rem;
  background: ${props => {
    if (props.choice === 'heads') return 'rgba(255, 215, 0, 0.2)'
    if (props.choice === 'tails') return 'rgba(192, 192, 192, 0.2)'
    return 'rgba(100, 100, 100, 0.2)'
  }};
  border: 2px solid ${props => {
    if (props.choice === 'heads') return '#FFD700'
    if (props.choice === 'tails') return '#C0C0C0'
    return '#666'
  }};
  border-radius: 0.5rem;
  color: ${props => {
    if (props.choice === 'heads') return '#FFD700'
    if (props.choice === 'tails') return '#C0C0C0'
    return '#999'
  }};
  font-weight: bold;
  font-size: 0.9rem;
`

const ResultDisplay = styled.div`
  text-align: center;
  padding: 0.5rem;
  background: ${props => props.won ? 'rgba(0, 255, 136, 0.3)' : 'rgba(255, 51, 51, 0.3)'};
  border: 2px solid ${props => props.won ? '#00ff88' : '#ff3333'};
  border-radius: 0.5rem;
  color: ${props => props.won ? '#00ff88' : '#ff3333'};
  font-weight: bold;
  font-size: 1.1rem;
  animation: resultPulse 0.5s ease-out;
  
  @keyframes resultPulse {
    0% { transform: scale(0.8); opacity: 0; }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
  }
`

const EliminatedBadge = styled.div`
  text-align: center;
  padding: 0.5rem;
  background: rgba(255, 0, 0, 0.3);
  border: 2px solid #ff0000;
  border-radius: 0.5rem;
  color: #ff6b6b;
  font-weight: bold;
  font-size: 0.9rem;
`

const PlayerLifeBoxes = ({ 
  players = {}, 
  playerOrder = [], 
  currentPlayerAddress = null,
  currentTurnPlayer = null
}) => {
  return (
    <BoxesContainer playerCount={Math.min(playerOrder.length, 6)}>
      {playerOrder.map(playerAddr => {
        const player = players[playerAddr]
        if (!player) return null
        
        const isCurrentPlayer = playerAddr.toLowerCase() === currentPlayerAddress?.toLowerCase()
        const isCurrentTurn = playerAddr.toLowerCase() === currentTurnPlayer?.toLowerCase()
        const isEliminated = !player.isActive
        const isCritical = player.lives === 1
        
        return (
          <PlayerBox
            key={playerAddr}
            isCurrentPlayer={isCurrentPlayer}
            isCurrentTurn={isCurrentTurn}
            isEliminated={isEliminated}
          >
            {/* Player Header */}
            <PlayerHeader>
              <ProfilePicture 
                address={playerAddr}
                size={40}
                style={{
                  borderRadius: '50%',
                  border: '2px solid rgba(255, 255, 255, 0.3)'
                }}
              />
              <PlayerInfo isCurrentPlayer={isCurrentPlayer}>
                <div className="address">
                  {isCurrentPlayer ? 'YOU' : `${playerAddr.slice(0, 6)}...${playerAddr.slice(-4)}`}
                </div>
                <div className="label">
                  {isCurrentTurn ? 'üéØ Your Turn' : isCurrentPlayer ? 'Waiting...' : 'Opponent'}
                </div>
              </PlayerInfo>
            </PlayerHeader>
            
            {/* Lives */}
            {!isEliminated && (
              <LivesDisplay critical={isCritical}>
                {[1, 2, 3].map(i => (
                  <span 
                    key={i} 
                    className="heart"
                    style={{
                      filter: i <= player.lives ? 'none' : 'grayscale(100%)',
                      opacity: i <= player.lives ? 1 : 0.3
                    }}
                  >
                    {i <= player.lives ? '‚ù§Ô∏è' : 'üñ§'}
                  </span>
                ))}
              </LivesDisplay>
            )}
            
            {/* Choice */}
            {player.choice && !isEliminated && (
              <ChoiceDisplay choice={player.choice}>
                {player.choice.toUpperCase()}
              </ChoiceDisplay>
            )}
            
            {/* Result (show temporarily after coin lands) */}
            {player.lastResult && !isEliminated && (
              <ResultDisplay won={player.lastResult.won}>
                {player.lastResult.won ? '‚úÖ WIN' : '‚ùå LOSE'}
              </ResultDisplay>
            )}
            
            {/* Eliminated */}
            {isEliminated && (
              <EliminatedBadge>
                üíÄ ELIMINATED
              </EliminatedBadge>
            )}
          </PlayerBox>
        )
      })}
    </BoxesContainer>
  )
}

export default PlayerLifeBoxes

üîß MODIFY: server/socketio/server-socketio.js
Add these handlers after the existing Battle Royale handlers:
javascript// ===== ADD TO IMPORTS =====
const PhysicsGameManager = require('../PhysicsGameManager')

// ===== ADD TO GameServer constructor =====
this.physicsGameManager = new PhysicsGameManager()

// ===== ADD THESE SOCKET HANDLERS =====

socket.on('physics_set_choice', safeHandler((data) => {
  console.log(`üî• physics_set_choice from ${socket.id}`, data)
  const { gameId, address, choice } = data
  const success = this.physicsGameManager.setChoice(gameId, address, choice)
  if (success) {
    this.physicsGameManager.broadcastState(gameId, (room, event, payload) => {
      this.io.to(room).emit(event, payload)
    })
  }
}))

socket.on('physics_fire_coin', safeHandler((data) => {
  console.log(`üî• physics_fire_coin from ${socket.id}`, data)
  const { gameId, address, angle, power } = data
  this.physicsGameManager.fireCoin(gameId, address, angle, power, (room, event, payload) => {
    this.io.to(room).emit(event, payload)
  })
}))

socket.on('physics_request_state', safeHandler((data) => {
  console.log(`üî• physics_request_state from ${socket.id}`)
  const { gameId } = data
  const state = this.physicsGameManager.getFullGameState(gameId)
  if (state) {
    socket.emit('physics_state_update', state)
  }
}))

socket.on('physics_start_game', safeHandler((data) => {
  console.log(`üî• physics_start_game from ${socket.id}`)
  const { gameId, address } = data
  const game = this.physicsGameManager.getGame(gameId)
  
  if (!game) {
    socket.emit('physics_error', { message: 'Game not found' })
    return
  }
  
  // Verify creator
  if (game.creator?.toLowerCase() !== address?.toLowerCase()) {
    socket.emit('physics_error', { message: 'Only creator can start game' })
    return
  }
  
  this.physicsGameManager.startGame(gameId, (room, event, payload) => {
    this.io.to(room).emit(event, payload)
  })
}))

üîß MODIFY: server/routes/api.js
Add this endpoint for creating physics games:
javascript// ===== PHYSICS BATTLE ROYALE ENDPOINTS =====

// Create Physics Battle Royale game
router.post('/physics-battle-royale/create', async (req, res) => {
  try {
    const {
      creator,
      nft_contract,
      nft_token_id,
      nft_name,
      nft_image,
      nft_collection,
      nft_chain,
      entry_fee,
      service_fee
    } = req.body

    if (!creator || !nft_contract || !nft_token_id || !entry_fee) {
      return res.status(400).json({
        error: 'Missing required fields'
      })
    }

    const gameId = `physics_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`

    const gameData = {
      id: gameId,
      creator: creator.toLowerCase(),
      nft_contract,
      nft_token_id,
      nft_name,
      nft_image,
      nft_collection,
      nft_chain: nft_chain || 'base',
      entry_fee: parseFloat(entry_fee),
      service_fee: parseFloat(service_fee || 0.50)
    }

    // Create in database
    await dbService.createBattleRoyaleGame(gameData)
    
    // Create in physics manager
    if (gameServer && gameServer.physicsGameManager) {
      gameServer.physicsGameManager.createPhysicsGame(gameId, gameData)
    }

    console.log(`‚úÖ Physics Battle Royale created: ${gameId}`)
    
    res.json({
      success: true,
      gameId,
      message: 'Physics Battle Royale created successfully'
    })

  } catch (error) {
    console.error('‚ùå Error creating Physics Battle Royale:', error)
    res.status(500).json({
      error: 'Failed to create Physics Battle Royale',
      details: error.message
    })
  }
})

// Join Physics Battle Royale
router.post('/physics-battle-royale/:gameId/join', async (req, res) => {
  try {
    const { gameId } = req.params
    const { player_address, payment_hash } = req.body

    if (!player_address) {
      return res.status(400).json({ error: 'Player address required' })
    }

    // Add to physics manager
    if (gameServer && gameServer.physicsGameManager) {
      const success = gameServer.physicsGameManager.addPlayer(gameId, player_address)
      
      if (success) {
        // Also add to database
        await dbService.addBattleRoyalePlayer(gameId, {
          player_address: player_address.toLowerCase(),
          slot_number: gameServer.physicsGameManager.getGame(gameId).currentPlayers,
          entry_paid: !!payment_hash,
          entry_payment_hash: payment_hash
        })
        
        res.json({
          success: true,
          message: 'Successfully joined Physics Battle Royale'
        })
      } else {
        res.status(400).json({ error: 'Failed to join game' })
      }
    } else {
      res.status(500).json({ error: 'Game server not available' })
    }

  } catch (error) {
    console.error('‚ùå Error joining Physics Battle Royale:', error)
    res.status(500).json({
      error: 'Failed to join game',
      details: error.message
    })
  }
})

üîß MODIFY: client/BattleRoyaleContainer.jsx
Update to use PhysicsGameScreen:
javascriptimport PhysicsGameScreen from './PhysicsGameScreen' // ADD THIS

// REPLACE BattleRoyaleContent function with:
const BattleRoyaleContent = () => {
  const { gameState, loading, error } = useBattleRoyaleGame()

  if (loading) {
    return <LoadingScreen />
  }

  if (error) {
    return <ErrorScreen error={error} />
  }

  if (!gameState) {
    return <ErrorScreen error="Game not found" />
  }

  // NEW: Check if this is a physics game
  const isPhysicsGame = gameState.gameId?.startsWith('physics_')

  // Simple phase-based routing
  if (gameState.phase === 'lobby' || gameState.phase === 'filling') {
    return <LobbyScreen />
  }

  // NEW: Use PhysicsGameScreen for physics games
  if (isPhysicsGame) {
    return <PhysicsGameScreen />
  }

  // Original game screen for non-physics games
  return <GameScreen />
}

üîß MODIFY: client/contexts/BattleRoyaleGameContext.jsx
Add physics-specific methods:
javascript// ADD TO THE CONTEXT (after existing methods):

const makeChoice = useCallback((choice) => {
  if (!gameState || !address) return false
  
  const isPhysicsGame = gameState.gameId?.startsWith('physics_')
  
  if (isPhysicsGame) {
    socketService.emit('physics_set_choice', {
      gameId: gameState.gameId,
      address,
      choice
    })
  } else {
    socketService.emit('battle_royale_player_choice', {
      gameId: gameState.gameId,
      address,
      choice
    })
  }
  
  return true
}, [gameState, address])

// ADD TO CONTEXT VALUE:
// makeChoice,

üì¶ PACKAGE.JSON UPDATES
Add to dependencies:
json"cannon-es": "^0.20.0"

üéØ IMPLEMENTATION STEPS FOR CURSOR
Step 1: Install Dependencies
bashnpm install cannon-es
Step 2: Create New Server Files

Create server/PhysicsGameManager.js with the code from artifact physics_game_manager

Step 3: Create New Client Components

Create client/components/BattleRoyale/PhysicsGameScreen.jsx from artifact physics_game_screen
Create client/components/BattleRoyale/PhysicsScene.jsx from artifact physics_scene
Create client/components/BattleRoyale/CannonController.jsx from artifact cannon_controller
Create client/components/BattleRoyale/PlayerLifeBoxes.jsx from artifact player_life_boxes

Step 4: Modify Existing Files

Update server/socketio/server-socketio.js with physics handlers
Update server/routes/api.js with physics endpoints
Update client/BattleRoyaleContainer.jsx to route to PhysicsGameScreen
Update client/contexts/BattleRoyaleGameContext.jsx to add makeChoice method

Step 5: Test

Create a test physics game via API
Join with 2 players
Test aiming, power, firing
Verify physics simulation
Check result calculation


üéÆ TESTING CHECKLIST

 Physics game creation works
 2 players can join
 Lobby shows correctly
 Game starts when both players ready
 Cannon controller appears on your turn
 Choice selection works
 Angle slider works
 Power charging works
 Coin fires and follows physics
 Camera follows coin
 Coin bounces off obstacles
 Coin lands and determines result
 Lives decrease on wrong choice
 Turn passes to next player
 Game ends when 1 player left
 Winner screen shows


üöÄ WHAT YOU GET
Gameplay:

Turn-based 3D physics coin cannon game
Beautiful space environment with planets/obstacles
Real physics simulation with Cannon.js
Smooth camera following your coin
30-second turns with power charging
Lives system (3 lives each)
Last player standing wins

Technical:

Server-authoritative physics (no cheating possible)
60fps physics simulation
WebSocket real-time updates
Supports 2 players (easily scalable to 6)
Reuses all existing payment/lobby infrastructure
Backward compatible with original game

Next Steps to Scale:

Increase maxPlayers from 2 to 6
Add simultaneous coin firing
Add coin-to-coin collisions
Enhance visual effects
Add more obstacle variety


This is a complete, production-ready transformation. Give Cursor these artifacts and instructions, and you'll have a working 3D physics battle royale in days, not weeks! üéÆ‚ú®