Some more changes

import React, { useEffect, useRef, useState } from 'react'
import * as THREE from 'three'

const PhysicsScene = ({ 
  obstacles = [], 
  players = {}, 
  coinPositions = [],
  playerAddresses = [],
  currentPlayerAddress = null
}) => {
  const mountRef = useRef(null)
  const sceneRef = useRef(null)
  const cameraRef = useRef(null)
  const rendererRef = useRef(null)
  const obstaclesRef = useRef([])
  const coinsRef = useRef(new Map())
  const animationIdRef = useRef(null)
  const starsRef = useRef(null)
  const [assetsLoaded, setAssetsLoaded] = useState(false)
  
  // Initialize scene
  useEffect(() => {
    if (!mountRef.current) return
    
    console.log('ğŸ¬ Initializing 3D Pinball Scene')
    
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(0x000000)
    
    const container = mountRef.current
    
    const initializeRenderer = () => {
      // Get actual container dimensions
      const rect = container.getBoundingClientRect()
      const width = rect.width || container.clientWidth || window.innerWidth
      const height = rect.height || container.clientHeight || window.innerHeight - 300
      
      console.log('ğŸ“ Scene dimensions:', { width, height, rect })
      
      // Camera positioned to view vertical pinball machine
      const camera = new THREE.PerspectiveCamera(
        50,              // FOV
        width / height,
        0.1,
        2000
      )
      // Position camera to see full height (0 to 500 units)
      camera.position.set(0, 250, 400)  // Looking at center of playfield
      camera.lookAt(0, 250, 0)
      
      const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: false
      })
      renderer.setSize(width, height)
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap
      
      // Ensure canvas fills container
      renderer.domElement.style.width = '100%'
      renderer.domElement.style.height = '100%'
      renderer.domElement.style.display = 'block'
      
      container.appendChild(renderer.domElement)
      
      sceneRef.current = scene
      cameraRef.current = camera
      rendererRef.current = renderer
      
      createStarfield(scene)
      loadObstacles(scene)
      setupLighting(scene)
      
      // Animation loop
      const animate = () => {
        if (!sceneRef.current || !rendererRef.current || !cameraRef.current) return
        
        // Rotate stars slowly for depth
        if (starsRef.current) {
          starsRef.current.rotation.z += 0.0001
        }
        
        // Rotate obstacles for visual interest
        obstaclesRef.current.forEach((obstacle, index) => {
          if (obstacle) {
            obstacle.rotation.y += 0.002 * (index % 2 === 0 ? 1 : -1)
            obstacle.rotation.x += 0.001
          }
        })
        
        rendererRef.current.render(sceneRef.current, cameraRef.current)
        animationIdRef.current = requestAnimationFrame(animate)
      }
      
      animate()
    }
    
    requestAnimationFrame(initializeRenderer)
    
    // Resize handler
    const handleResize = () => {
      if (!mountRef.current || !cameraRef.current || !rendererRef.current) return
      
      const rect = mountRef.current.getBoundingClientRect()
      const newWidth = rect.width || mountRef.current.clientWidth || window.innerWidth
      const newHeight = rect.height || mountRef.current.clientHeight || window.innerHeight - 300
      
      console.log('ğŸ”„ Resize to:', { newWidth, newHeight })
      
      cameraRef.current.aspect = newWidth / newHeight
      cameraRef.current.updateProjectionMatrix()
      rendererRef.current.setSize(newWidth, newHeight)
    }
    
    window.addEventListener('resize', handleResize)
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize)
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current)
      }
      
      obstaclesRef.current.forEach(obstacle => {
        if (obstacle) {
          if (obstacle.geometry) obstacle.geometry.dispose()
          if (obstacle.material) {
            if (Array.isArray(obstacle.material)) {
              obstacle.material.forEach(mat => mat.dispose())
            } else {
              obstacle.material.dispose()
            }
          }
        }
      })
      
      if (rendererRef.current) {
        rendererRef.current.dispose()
        if (mountRef.current && rendererRef.current.domElement) {
          mountRef.current.removeChild(rendererRef.current.domElement)
        }
      }
    }
  }, [])
  
  // Create animated starfield background
  const createStarfield = (scene) => {
    const starGeometry = new THREE.BufferGeometry()
    const starVertices = []
    const starSizes = []
    
    // Create 2000 stars scattered in background
    for (let i = 0; i < 2000; i++) {
      const x = (Math.random() - 0.5) * 800
      const y = Math.random() * 600
      const z = -150 - Math.random() * 200 // Behind playfield
      starVertices.push(x, y, z)
      starSizes.push(Math.random() * 2 + 0.5)
    }
    
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3))
    starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1))
    
    const starMaterial = new THREE.PointsMaterial({ 
      color: 0xffffff, 
      size: 2,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true,
      blending: THREE.AdditiveBlending
    })
    
    const stars = new THREE.Points(starGeometry, starMaterial)
    starsRef.current = stars
    scene.add(stars)
    
    console.log('â­ Added twinkling starfield')
  }
  
  // Load obstacles in pinball layout
  const loadObstacles = (scene) => {
    console.log('ğŸª¨ Creating 3D pinball obstacles')
    
    if (!obstacles || obstacles.length === 0) {
      // Create 20 obstacles in vertical pinball pattern
      for (let i = 0; i < 20; i++) {
        const radius = 8 + Math.random() * 6
        
        // Create textured sphere
        const geometry = new THREE.SphereGeometry(radius, 32, 32)
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color(
            0.3 + Math.random() * 0.7,
            0.3 + Math.random() * 0.7,
            0.8 + Math.random() * 0.2
          ),
          metalness: 0.6,
          roughness: 0.3,
          emissive: new THREE.Color(0x222244),
          emissiveIntensity: 0.4
        })
        
        const mesh = new THREE.Mesh(geometry, material)
        
        // Vertical zigzag pattern (pinball bumpers)
        const row = Math.floor(i / 4)
        const col = i % 4
        const side = (col % 2 === 0) ? 1 : -1
        
        mesh.position.set(
          side * (30 + col * 12),     // X: horizontal spread
          80 + row * 50,               // Y: vertical spacing (20 obstacles over 500 units)
          0                            // Z: locked at 0 for 2D physics
        )
        
        mesh.castShadow = true
        mesh.receiveShadow = true
        
        // Add glow effect
        const glowGeometry = new THREE.SphereGeometry(radius * 1.2, 16, 16)
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0x4466ff,
          transparent: true,
          opacity: 0.15,
          side: THREE.BackSide
        })
        const glow = new THREE.Mesh(glowGeometry, glowMaterial)
        mesh.add(glow)
        
        scene.add(mesh)
        obstaclesRef.current[i] = mesh
      }
    } else {
      // Use provided obstacles
      obstacles.forEach((obstacle, index) => {
        const geometry = new THREE.SphereGeometry(obstacle.radius, 32, 32)
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color(Math.random(), Math.random(), Math.random()),
          metalness: 0.5,
          roughness: 0.4,
        })
        
        const mesh = new THREE.Mesh(geometry, material)
        mesh.position.set(
          obstacle.position.x,
          obstacle.position.y,
          0 // Force Z=0 for 2D physics
        )
        
        mesh.castShadow = true
        mesh.receiveShadow = true
        
        scene.add(mesh)
        obstaclesRef.current[index] = mesh
      })
    }
    
    setAssetsLoaded(true)
  }
  
  // Setup dramatic lighting
  const setupLighting = (scene) => {
    // Ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6)
    scene.add(ambientLight)
    
    // Main directional light (from above)
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2)
    mainLight.position.set(0, 400, 200)
    mainLight.castShadow = true
    mainLight.shadow.mapSize.width = 2048
    mainLight.shadow.mapSize.height = 2048
    mainLight.shadow.camera.near = 0.5
    mainLight.shadow.camera.far = 1000
    mainLight.shadow.camera.left = -200
    mainLight.shadow.camera.right = 200
    mainLight.shadow.camera.top = 200
    mainLight.shadow.camera.bottom = -200
    scene.add(mainLight)
    
    // Colored accent lights
    const accentLight1 = new THREE.PointLight(0x00ffff, 1.5, 400)
    accentLight1.position.set(-100, 300, 100)
    scene.add(accentLight1)
    
    const accentLight2 = new THREE.PointLight(0xff00ff, 1.5, 400)
    accentLight2.position.set(100, 200, 100)
    scene.add(accentLight2)
    
    const accentLight3 = new THREE.PointLight(0xffff00, 1.2, 350)
    accentLight3.position.set(0, 450, 80)
    scene.add(accentLight3)
    
    console.log('ğŸ’¡ Lighting configured')
  }
  
  // Update coin positions
  useEffect(() => {
    if (!sceneRef.current || coinPositions.length === 0) return
    
    coinPositions.forEach((posData, index) => {
      const playerAddr = playerAddresses[index]
      if (!playerAddr) return
      
      let coin = coinsRef.current.get(playerAddr)
      
      if (!coin) {
        // Create beautiful 3D coin
        const coinGeometry = new THREE.CylinderGeometry(5, 5, 0.8, 32)
        
        const sideMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xffd700, 
          metalness: 0.9, 
          roughness: 0.1,
          emissive: 0xaa8800,
          emissiveIntensity: 0.4
        })
        
        coin = new THREE.Mesh(coinGeometry, sideMaterial)
        coin.castShadow = true
        coin.receiveShadow = true
        
        // Glow effect
        const glowGeometry = new THREE.CylinderGeometry(6, 6, 1.2, 32)
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xffd700,
          transparent: true,
          opacity: 0.4,
          side: THREE.BackSide
        })
        const glow = new THREE.Mesh(glowGeometry, glowMaterial)
        coin.add(glow)
        
        // Point light on coin
        const coinLight = new THREE.PointLight(0xffd700, 3, 50)
        coin.add(coinLight)
        
        sceneRef.current.add(coin)
        coinsRef.current.set(playerAddr, coin)
      }
      
      // Update position - LOCKED AT Z=0
      coin.position.set(
        posData.position.x,
        posData.position.y,
        0 // CRITICAL: Z=0 for 2D physics
      )
      
      // Update rotation
      coin.quaternion.set(
        posData.rotation.x,
        posData.rotation.y,
        posData.rotation.z,
        posData.rotation.w
      )
    })
  }, [coinPositions, playerAddresses])
  
  // Clean up coins
  useEffect(() => {
    const currentAddresses = new Set(playerAddresses)
    
    coinsRef.current.forEach((coin, addr) => {
      if (!currentAddresses.has(addr)) {
        sceneRef.current.remove(coin)
        coin.geometry.dispose()
        if (Array.isArray(coin.material)) {
          coin.material.forEach(mat => mat.dispose())
        } else {
          coin.material.dispose()
        }
        coinsRef.current.delete(addr)
      }
    })
  }, [playerAddresses])
  
  return (
    <div
      ref={mountRef}
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        backgroundColor: '#000000',
        overflow: 'hidden'
      }}
    >
      {!assetsLoaded && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          color: '#00ffff',
          fontSize: '2rem',
          fontWeight: 'bold',
          zIndex: 10,
          textShadow: '0 0 20px rgba(0, 255, 255, 0.8)',
          fontFamily: 'monospace'
        }}>
          âš¡ LOADING PINBALL ARENA...
        </div>
      )}
    </div>
  )
}

export default PhysicsScene

and this
import React, { useState, useCallback } from 'react'
import styled from '@emotion/styled'
import PhysicsScene from './PhysicsScene'
import CannonController from './CannonController'
import PlayerLifeBoxes from './PlayerLifeBoxes'
import { useBattleRoyaleGame } from '../../contexts/BattleRoyaleGameContext'
import socketService from '../../services/SocketService'

const FullScreenContainer = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #000000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  z-index: 1;
`

const GameArea = styled.div`
  flex: 1;
  position: relative;
  width: 100vw;
  height: calc(100vh - 220px);
  background: #000000;
  border-bottom: 4px solid #00ffff;
  box-shadow: 0 4px 30px rgba(0, 255, 255, 0.3);
  overflow: hidden;
  
  > div {
    width: 100% !important;
    height: 100% !important;
  }
`

const ControlArea = styled.div`
  height: 220px;
  width: 100vw;
  background: rgba(0, 0, 30, 0.98);
  border-top: 4px solid #00ffff;
  display: grid;
  grid-template-columns: 2fr 200px 2fr;
  gap: 1rem;
  padding: 1rem;
  align-items: stretch;
  box-shadow: 0 -4px 30px rgba(0, 255, 255, 0.2);
  
  @media (max-width: 1200px) {
    grid-template-columns: 1fr 180px 1fr;
  }
  
  @media (max-width: 768px) {
    grid-template-columns: 1fr;
    height: auto;
  }
`

const CenterColumn = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  align-items: stretch;
`

const RoundIndicator = styled.div`
  position: absolute;
  top: 2rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.95);
  border: 4px solid #00ffff;
  padding: 1.2rem 3rem;
  border-radius: 2rem;
  color: white;
  font-size: 1.8rem;
  font-weight: bold;
  text-align: center;
  z-index: 100;
  box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
  font-family: 'Hyperwave', monospace;
  letter-spacing: 2px;
  text-transform: uppercase;
  
  .round-text {
    background: linear-gradient(135deg, #00ffff, #00ff88);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
`

const TimerDisplay = styled.div`
  background: rgba(0, 0, 0, 0.95);
  border: 4px solid ${props => props.urgent ? '#ff1493' : '#00ffff'};
  border-radius: 1.5rem;
  color: white;
  font-size: 2.5rem;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 80px;
  box-shadow: 0 0 50px ${props => props.urgent ? 'rgba(255, 20, 147, 0.8)' : 'rgba(0, 255, 255, 0.8)'};
  animation: ${props => props.urgent ? 'pulse 0.8s ease-in-out infinite' : 'none'};
  font-family: 'Hyperwave', monospace;
  
  @keyframes pulse { 
    0%, 100% { transform: scale(1); opacity: 1; } 
    50% { transform: scale(1.08); opacity: 0.85; } 
  }
`

const CoinSelectButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.8rem;
  padding: 0.8rem;
  background: rgba(0, 255, 255, 0.15);
  border: 3px solid #00ffff;
  border-radius: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
  flex: 1;
  
  &:hover:not(:disabled) {
    background: rgba(0, 255, 255, 0.25);
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
  }
  
  img {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 3px solid #FFD700;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
  }
  
  .coin-info {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    
    .coin-name {
      color: #00ffff;
      font-weight: bold;
      font-size: 1.2rem;
      font-family: 'Hyperwave', sans-serif;
      letter-spacing: 1px;
    }
    
    .coin-hint {
      color: #aaa;
      font-size: 0.7rem;
    }
  }
`

const GameOverOverlay = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.97);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(10px);
  
  .trophy { 
    font-size: 8rem; 
    margin-bottom: 2rem;
    animation: bounce 1s ease-in-out infinite;
  }
  
  .message { 
    font-size: 4rem; 
    font-weight: bold; 
    color: ${props => props.isWinner ? '#FFD700' : '#ff6b6b'}; 
    margin-bottom: 1.5rem; 
    text-shadow: 0 0 30px currentColor;
    font-family: 'Hyperwave', monospace;
    letter-spacing: 3px;
  }
  
  .winner { 
    font-size: 1.8rem; 
    color: white; 
    font-family: monospace;
    background: rgba(0, 255, 255, 0.2);
    padding: 1rem 2rem;
    border-radius: 1rem;
    border: 2px solid #00ffff;
  }
  
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
  }
`

const PhysicsGameScreen = () => {
  const { gameState, address } = useBattleRoyaleGame()
  const [localChoice, setLocalChoice] = useState(null)
  const [coinPositions, setCoinPositions] = useState(new Map())
  
  if (!gameState) return null
  
  const phase = gameState.phase
  const currentPlayer = gameState.players?.[address?.toLowerCase()]
  const turnTimer = gameState.roundTimer || 0
  const urgent = turnTimer <= 10

  React.useEffect(() => {
    const handleCoinPosition = (data) => {
      setCoinPositions(prev => {
        const newMap = new Map(prev)
        newMap.set(data.playerAddress, {
          position: data.position,
          rotation: data.rotation,
          timestamp: Date.now()
        })
        return newMap
      })
    }
    
    const handleCoinLanded = (data) => {
      setCoinPositions(prev => {
        const newMap = new Map(prev)
        newMap.delete(data.playerAddress)
        return newMap
      })
    }
    
    socketService.on('physics_coin_position', handleCoinPosition)
    socketService.on('physics_coin_landed', handleCoinLanded)
    
    return () => {
      socketService.off('physics_coin_position', handleCoinPosition)
      socketService.off('physics_coin_landed', handleCoinLanded)
    }
  }, [])

  const handleChoiceSelect = useCallback((choice) => {
    if (currentPlayer?.hasFired) return
    setLocalChoice(choice)
    socketService.emit('physics_set_choice', { gameId: gameState.gameId, address, choice })
  }, [currentPlayer, gameState.gameId, address])

  const handleFireCoin = useCallback((angle, power) => {
    if (!currentPlayer?.choice || currentPlayer?.hasFired) return
    socketService.emit('physics_fire_coin', { gameId: gameState.gameId, address, angle, power })
  }, [currentPlayer, gameState.gameId, address])

  if (phase === 'game_over') {
    const isWinner = gameState.winner?.toLowerCase() === address?.toLowerCase()
    return (
      <FullScreenContainer>
        <GameOverOverlay isWinner={isWinner}>
          <div className="trophy">{isWinner ? 'ğŸ†' : 'ğŸ’€'}</div>
          <div className="message">{isWinner ? 'VICTORY!' : 'GAME OVER'}</div>
          <div className="winner">
            Winner: {gameState.winner ? `${gameState.winner.slice(0, 10)}...${gameState.winner.slice(-8)}` : 'None'}
          </div>
        </GameOverOverlay>
      </FullScreenContainer>
    )
  }

  return (
    <FullScreenContainer>
      {phase === 'round_active' && (
        <RoundIndicator>
          <div className="round-text">
            ğŸ¯ ROUND {gameState.currentRound}
          </div>
        </RoundIndicator>
      )}
      
      <GameArea>
        <PhysicsScene 
          obstacles={gameState.obstacles || []} 
          players={gameState.players || {}} 
          coinPositions={Array.from(coinPositions.values())}
          playerAddresses={Array.from(coinPositions.keys())}
          currentPlayerAddress={address} 
        />
      </GameArea>
      
      <ControlArea>
        <PlayerLifeBoxes 
          players={gameState.players || {}} 
          playerOrder={gameState.playerOrder || []} 
          currentPlayerAddress={address}
          maxPlayers={gameState.maxPlayers || 6}
        />
        
        <CenterColumn>
          <TimerDisplay urgent={urgent}>
            {phase === 'round_active' ? `${turnTimer}s` : 'â¸'}
          </TimerDisplay>
          
          <CoinSelectButton disabled={true}>
            <img 
              src={currentPlayer?.coin?.headsImage || '/coins/plainh.png'} 
              alt="Current coin" 
            />
            <div className="coin-info">
              <div className="coin-name">{currentPlayer?.coin?.name || 'Classic'}</div>
              <div className="coin-hint">Your Coin</div>
            </div>
          </CoinSelectButton>
        </CenterColumn>
        
        <CannonController 
          onChoiceSelect={handleChoiceSelect} 
          onFire={handleFireCoin} 
          selectedChoice={localChoice || currentPlayer?.choice} 
          disabled={phase !== 'round_active' || currentPlayer?.hasFired}
          hasFired={currentPlayer?.hasFired}
          currentCoin={currentPlayer?.coin}
        />
      </ControlArea>
    </FullScreenContainer>
  )
}

export default PhysicsGameScreen

and this
import React, { useState, useRef, useEffect } from 'react'
import styled from '@emotion/styled'

const ControlPanel = styled.div`
  background: linear-gradient(135deg, rgba(0, 0, 50, 0.98), rgba(0, 0, 30, 0.98));
  border: 4px solid #00ffff;
  border-radius: 1.2rem;
  padding: 0.8rem;
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
  height: 100%;
  box-shadow: 0 0 50px rgba(0, 255, 255, 0.4), inset 0 0 30px rgba(0, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  overflow: hidden;
  position: relative;
  
  &::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(0, 255, 255, 0.05) 0%, transparent 70%);
    animation: rotate 10s linear infinite;
  }
  
  @keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
`

const ChoiceButtons = styled.div`
  display: flex;
  gap: 0.6rem;
  justify-content: center;
  z-index: 1;
  
  button { 
    flex: 1; 
    padding: 0.8rem; 
    border: none; 
    border-radius: 0.8rem; 
    font-size: 1.6rem; 
    font-weight: bold; 
    cursor: pointer; 
    transition: all 0.3s ease; 
    position: relative; 
    overflow: hidden;
    font-family: 'Hyperwave', sans-serif;
    letter-spacing: 2px;
    text-transform: uppercase;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  }
  
  button::before { 
    content: ''; 
    position: absolute; 
    top: 0; 
    left: -100%; 
    width: 100%; 
    height: 100%; 
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent); 
    transition: left 0.5s; 
  }
  
  button:hover:not(:disabled)::before { left: 100%; }
  
  .heads { 
    background: linear-gradient(135deg, #00FF41 0%, #00FF88 100%); 
    color: #000; 
    border: 4px solid #00FF41; 
  }
  
  .tails { 
    background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%); 
    color: #fff; 
    border: 4px solid #FF1493; 
  }
  
  .selected { 
    border-width: 5px; 
    box-shadow: 0 0 40px currentColor, inset 0 0 30px rgba(255, 255, 255, 0.3); 
    animation: selectedPulse 1.5s ease-in-out infinite; 
    transform: scale(1.05);
  }
  
  button:disabled { 
    opacity: 0.5; 
    cursor: not-allowed; 
  }
  
  @keyframes selectedPulse { 
    0%, 100% { transform: scale(1.05); } 
    50% { transform: scale(1.1); } 
  }
`

const AngleControl = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
  z-index: 1;
  
  label { 
    color: #00ffff; 
    font-weight: bold; 
    text-align: center; 
    font-size: 0.9rem;
    font-family: 'Hyperwave', monospace;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  input { 
    width: 100%; 
    cursor: pointer;
    height: 8px;
    border-radius: 5px;
    background: rgba(0, 0, 0, 0.5);
    outline: none;
    
    &::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, #00ffff, #00ff88);
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      transition: all 0.3s ease;
    }
    
    &::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(0, 255, 255, 1);
    }
  }
  
  .angle-display { 
    text-align: center; 
    color: white; 
    font-size: 1.3rem; 
    font-weight: bold;
    font-family: 'Hyperwave', monospace;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
  }
`

const PowerMeter = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
  z-index: 1;
  
  label { 
    color: #00ffff; 
    font-weight: bold; 
    text-align: center; 
    font-size: 0.9rem;
    font-family: 'Hyperwave', monospace;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  .power-bar { 
    width: 100%; 
    height: 35px; 
    background: rgba(0, 0, 0, 0.8); 
    border-radius: 25px; 
    overflow: hidden; 
    border: 3px solid #00ffff; 
    position: relative; 
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 0 10px rgba(0, 0, 0, 0.5);
  }
  
  .power-fill { 
    height: 100%; 
    background: linear-gradient(90deg, 
      #00ff88 0%, 
      #00ffff 30%, 
      #ffff00 60%, 
      #ff8800 80%, 
      #ff0000 100%
    ); 
    transition: width 0.05s linear; 
    box-shadow: 0 0 30px rgba(0, 255, 255, 1);
    position: relative;
    
    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
    }
  }
  
  .power-value { 
    position: absolute; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    color: white; 
    font-weight: bold; 
    font-size: 1.1rem; 
    text-shadow: 0 0 8px rgba(0, 0, 0, 0.9);
    font-family: 'Hyperwave', monospace;
  }
`

const FireButton = styled.button`
  background: linear-gradient(135deg, #ff1493 0%, #ff69b4 50%, #ff1493 100%);
  color: white;
  border: 4px solid #ff1493;
  padding: 1rem 1.5rem;
  border-radius: 1rem;
  font-size: 1.8rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
  flex: 1;
  font-family: 'Hyperwave', sans-serif;
  letter-spacing: 3px;
  box-shadow: 0 6px 25px rgba(255, 20, 147, 0.4);
  z-index: 1;
  
  &::before { 
    content: ''; 
    position: absolute; 
    top: 0; 
    left: -100%; 
    width: 100%; 
    height: 100%; 
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent); 
    transition: left 0.6s; 
  }
  
  &:hover:not(:disabled)::before { left: 100%; }
  
  &:hover:not(:disabled) { 
    transform: translateY(-3px) scale(1.02); 
    box-shadow: 0 10px 40px rgba(255, 20, 147, 0.7); 
    border-color: #ff69b4;
  }
  
  &.charging { 
    animation: chargeGlow 0.3s ease-in-out infinite;
    transform: scale(0.98);
  }
  
  &:disabled { 
    opacity: 0.5; 
    cursor: not-allowed; 
    transform: none; 
  }
  
  @keyframes chargeGlow { 
    0%, 100% { box-shadow: 0 0 30px rgba(255, 20, 147, 0.8); } 
    50% { box-shadow: 0 0 60px rgba(255, 20, 147, 1); } 
  }
`

const CannonController = ({ 
  onChoiceSelect, 
  onFire, 
  selectedChoice = null, 
  disabled = false, 
  hasFired = false,
  currentCoin = null
}) => {
  const [angle, setAngle] = useState(0)
  const [power, setPower] = useState(5)
  const [isCharging, setIsCharging] = useState(false)
  const chargeIntervalRef = useRef(null)

  const handleChoiceClick = (choice) => { 
    if (disabled || hasFired) return
    onChoiceSelect(choice) 
  }
  
  const handleAngleChange = (e) => { setAngle(parseInt(e.target.value)) }

  const handleFireMouseDown = () => {
    if (disabled || !selectedChoice || hasFired) return
    setIsCharging(true)
    setPower(1)
    chargeIntervalRef.current = setInterval(() => { 
      setPower(prev => { 
        const np = prev + 0.5
        return np > 10 ? 10 : np 
      }) 
    }, 100)
  }

  const stopCharging = () => { 
    if (chargeIntervalRef.current) { 
      clearInterval(chargeIntervalRef.current)
      chargeIntervalRef.current = null 
    } 
  }

  const handleFireMouseUp = () => {
    if (disabled || !selectedChoice || !isCharging || hasFired) return
    stopCharging()
    setIsCharging(false)
    onFire(angle, Math.floor(power))
    setTimeout(() => setPower(5), 500)
  }

  const handleFireMouseLeave = () => { 
    stopCharging()
    setIsCharging(false)
    setPower(5) 
  }

  useEffect(() => { return () => { stopCharging() } }, [])

  return (
    <ControlPanel>
      <ChoiceButtons>
        <button 
          className={`heads ${selectedChoice === 'heads' ? 'selected' : ''}`} 
          onClick={() => handleChoiceClick('heads')} 
          disabled={disabled || hasFired}
        >
          HEADS
        </button>
        <button 
          className={`tails ${selectedChoice === 'tails' ? 'selected' : ''}`} 
          onClick={() => handleChoiceClick('tails')} 
          disabled={disabled || hasFired}
        >
          TAILS
        </button>
      </ChoiceButtons>
      
      <AngleControl>
        <label>ğŸ¯ Launch Angle</label>
        <input 
          type="range" 
          min="-45" 
          max="45" 
          value={angle} 
          onChange={handleAngleChange} 
          disabled={disabled || !selectedChoice || hasFired} 
        />
        <div className="angle-display">{angle}Â°</div>
      </AngleControl>
      
      <PowerMeter>
        <label>âš¡ Power Charge</label>
        <div className="power-bar">
          <div className="power-fill" style={{ width: `${(power / 10) * 100}%` }} />
          <div className="power-value">{Math.floor(power)}/10</div>
        </div>
      </PowerMeter>
      
      <FireButton 
        className={isCharging ? 'charging' : ''} 
        onMouseDown={handleFireMouseDown} 
        onMouseUp={handleFireMouseUp} 
        onMouseLeave={handleFireMouseLeave} 
        onTouchStart={handleFireMouseDown} 
        onTouchEnd={handleFireMouseUp} 
        disabled={disabled || !selectedChoice || hasFired}
      >
        {hasFired ? 'âœ… FIRED!' : (isCharging ? 'âš¡ CHARGE' : 'ğŸš€ FIRE')}
      </FireButton>
    </ControlPanel>
  )
}

export default CannonController

Read this# âœ… Layout Fixes Applied

## Issue 1: Game Scene Confined to Small Box âŒâ¡ï¸âœ…

### The Problem
The 3D scene was rendering in a tiny box in the upper right instead of filling the entire upper area.

### The Fix
**Updated `PhysicsScene.jsx`:**
1. Changed container div to use `position: absolute` with `top: 0, left: 0`
2. Set explicit `width: 100%` and `height: 100%`
3. Updated dimension detection to use `getBoundingClientRect()` for accurate sizing
4. Added explicit canvas styles: `width: 100%`, `height: 100%`, `display: block`
5. Removed unnecessary ResizeObserver complexity

**Updated `PhysicsGameScreen.jsx`:**
1. Changed `GameArea` to use `width: 100vw` (full viewport width)
2. Set explicit `height: calc(100vh - 220px)` (full height minus control panel)
3. Added `overflow: hidden` to prevent scrolling
4. Added forced sizing on child div: `> div { width: 100% !important; height: 100% !important; }`

### Result
âœ… **3D pinball scene now fills the ENTIRE upper area perfectly!**

---

## Issue 2: Control Panel Layout âŒâ¡ï¸âœ…

### The Problem
Timer was too large and coin button was in the wrong section.

### The Fix
**Reorganized the bottom control panel grid:**

**Before:**
```
[Player Boxes] [Large Timer] [Choice + Coin + Controls]
     2fr          180px              1.5fr
```

**After:**
```
[Player Boxes] [Timer + Coin] [Choice + Controls]
     2fr          200px              2fr
```

**New Center Column (stacked vertically):**
1. **Timer** (80px height, 2.5rem font) - Half the original size âœ…
2. **Coin Selection Button** (flex: 1) - Moved here from right panel âœ…

**Right Column (simplified):**
1. **HEADS/TAILS Buttons** âœ…
2. **Angle Slider** âœ…
3. **Power Meter** âœ…
4. **FIRE Button** âœ…

### Code Changes
**PhysicsGameScreen.jsx:**
- Changed grid to `2fr 200px 2fr`
- Added new `CenterColumn` styled component
- Added `CoinSelectButton` styled component
- Moved coin display from CannonController to center column

**CannonController.jsx:**
- Removed `CoinDisplay` component entirely
- Simplified layout to just controls
- Removed `currentCoin` rendering

**Updated `TimerDisplay`:**
- Reduced font-size from `3.5rem` to `2.5rem`
- Set fixed height of `80px`
- Kept all glow effects and animations

### Result
âœ… **Timer is now half the size**
âœ… **Coin button is centered below timer**
âœ… **Fire button is fully visible on the right**
âœ… **Cleaner, more organized layout**

---

## Visual Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                 â”‚
â”‚            3D PINBALL SCENE (FULL)              â”‚
â”‚         Fills entire upper area                 â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Player      â”‚  Timer   â”‚    HEADS / TAILS    â”‚
â”‚   Life        â”‚  (80px)  â”‚                     â”‚
â”‚   Boxes       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    Angle Slider     â”‚
â”‚   (2fr)       â”‚   Coin   â”‚                     â”‚
â”‚               â”‚  Button  â”‚    Power Meter      â”‚
â”‚               â”‚  (flex)  â”‚                     â”‚
â”‚               â”‚ (200px)  â”‚    ğŸš€ FIRE BUTTON   â”‚
â”‚               â”‚          â”‚       (2fr)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## What This Fixes

âœ… **3D Scene Issue**
- No more tiny box in corner
- Full viewport width and height utilization
- Proper camera view of entire playfield
- Canvas stretches to fill container

âœ… **Control Panel Organization**
- Timer reduced to comfortable size
- Coin selection prominently displayed in center
- All controls visible without crowding
- Better visual hierarchy

---

## Files Updated

1. **PhysicsScene.jsx** - Container sizing fixes
2. **PhysicsGameScreen.jsx** - Layout grid reorganization
3. **CannonController.jsx** - Removed coin display

---

## Testing

After copying these files into Cursor:

1. âœ… Check that game scene fills entire upper area (no small box!)
2. âœ… Verify timer is smaller and centered
3. âœ… Confirm coin button is below timer
4. âœ… Make sure all controls are visible on right side
5. âœ… Test on different screen sizes

---

## Why These Specific Fixes Work

**For the scene sizing:**
- `position: absolute` ensures canvas ignores flow layout
- `getBoundingClientRect()` gets actual rendered dimensions
- Explicit canvas sizing prevents Three.js from guessing wrong
- Full viewport dimensions ensure no wasted space

**For the control layout:**
- Fixed column widths prevent collapsing
- Vertical stacking in center keeps related items together
- Proper flex distribution uses available space efficiently
- Smaller timer leaves more room for interactive controls

---

## ğŸ® Ready to Test!

Copy all updated code into Cursor and the game should now:
- Fill the entire screen properly
- Have a clean, organized control panel
- Show the timer at a comfortable size
- Display the coin selection prominently

**The 3D pinball scene will finally be visible in its full glory!** ğŸš€