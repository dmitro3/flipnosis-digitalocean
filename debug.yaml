I've carefully read through your entire code, and I found multiple issues causing the pearl animation problem. Let me break down what I discovered:
ğŸ” Root Causes of the Pearl Animation Issue
1. Server Broadcast Throttling (Primary Issue)
javascript// Lines ~2867-2875
if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === i) {
  // Only broadcast every 10th frame (6 times per second instead of 60) to reduce server load
  if (frameCount % 10 === 0) {
    console.log(`âš¡ Broadcasting power charging to server...`);
    socket.emit('physics_power_charging', {...});
  }
}
Problem: You're only sending power updates to the server every 10 frames (6 times/second), but the animation runs at 60fps. This creates a ~167ms delay before other players even know you're charging, plus the animation looks choppy on their screens.
2. Viewer Pearl Cycle Conflicts
javascript// Lines ~1540-1585
function startViewerPearlCycle(tubeIndex, powerLevel) {
  // This 5-second cycle REPLACES incremental updates for viewers
  return; // Exits early, preventing normal animation
}
Problem: When other players receive your charging update, it triggers a 5-second fixed animation cycle instead of real-time updates. This causes:

Delayed start (waits for first server message)
Disconnected from actual charging progress
Visual desync between charger and viewers

3. Race Condition in updatePowerChargingVisual
javascript// Lines ~1485-1515
if (data.playerSlot !== playerSlot && data.isFilling) {
  console.log(`ğŸŒŠ Starting 5-second pearl cycle for viewer...`);
  startViewerPearlCycle(data.playerSlot, tube.powerLevel);
  return; // âš ï¸ EXITS HERE - never reaches actual pearl color updates below!
}
Problem: For viewers, the function returns early, skipping all the pearl color/intensity updates that make them glow!

ğŸ¯ Recommended Solution: Real-Time Broadcast Architecture
Here's a refactored approach that preserves your beautiful pearl visuals while fixing sync:
javascript// ===== POWER CHARGING SYSTEM - REFACTORED FOR REAL-TIME SYNC =====

// 1. IMMEDIATE server notification when charging STARTS
powerButton.addEventListener('mousedown', (e) => {
  e.stopPropagation();
  
  if (players[i].lives <= 0 || !players[i].choice || tubes[i].hasUsedPower) return;
  
  console.log(`âš¡ Charging power for tube ${i + 1}`);
  isCharging = true;
  tubes[i].isFilling = true;
  tubes[i].power = 0;
  
  playSound(powerChargeSound);
  
  // ğŸ¯ INSTANT BROADCAST - Tell everyone charging started
  if (isServerSideMode && socket && gameIdParam && walletParam) {
    socket.emit('physics_power_charging_start', {
      gameId: gameIdParam,
      address: walletParam,
      playerSlot: i
    });
  }
});

// 2. LIGHTWEIGHT periodic updates (reduce from every 10 frames to every 5 frames)
// In animate() loop around line 2867:
if (tube.isFilling && !tube.isShattered) {
  tube.power = Math.min(tube.power + 0.6, 100);
  const powerPercent = tube.power / 100;
  tube.foamIntensity = powerPercent;
  const powerLevel = Math.min(5, Math.max(1, Math.ceil(tube.power / 20)));
  
  // ğŸ¯ FASTER UPDATES - Every 5 frames = 12 updates/second
  if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === i) {
    if (frameCount % 5 === 0) { // Changed from 10 to 5
      socket.emit('physics_power_charging', {
        gameId: gameIdParam,
        address: walletParam,
        power: tube.power,
        powerLevel: powerLevel,
        playerSlot: i,
        isFilling: true
      });
    }
  }
  
  // ğŸ¯ LOCAL PEARL ANIMATION (same beautiful code)
  updatePearlAnimation(tube, powerPercent, i);
  updatePearlColors(tube, powerPercent, i);
}

// 3. REFACTORED viewer update - NO 5-second cycle, REAL-TIME mirroring
function updatePowerChargingVisual(data) {
  if (data.playerSlot >= 0 && data.playerSlot < 4) {
    const tube = tubes[data.playerSlot];
    if (!tube) return;
    
    tube.power = data.power;
    tube.powerLevel = data.powerLevel || Math.min(5, Math.max(1, Math.ceil(data.power / 20)));
    tube.isFilling = data.isFilling;
    
    const powerPercent = tube.power / 100;
    tube.foamIntensity = powerPercent;
    
    // ğŸ¯ SAME ANIMATION FOR EVERYONE - No viewer-specific cycle!
    updatePearlAnimation(tube, powerPercent, data.playerSlot);
    updatePearlColors(tube, powerPercent, data.playerSlot);
    
    console.log(`âš¡ Synced viewer pearl animation: ${data.power}% (level ${tube.powerLevel})`);
  }
}

// 4. EXTRACT pearl animation logic into reusable functions
function updatePearlAnimation(tube, powerPercent, tubeIndex) {
  const spinSpeed = powerPercent * 0.3;
  const spinForce = powerPercent * 1200;
  const buoyancyForce = powerPercent * 800;
  
  tube.liquidParticles.forEach((particleBody, idx) => {
    particleBody.force.y += buoyancyForce;
    
    const dx = particleBody.position.x - tube.tube.position.x;
    const dz = particleBody.position.z;
    const distance = Math.sqrt(dx * dx + dz * dz);
    
    if (distance > 1) {
      const angle = Math.atan2(dz, dx);
      const tangentAngle = angle + Math.PI / 2;
      const orbitForceX = Math.cos(tangentAngle) * spinForce * (1 + idx * 0.05);
      const orbitForceZ = Math.sin(tangentAngle) * spinForce * (1 + idx * 0.05);
      
      particleBody.force.x += orbitForceX;
      particleBody.force.z += orbitForceZ;
    }
    
    const chaos = Math.sin(frameCount * 0.2 + idx) * 200 * powerPercent;
    particleBody.force.x += chaos;
    particleBody.force.z += Math.cos(frameCount * 0.2 + idx * 1.3) * 200 * powerPercent;
  });
}

function updatePearlColors(tube, powerPercent, tubeIndex) {
  const darkPearl = new THREE.Color(0x1a1a1a);
  
  // Tube-specific neon colors (your beautiful gradient system)
  const neonColors = [
    new THREE.Color(0x00ff00), // Tube 1: NEON GREEN
    new THREE.Color(0x00ddff), // Tube 2: NEON BLUE
    new THREE.Color(0xff0088), // Tube 3: NEON PINK
    new THREE.Color(0xffff00)  // Tube 4: NEON YELLOW
  ];
  
  const neonColor = neonColors[tubeIndex] || neonColors[0];
  const currentColor = darkPearl.clone().lerp(neonColor, powerPercent);
  
  tube.liquidParticleMeshes.forEach(particleMesh => {
    particleMesh.material.color.copy(currentColor);
    particleMesh.material.emissive.copy(currentColor);
    particleMesh.material.emissiveIntensity = 0.2 + (powerPercent * 25.0);
  });
  
  tube.liquidLight.color.copy(currentColor);
  tube.liquidLight.intensity = 0.3 + (powerPercent * 15.0);
}
```

---

## ğŸ“Š **Timing Analysis**

Current flow:
```
Player 1 clicks â†’ Animation starts â†’ Wait 167ms â†’ Server notified â†’ 
Server broadcasts â†’ Player 2 receives â†’ Starts 5-second cycle (wrong!)
Total delay: ~200-300ms + choppy animation
```

Proposed flow:
```
Player 1 clicks â†’ INSTANT server notify â†’ Server broadcasts â†’ 
Player 2 receives â†’ Animation starts simultaneously
Updates every 83ms (12/sec) for smooth sync
Total delay: ~16-50ms (network latency only)

ğŸ¨ What This Preserves
âœ… Your gorgeous pearl animations (unchanged)
âœ… Tube-specific neon colors (GREEN/BLUE/PINK/YELLOW)
âœ… Physics-based particle system
âœ… Power-based intensity scaling
âœ… Bloom effects on layer 1
ğŸ› What This Fixes
âœ… Instant start notification
âœ… 2x faster updates (5 frames vs 10 frames)
âœ… Real-time mirroring (no 5-second cycle)
âœ… No early returns in viewer updates
âœ… Unified animation code path

ğŸš€ Server-Side Requirements
You'll need to add this socket event handler:
javascript// server.js
socket.on('physics_power_charging_start', (data) => {
  // Broadcast immediately - no processing needed
  socket.to(`game_${data.gameId}`).emit('physics_power_charging', {
    ...data,
    power: 0,
    powerLevel: 1,
    isFilling: true
  });
});
Would you like me to provide the complete refactored code sections ready to drop in?RetryKyes pleaseğŸ® Complete Refactored Code - Pearl Animation Sync Fix
Here's the complete refactored code with all changes marked and explained. Copy-paste these sections to replace the corresponding parts in your HTML file.

ğŸ“¦ SECTION 1: Power Button Event Handlers (Lines ~2121-2250)
Replace the entire power button event handler section:
javascript// Add power charge button handler (HOLD TO CHARGE) - always add, visibility controlled by CSS
const flipButtons = cardElement.querySelectorAll('.action-btn');
const powerButton = flipButtons[1]; // The second action button
const powerBar = cardElement.querySelector('.power-bar');

if (powerButton) {
  const powerText = cardElement.querySelector('.power-text');
  powerButton.style.pointerEvents = 'auto';
  
  let isCharging = false;
  
  powerButton.addEventListener('mousedown', (e) => {
    e.stopPropagation();
    
    // Prevent charging if player has no lives
    if (players[i].lives <= 0) {
      console.log(`âŒ Player ${i + 1} has no lives - cannot flip coin`);
      return;
    }
    
    // Prevent charging if player hasn't chosen heads or tails
    if (!players[i].choice) {
      showChoiceRequiredMessage(i);
      console.log(`âŒ Player ${i + 1} must choose heads or tails first!`);
      return;
    }
    
    // Prevent charging if already used this round
    if (tubes[i].hasUsedPower) return;
    
    console.log(`âš¡ Charging power for tube ${i + 1}`);
    isCharging = true;
    tubes[i].isFilling = true;
    tubes[i].power = 0;
    tubes[i].chargingStartTime = Date.now(); // Track start time for sync
    
    // Play power charging sound
    playSound(powerChargeSound);
    
    // ğŸ¯ NEW: INSTANT BROADCAST - Tell everyone charging started
    if (isServerSideMode && socket && gameIdParam && walletParam) {
      socket.emit('physics_power_charging_start', {
        gameId: gameIdParam,
        address: walletParam,
        playerSlot: i
      });
      console.log(`ğŸ“¢ Broadcast: Player ${i + 1} started charging`);
    }
  });
  
  powerButton.addEventListener('mouseup', (e) => {
    e.stopPropagation();
    const finalPower = tubes[i].power;
    console.log(`âš¡ Power released at ${finalPower.toFixed(0)}%`);
    isCharging = false;
    tubes[i].isFilling = false;
    
    // Stop power charging sound
    stopSound(powerChargeSound);
    
    // ğŸ¯ NEW: INSTANT BROADCAST - Tell everyone charging stopped
    if (isServerSideMode && socket && gameIdParam && walletParam) {
      socket.emit('physics_power_charging_stop', {
        gameId: gameIdParam,
        address: walletParam,
        playerSlot: i,
        finalPower: finalPower
      });
      console.log(`ğŸ“¢ Broadcast: Player ${i + 1} stopped charging at ${finalPower}%`);
    }
    
    // Shatter glass and flip coin (minimum 5% power to prevent instant flips)
    if (finalPower >= 5) {
      // Server-side physics: Send flip request to server
      if (isServerSideMode && socket && gameIdParam && walletParam) {
        // Get player choice from the card
        const playerChoice = players[i].choice;
        
        // Send flip request to server (server will broadcast glass shatter to all)
        socket.emit('physics_flip_coin', {
          gameId: gameIdParam,
          address: walletParam,
          power: finalPower,
          angle: 0 // Default angle for now
        });
        
        console.log(`ğŸª™ Sent flip request to server: power=${finalPower}, choice=${playerChoice}`);
      } else {
        // Fallback to local physics (for testing)
        shatterGlass(i, finalPower);
        const playerChoice = players[i].choice;
        flipCoinWithPower(i, finalPower, playerChoice);
      }
      
      // Disable button after use
      powerButton.disabled = true;
      powerButton.style.opacity = '0.5';
      powerButton.style.cursor = 'not-allowed';
      powerButton.style.background = '#cccccc';
      powerButton.style.color = '#666666';
      powerButton.style.borderColor = '#999999';
      tubes[i].hasUsedPower = true;
    }
  });
  
  powerButton.addEventListener('mouseleave', (e) => {
    if (isCharging) {
      const finalPower = tubes[i].power;
      console.log(`âš¡ Power released at ${finalPower.toFixed(0)}%`);
      
      // Stop power charging sound
      stopSound(powerChargeSound);
      
      // ğŸ¯ NEW: INSTANT BROADCAST - Tell everyone charging stopped
      if (isServerSideMode && socket && gameIdParam && walletParam) {
        socket.emit('physics_power_charging_stop', {
          gameId: gameIdParam,
          address: walletParam,
          playerSlot: i,
          finalPower: finalPower
        });
        console.log(`ğŸ“¢ Broadcast: Player ${i + 1} stopped charging (mouseleave) at ${finalPower}%`);
      }
      
      // Shatter glass and flip coin (minimum 5% power)
      if (finalPower >= 5) {
        // Server-side physics: Send flip request to server
        if (isServerSideMode && socket && gameIdParam && walletParam) {
          // Get player choice from the card
          const playerChoice = players[i].choice;
          
          // Send flip request to server (server will broadcast glass shatter to all)
          socket.emit('physics_flip_coin', {
            gameId: gameIdParam,
            address: walletParam,
            power: finalPower,
            angle: 0 // Default angle for now
          });
          
          console.log(`ğŸª™ Sent flip request to server (mouseleave): power=${finalPower}, choice=${playerChoice}`);
        } else {
          // Fallback to local physics (for testing)
          shatterGlass(i, finalPower);
          const playerChoice = players[i].choice;
          flipCoinWithPower(i, finalPower, playerChoice);
        }
        
        // Disable button after use
        powerButton.disabled = true;
        powerButton.style.opacity = '0.5';
        powerButton.style.cursor = 'not-allowed';
        powerButton.style.background = '#cccccc';
        powerButton.style.color = '#666666';
        powerButton.style.borderColor = '#999999';
        tubes[i].hasUsedPower = true;
      }
    }
    isCharging = false;
    tubes[i].isFilling = false;
  });
  
  // Add choice button handlers (only for current player)
  const choiceButtons = cardElement.querySelectorAll('.choice-btn');
  choiceButtons.forEach(btn => {
    btn.style.pointerEvents = 'auto';
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Don't allow choices if player has no lives
      if (players[i].lives <= 0) {
        console.log(`âŒ Player ${i + 1} has no lives - cannot make choice`);
        return;
      }
      
      const choice = btn.textContent.toLowerCase();
      players[i].choice = choice;
      console.log(`Player ${i + 1} selected: ${choice}`);
      
      // Update coin rotation immediately
      updateCoinRotationsFromPlayerChoices();
      
      // Send choice to server
      if (isServerSideMode && socket && gameIdParam && walletParam) {
        socket.emit('physics_set_choice', {
          gameId: gameIdParam,
          address: walletParam,
          choice: choice
        });
        console.log(`ğŸ¯ Sent choice to server: ${choice}`);
      }
      
      // Replace buttons with choice badge
      const choiceButtonContainer = cardElement.querySelector('.choice-buttons');
      if (choiceButtonContainer) {
        choiceButtonContainer.outerHTML = `
          <div class="choice-badge ${choice}">
            ${choice.toUpperCase()}
          </div>
        `;
      }
    });
  });
}

ğŸ“¦ SECTION 2: Socket Event Handlers (Lines ~1140-1210)
Add these NEW socket event handlers right after the existing socket.on handlers (around line 1210):
javascript// ğŸ¯ NEW: Handle charging start event
socket.on('physics_power_charging_start', (data) => {
  console.log('âš¡ Received charging start:', data);
  if (data.playerSlot >= 0 && data.playerSlot < 4) {
    const tube = tubes[data.playerSlot];
    if (tube) {
      tube.isFilling = true;
      tube.power = 0;
      tube.chargingStartTime = Date.now();
      console.log(`ğŸŒŠ Started pearl animation for tube ${data.playerSlot + 1}`);
    }
  }
});

// ğŸ¯ NEW: Handle charging stop event
socket.on('physics_power_charging_stop', (data) => {
  console.log('âš¡ Received charging stop:', data);
  if (data.playerSlot >= 0 && data.playerSlot < 4) {
    const tube = tubes[data.playerSlot];
    if (tube) {
      tube.isFilling = false;
      tube.power = data.finalPower || tube.power;
      console.log(`ğŸ›‘ Stopped pearl animation for tube ${data.playerSlot + 1} at ${tube.power}%`);
    }
  }
});

ğŸ“¦ SECTION 3: Update Power Charging Visual Function (Lines ~1485-1585)
REPLACE THE ENTIRE FUNCTION with this refactored version:
javascript// ğŸ¯ REFACTORED: Update power charging visual - REAL-TIME for all players
function updatePowerChargingVisual(data) {
  if (data.playerSlot >= 0 && data.playerSlot < 4) {
    const tube = tubes[data.playerSlot];
    if (!tube) return;
    
    tube.power = data.power;
    tube.powerLevel = data.powerLevel || Math.min(5, Math.max(1, Math.ceil(data.power / 20)));
    tube.isFilling = data.isFilling;
    
    const powerPercent = tube.power / 100;
    tube.foamIntensity = powerPercent;
    
    console.log(`âš¡ Updated power visual for player ${data.playerSlot + 1}: ${data.power}% (level ${tube.powerLevel}, foamIntensity: ${tube.foamIntensity})`);
    
    // ğŸ¯ UNIFIED ANIMATION - Same code for charger and viewers!
    updatePearlColors(tube, powerPercent, data.playerSlot);
    
    // Debug: Check if pearls exist and are visible
    if (tube.liquidParticleMeshes && tube.liquidParticleMeshes.length > 0) {
      const visibleCount = tube.liquidParticleMeshes.filter(mesh => mesh.visible).length;
      console.log(`ğŸ” Tube ${data.playerSlot + 1} has ${tube.liquidParticleMeshes.length} pearls, ${visibleCount} visible`);
    }
  }
}

ğŸ“¦ SECTION 4: NEW Helper Functions (Add after updatePowerChargingVisual)
Add these NEW helper functions right after the updatePowerChargingVisual function:
javascript// ğŸ¯ NEW: Update pearl colors - Extracted for reusability
function updatePearlColors(tube, powerPercent, tubeIndex) {
  const darkPearl = new THREE.Color(0x1a1a1a); // Dark grey (neutral start)
  
  // Define neon colors for each tube
  const neonColors = [
    new THREE.Color(0x00ff00), // Tube 1: NEON GREEN
    new THREE.Color(0x00ddff), // Tube 2: NEON BLUE
    new THREE.Color(0xff0088), // Tube 3: NEON PINK
    new THREE.Color(0xffff00)  // Tube 4: NEON YELLOW
  ];
  
  const neonColor = neonColors[tubeIndex] || neonColors[0];
  const currentColor = darkPearl.clone().lerp(neonColor, powerPercent);
  
  // Update pearl colors with MAXIMUM NEON - ULTRA VIBRANT with bloom!
  tube.liquidParticleMeshes.forEach(particleMesh => {
    particleMesh.material.color.copy(currentColor);
    particleMesh.material.emissive.copy(currentColor);
    particleMesh.material.emissiveIntensity = 0.2 + (powerPercent * 25.0); // 0.2 to 25.2 - Perfect with bloom!
  });
  
  // Update liquid light to match pearl color
  tube.liquidLight.color.copy(currentColor);
  tube.liquidLight.intensity = 0.3 + (powerPercent * 15.0); // 0.3 to 15.3 - MEGA INTENSE!
}

// ğŸ¯ NEW: Update pearl physics - Extracted for reusability
function updatePearlPhysics(tube, powerPercent, tubeIndex, frameCount) {
  const spinSpeed = powerPercent * 0.3; // Rotation speed increases with power
  const spinForce = powerPercent * 1200; // Orbital force
  const buoyancyForce = powerPercent * 800; // Upward float force
  
  tube.liquidParticles.forEach((particleBody, idx) => {
    // BUOYANCY - Float upward!
    particleBody.force.y += buoyancyForce;
    
    // Calculate position relative to tube center
    const dx = particleBody.position.x - tube.tube.position.x;
    const dz = particleBody.position.z;
    const distance = Math.sqrt(dx * dx + dz * dz);
    
    if (distance > 1) {
      // Calculate tangential force (perpendicular to radius) for circular motion
      const angle = Math.atan2(dz, dx);
      const tangentAngle = angle + Math.PI / 2; // 90 degrees to create orbit
      
      // Apply circular orbital force - pearls spin around the walls!
      const orbitForceX = Math.cos(tangentAngle) * spinForce * (1 + idx * 0.05);
      const orbitForceZ = Math.sin(tangentAngle) * spinForce * (1 + idx * 0.05);
      
      particleBody.force.x += orbitForceX;
      particleBody.force.z += orbitForceZ;
    }
    
    // Add chaotic bouncing movement
    const chaos = Math.sin(frameCount * 0.2 + idx) * 200 * powerPercent;
    particleBody.force.x += chaos;
    particleBody.force.z += Math.cos(frameCount * 0.2 + idx * 1.3) * 200 * powerPercent;
  });
}

ğŸ“¦ SECTION 5: Animation Loop (Lines ~2850-2950)
REPLACE the power charging section in the animate loop:
javascript// Animation loop with physics
let frameCount = 0;
const timeStep = 1 / 60; // 60 FPS

function animate() {
  frameCount++;

  // Step physics simulation
  physicsWorld.step(timeStep);

  tubes.forEach((tube, i) => {
    const offset = i * 0.4;
    
    // ğŸ¯ REFACTORED: POWER CHARGING SYSTEM - REAL-TIME SYNC
    if (tube.isFilling && !tube.isShattered) {
      // Increase power (0-100 over ~3 seconds)
      tube.power = Math.min(tube.power + 0.6, 100);
      const powerPercent = tube.power / 100;
      
      // Update foam intensity
      tube.foamIntensity = powerPercent;
      
      // Calculate power level (1-5) based on power percentage
      const powerLevel = Math.min(5, Math.max(1, Math.ceil(tube.power / 20)));
      
      // ğŸ¯ FASTER BROADCAST - Every 5 frames = 12 updates/second (was 10 frames = 6/sec)
      if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === i) {
        if (frameCount % 5 === 0) { // Changed from 10 to 5
          socket.emit('physics_power_charging', {
            gameId: gameIdParam,
            address: walletParam,
            power: tube.power,
            powerLevel: powerLevel,
            playerSlot: i,
            isFilling: tube.isFilling
          });
          // Removed console.log to reduce spam - only log on start/stop
        }
      }
      
      // Update UI elements
      if (tube.cardElement) {
        const powerBar = tube.cardElement.querySelector('.power-bar');
        const powerText = tube.cardElement.querySelector('.power-text');
        if (powerBar) powerBar.style.width = `${tube.power}%`;
        if (powerText) powerText.textContent = `POWER: ${tube.power.toFixed(0)}%`;
        
        // Change bar color as it charges (pink theme)
        if (tube.power > 75) {
          powerBar.style.background = 'linear-gradient(90deg, #ff1493, #ff69b4)';
        } else if (tube.power > 50) {
          powerBar.style.background = 'linear-gradient(90deg, #ff69b4, #ffb6c1)';
        }
      }
      
      // ğŸ¯ UNIFIED PEARL COLOR UPDATE - Same for local and remote
      updatePearlColors(tube, powerPercent, i);
    }
    
    // ğŸ¯ UNIFIED PEARL PHYSICS - Runs for BOTH local charging AND remote viewing
    if ((tube.isFilling || tube.foamIntensity > 0) && !tube.isShattered) {
      updatePearlPhysics(tube, tube.foamIntensity, i, frameCount);
    }
    
    // Sync particle visual meshes with physics bodies
    tube.liquidParticles.forEach((particleBody, idx) => {
      tube.liquidParticleMeshes[idx].position.copy(particleBody.position);
      tube.liquidParticleMeshes[idx].quaternion.copy(particleBody.quaternion);
    });
    
    // Pulsing light during charging
    if (tube.foamIntensity > 0) {
      const lightPulse = Math.sin(frameCount * 0.15 + offset) * 0.5;
      tube.liquidLight.intensity = tube.liquidLight.intensity + lightPulse * tube.foamIntensity;
    }
  });

  // ... rest of animate function continues unchanged ...

ğŸ“¦ SECTION 6: REMOVE Old Viewer Cycle Function (Lines ~1540-1585)
DELETE the entire startViewerPearlCycle function. It's no longer needed! Just remove this entire block:
javascript// âŒ DELETE THIS ENTIRE FUNCTION
function startViewerPearlCycle(tubeIndex, powerLevel) {
  // ... entire function body ...
}

ğŸ–¥ï¸ SECTION 7: Server-Side Changes (server.js or your Node.js backend)
Add these socket event handlers to your server code:
javascript// ğŸ¯ NEW: Handle power charging start
socket.on('physics_power_charging_start', (data) => {
  console.log(`âš¡ Player ${data.playerSlot + 1} started charging in game ${data.gameId}`);
  
  // Broadcast to all OTHER players in the room
  socket.to(`game_${data.gameId}`).emit('physics_power_charging_start', {
    playerSlot: data.playerSlot,
    address: data.address
  });
});

// ğŸ¯ NEW: Handle power charging stop
socket.on('physics_power_charging_stop', (data) => {
  console.log(`âš¡ Player ${data.playerSlot + 1} stopped charging at ${data.finalPower}% in game ${data.gameId}`);
  
  // Broadcast to all OTHER players in the room
  socket.to(`game_${data.gameId}`).emit('physics_power_charging_stop', {
    playerSlot: data.playerSlot,
    address: data.address,
    finalPower: data.finalPower
  });
});

// Keep your existing physics_power_charging handler for incremental updates
socket.on('physics_power_charging', (data) => {
  // Broadcast to all OTHER players in the room
  socket.to(`game_${data.gameId}`).emit('physics_power_charging', {
    playerSlot: data.playerSlot,
    power: data.power,
    powerLevel: data.powerLevel,
    isFilling: data.isFilling
  });
});

ğŸ“Š What Changed - Summary
Timing Improvements
BeforeAfterUpdate every 167ms (10 frames)Update every 83ms (5 frames)No start notificationInstant start broadcast5-second viewer cycleReal-time mirroring~300ms initial delay~16-50ms network latency only
Code Structure

âœ… Extracted updatePearlColors() - reusable color logic
âœ… Extracted updatePearlPhysics() - reusable physics logic
âœ… Removed startViewerPearlCycle() - no longer needed
âœ… Unified animation code path - same for all players
âœ… Added start/stop events - instant sync

What's Preserved

âœ… All visual effects (colors, bloom, intensity)
âœ… Physics-based particle system
âœ… Tube-specific neon colors
âœ… Power scaling (0-100%)
âœ… UI synchronization


ğŸ§ª Testing Checklist

Start server with new socket handlers
Open 2 browser tabs (different players)
Player 1: Click and hold "CHARGE POWER"
Player 2 should see:

âœ… Pearls start glowing immediately
âœ… Smooth color transition
âœ… Physics animation (spinning, floating)
âœ… Matching power level


Player 1: Release button
Player 2 should see:

âœ… Animation stops immediately
âœ… Pearls fade back to neutral




ğŸ› Debugging Tips
If pearls still don't show for viewers, check console logs:
javascript// You should see these messages in Player 2's console:
"âš¡ Received charging start: {playerSlot: 0, address: '0x...'}"
"ğŸŒŠ Started pearl animation for tube 1"
"âš¡ Updated power visual for player 1: 25% (level 2, foamIntensity: 0.25)"
"ğŸ” Tube 1 has 80 pearls, 80 visible"
If you DON'T see these messages, the issue is server-side broadcasting.
Let me know if you need any clarification or run into issues!RetryClaude can make mistakes. Please double-check responses.flip sat 1 Sonnet 4.5