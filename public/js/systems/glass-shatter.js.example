/**
 * Glass Shattering System
 * Handles glass tube shattering effects and shard physics
 * 
 * This is an EXAMPLE showing how the module would be structured
 * It's based on the shatterGlass function from test-tubes.html
 */

// Import dependencies
import * as THREE from 'three';
import * as Config from '../config.js';

/**
 * Shatter a glass tube with physics-based shards
 * 
 * @param {number} tubeIndex - Index of the tube to shatter
 * @param {number} powerLevel - Power level (0-100) affecting shard count/speed
 * @param {Array} tubes - Array of tube objects
 * @param {Object} scene - Three.js scene to add shards to
 * @param {Object} physicsWorld - CANNON.js physics world
 * @param {Function} playSound - Sound playback function
 * @param {Function} stopSound - Sound stop function
 * @param {Object} glassBreakSound - Audio object for glass breaking
 * @param {Object} powerChargeSound - Audio object for power charging
 */
export function shatterGlass(
  tubeIndex, 
  powerLevel, 
  tubes, 
  scene, 
  physicsWorld,
  playSound,
  stopSound,
  glassBreakSound,
  powerChargeSound
) {
  const tube = tubes[tubeIndex];
  if (!tube || tube.isShattered) return;
  
  const powerPercent = powerLevel / 100;
  console.log(`ðŸ’¥ Shattering glass for tube ${tubeIndex + 1} at ${powerLevel.toFixed(0)}% power`);
  
  // Stop charging sound, play break sound
  stopSound(powerChargeSound);
  playSound(glassBreakSound);
  
  // Mark tube as shattered
  tube.isShattered = true;
  
  // Hide glass components
  tube.tube.visible = false;
  tube.backing.visible = false;
  tube.topRim.visible = false;
  tube.bottomRim.visible = false;
  tube.liquid.visible = false;
  tube.coinShadow.visible = true;
  
  // Remove physics body
  physicsWorld.removeBody(tube.glassBody);
  
  // Create glass shards
  const shardCount = Math.floor(20 + (powerPercent * 60));
  const tubeY = Config.TUBE_Y_POSITION;
  
  // Initialize shards array if needed
  if (!tube.glassShards) {
    tube.glassShards = [];
  }
  
  for (let s = 0; s < shardCount; s++) {
    const size = Math.random() * 12 + 5;
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      0, 0, 0,
      size, 0, 0,
      size * 0.5, size, 0
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    
    const material = new THREE.MeshStandardMaterial({
      color: 0xe0e0e0,
      metalness: 0.95,
      roughness: 0.1,
      emissive: 0xc0c0c0,
      emissiveIntensity: 0.4,
      side: THREE.DoubleSide
    });
    
    const shard = new THREE.Mesh(geometry, material);
    
    const angle = (s / shardCount) * Math.PI * 2;
    const heightPos = (Math.random() - 0.5) * Config.TUBE_HEIGHT;
    shard.position.set(
      tube.tube.position.x + Math.cos(angle) * Config.TUBE_RADIUS,
      tubeY + heightPos,
      Math.sin(angle) * Config.TUBE_RADIUS
    );
    
    shard.rotation.set(
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2
    );
    
    const baseSpeed = 2 + (powerPercent * 12);
    const velocity = {
      x: Math.cos(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5),
      y: Math.random() * 3 - 1.5,
      z: Math.sin(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5)
    };
    
    const rotVelocity = {
      x: (Math.random() - 0.5) * 0.3,
      y: (Math.random() - 0.5) * 0.3,
      z: (Math.random() - 0.5) * 0.3
    };
    
    scene.add(shard);
    
    tube.glassShards.push({
      mesh: shard,
      velocity,
      rotVelocity,
      lifetime: 0
    });
  }
  
  // Explode liquid particles (pearls)
  if (tube.liquidParticles) {
    tube.liquidParticles.forEach((particleBody, idx) => {
      const dx = particleBody.position.x - tube.tube.position.x;
      const dz = particleBody.position.z - tube.tube.position.z;
      const distance = Math.sqrt(dx * dx + dz * dz) || 1;
      
      const baseForce = 2000 + (powerPercent * 16000);
      const explosionForce = baseForce + Math.random() * (baseForce * 0.3);
      
      particleBody.velocity.set(
        (dx / distance) * explosionForce,
        Math.random() * 800 - 400,
        (dz / distance) * explosionForce
      );
      
      const spinForce = 15 * powerPercent;
      particleBody.angularVelocity.set(
        Math.random() * spinForce * 2 - spinForce,
        Math.random() * spinForce * 2 - spinForce,
        Math.random() * spinForce * 2 - spinForce
      );
    });
  }
}

/**
 * Update glass shard animations in the render loop
 * 
 * @param {Array} tubes - Array of tube objects
 * @param {number} deltaTime - Time since last frame
 */
export function updateGlassShards(tubes, deltaTime) {
  tubes.forEach(tube => {
    if (tube.glassShards && tube.glassShards.length > 0) {
      tube.glassShards = tube.glassShards.filter(shard => {
        shard.lifetime += deltaTime;
        
        // Update position
        shard.mesh.position.x += shard.velocity.x * deltaTime;
        shard.mesh.position.y += shard.velocity.y * deltaTime;
        shard.mesh.position.z += shard.velocity.z * deltaTime;
        
        // Update rotation
        shard.mesh.rotation.x += shard.rotVelocity.x * deltaTime;
        shard.mesh.rotation.y += shard.rotVelocity.y * deltaTime;
        shard.mesh.rotation.z += shard.rotVelocity.z * deltaTime;
        
        // Apply gravity
        shard.velocity.y -= 980 * deltaTime; // Gravity
        
        // Remove shards after 3 seconds
        if (shard.lifetime > 3) {
          // Remove from scene and clean up
          shard.mesh.geometry.dispose();
          shard.mesh.material.dispose();
          return false; // Filter out
        }
        
        return true; // Keep shard
      });
    }
  });
}

// Example of how to use this module:
/*
import { shatterGlass, updateGlassShards } from './systems/glass-shatter.js';

// In your game code:
shatterGlass(
  tubeIndex,
  powerLevel,
  tubes,
  scene,
  physicsWorld,
  playSound,
  stopSound,
  glassBreakSound,
  powerChargeSound
);

// In animation loop:
updateGlassShards(tubes, deltaTime);
*/

