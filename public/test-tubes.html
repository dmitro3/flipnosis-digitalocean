<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glass Tube Game Test</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }
    
    body {
      font-family: 'Orbitron', sans-serif;
      background: url('/Images/Background/game room2.png') no-repeat center center fixed;
      background-size: cover;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }

    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: auto; /* Enable interactions for CSS3D/UI elements */
    }
    
    #container canvas {
      pointer-events: auto; /* Re-enable clicks on the canvas */
    }

    /* Player Card Styling */
    .player-card {
      width: 320px;
      background: rgba(10, 15, 35, 0.95);
      border: 3px solid #00ffff;
      border-radius: 16px;
      padding: 15px 20px;
      font-family: 'Orbitron', sans-serif;
      color: white;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
      pointer-events: auto;
      position: relative;
    }

    .card-header {
      margin-bottom: 15px;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .player-avatar {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      object-fit: cover;
      border: 2px solid #00ffff;
      flex-shrink: 0;
    }

    .player-info {
      flex: 1;
      text-align: right;
    }

    .player-name {
      font-size: 22px;
      font-weight: bold;
      color: #00ffff;
      margin-bottom: 5px;
    }

    .player-address {
      font-size: 16px;
      color: #ffffff;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
    }

    .lives-container {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin: 15px 0;
    }

    .life {
      opacity: 0.3;
      filter: grayscale(100%) brightness(0.5);
      transition: all 0.3s ease;
    }

    .life.active {
      opacity: 1;
      filter: grayscale(0%) brightness(1);
      animation: heartbeat 2s ease-in-out infinite;
    }

    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .choice-badge {
      padding: 12px;
      margin: 15px 0;
      border-radius: 8px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .choice-badge.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      border: 2px solid #00ff00;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-badge.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      border: 2px solid #00d4ff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-buttons {
      display: flex;
      gap: 10px;
      margin: 15px 0;
    }

    .choice-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      pointer-events: auto;
    }

    .choice-btn.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-btn.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-btn:hover {
      transform: translateY(-3px);
      filter: brightness(1.2);
    }
    
    .choice-btn.heads:hover {
      box-shadow: 0 5px 20px rgba(0, 255, 0, 0.8);
    }
    
    .choice-btn.tails:hover {
      box-shadow: 0 5px 20px rgba(0, 212, 255, 0.8);
    }

    .action-btn {
      width: 100%;
      padding: 15px;
      background: white;
      border: 2px solid #ff1493;
      border-radius: 8px;
      color: #ff1493;
      font-weight: bold;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-top: 10px;
      pointer-events: auto;
    }

    .action-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 20, 147, 0.3);
      background: #ffe6f2;
    }

    .action-btn:active {
      transform: translateY(0);
    }

    /* Pulse animation for eliminated players */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    #info {
      display: none; /* Hidden */
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="info">
    ðŸŽ® Glass Tube Game Test<br>
    Loading Three.js...
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
      }
    }
  </script>
  
  <!-- Socket.io for server-side physics -->
  <script src="/socket.io/socket.io.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import * as CANNON from 'cannon-es';

    const info = document.getElementById('info');

    // ===== URL PARAMS =====
    const urlParams = new URLSearchParams(window.location.search);
    const gameIdParam = urlParams.get('gameId') || '';
    const roleParam = urlParams.get('role') || 'player';
    const userNameParam = urlParams.get('username') || '';
    let walletParam = urlParams.get('address') || '';
    const avatarParam = urlParams.get('avatar') || '';
    const tokenParam = urlParams.get('token') || '';
    
    // Fallback: Try to get wallet from localStorage if not in URL (for React redirects)
    if (!walletParam) {
      walletParam = localStorage.getItem('walletAddress') || '';
      console.log('ðŸ” No wallet in URL, trying localStorage:', walletParam);
      
      // Additional fallback: try to get from window.ethereum
      if (!walletParam && window.ethereum?.selectedAddress) {
        walletParam = window.ethereum.selectedAddress;
        console.log('ðŸ” Got wallet from window.ethereum:', walletParam);
      }
      
      // Debug: show all available wallet sources
      console.log('ðŸ” Wallet detection debug:', {
        urlParam: urlParams.get('address'),
        localStorage: localStorage.getItem('walletAddress'),
        ethereum: window.ethereum?.selectedAddress,
        final: walletParam
      });
    }

    if (gameIdParam) {
      document.title = `Glass Tube Game â€¢ ${gameIdParam}`;
    }
    info.textContent = 'ðŸŽ® Initializing 4-Player Glass Tube Game...';

    // ===== SOCKET.IO CONNECTION =====
    let socket = null;
    let gameState = null;
    let playerSlot = -1;
    let isServerSideMode = true; // Enable server-side physics
    
    // Initialize socket connection
    function initializeSocket() {
      if (typeof io === 'undefined') {
        console.error('âŒ Socket.io not loaded');
        return;
      }
      
      socket = io();
      
      socket.on('connect', () => {
        console.log('âœ… Connected to server');
        
        // Join physics room
        if (gameIdParam && walletParam) {
          socket.emit('physics_join_room', {
            roomId: `game_${gameIdParam}`,
            address: walletParam
          });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('âŒ Disconnected from server');
      });
      
      // Handle reconnection
      socket.on('reconnect', () => {
        console.log('ðŸ”„ Reconnecting to server...');
        
        // Rejoin the game room with saved state
        if (gameIdParam && walletParam) {
          socket.emit('physics_rejoin_room', {
            roomId: `game_${gameIdParam}`,
            address: walletParam,
            lastKnownSlot: playerSlot
          });
        }
      });

      socket.on('game_state_restored', (data) => {
        console.log('âœ… Game state restored:', data);
        
        // Restore player choices
        if (data.playerChoices) {
          Object.keys(data.playerChoices).forEach(slot => {
            const slotIndex = parseInt(slot);
            if (players[slotIndex]) {
              players[slotIndex].choice = data.playerChoices[slot];
              updatePlayerCardChoice(slotIndex, data.playerChoices[slot]);
            }
          });
        }
        
        // Restore coin selections
        if (data.coinSelections) {
          data.coinSelections.forEach((selection, index) => {
            if (selection && tubes[index]) {
              tubes[index].selectedCoin = coinOptions.find(c => c.id === selection.coinId) || coinOptions[0];
              tubes[index].selectedMaterial = coinMaterials.find(m => m.id === selection.materialId) || coinMaterials[0];
              // Apply the coin textures
              applyCoinSelection(index, tubes[index].selectedCoin, tubes[index].selectedMaterial);
            }
          });
        }
        
        // Restore game phase
        if (data.phase) {
          gameState = { ...gameState, phase: data.phase };
          if (data.phase === 'game_over') {
            gameOver = true;
            handleGameEnd(data);
          }
        }
      });
      
      // Server-side physics events
      socket.on('physics_state_update', (state) => {
        console.log('ðŸ“Š Received physics state update:', state);
        gameState = state;
        updateClientFromServerState(state);
      });
      
      socket.on('physics_coin_flip_start', (data) => {
        console.log('ðŸª™ Coin flip started:', data);
        startClientCoinFlipAnimation(data);
      });
      
      socket.on('physics_coin_result', (data) => {
        console.log('ðŸŽ² Coin flip result:', data);
        showCoinFlipResult(data);
      });
      
      socket.on('physics_power_charging', (data) => {
        console.log('âš¡ Power charging:', data);
        updatePowerChargingVisual(data);
      });
      
      // ðŸŽ¯ NEW: Handle charging start event
      socket.on('physics_power_charging_start', (data) => {
        console.log('âš¡ Received charging start:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = true;
            tube.power = 0;
            tube.chargingStartTime = Date.now();
            console.log(`ðŸŒŠ Started pearl animation for tube ${data.playerSlot + 1}`);
          }
        }
      });

      // ðŸŽ¯ NEW: Handle charging stop event
      socket.on('physics_power_charging_stop', (data) => {
        console.log('âš¡ Received charging stop:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = false;
            tube.power = data.finalPower || tube.power;
            console.log(`ðŸ›‘ Stopped pearl animation for tube ${data.playerSlot + 1} at ${tube.power}%`);
          }
        }
      });
      
      socket.on('physics_coin_angle_update', (data) => {
        console.log('ðŸŽ¯ Coin angle update:', data);
        updateCoinAngleVisual(data);
      });
      
      // Handle FLIP token award confirmation
      socket.on('flip_tokens_awarded', (data) => {
        console.log('ðŸ’° FLIP tokens awarded:', data);
        if (data.success) {
          // Show floating message instead of immediate XP update
          showFloatingMessage(`+${data.amount} FLIP earned!`, '#FFD700', 3000);
        } else {
          console.error('âŒ Failed to award FLIP tokens:', data.error);
        }
      });

      // Handle collection session creation
      socket.on('flip_collection_created', (data) => {
        console.log('ðŸŽ FLIP collection created:', data);
        if (data.success && data.collectionId) {
          currentCollectionId = data.collectionId;
          // Collection UI is already shown in showGameOverScreen
          showFloatingMessage('Collection session created!', '#00ff00', 2000);
        }
      });

      // Handle FLIP collection confirmation
      socket.on('flip_tokens_collected', (data) => {
        console.log('ðŸ’Ž FLIP tokens collected:', data);
        if (data.success) {
          const claimBtn = document.getElementById('claim-flip-btn');
          if (claimBtn) {
            claimBtn.textContent = `âœ… Claimed ${data.amount} FLIP!`;
            claimBtn.style.background = 'linear-gradient(135deg, #888, #666)';
            claimBtn.disabled = true;
          }
          showFloatingMessage(`Successfully claimed ${data.amount} FLIP!`, '#00ff00', 3000);
        }
      });

      // Handle NFT claim confirmation
      socket.on('nft_prize_claimed', (data) => {
        console.log('ðŸ† NFT prize claimed:', data);
        if (data.success) {
          const nftBtn = document.getElementById('claim-nft-btn');
          if (nftBtn) {
            nftBtn.textContent = 'âœ… NFT Claimed!';
            nftBtn.style.background = 'linear-gradient(135deg, #888, #666)';
            nftBtn.disabled = true;
          }
          showFloatingMessage('NFT successfully transferred to your wallet!', '#FFD700', 3000);
        }
      });
      
      socket.on('physics_error', (error) => {
        console.error('âŒ Physics error:', error);
        alert(`Game Error: ${error.message}`);
      });
      
      // Listen for player choice updates from server
      socket.on('player_choice_update', (data) => {
        console.log('ðŸŽ¯ Player choice update:', data);
        updatePlayerChoice(data);
      });
      
      // Listen for coin updates from server
      socket.on('coin_update', (data) => {
        console.log('ðŸª™ Coin update received:', data);
        updateCoinFromServer(data);
      });
      
      // Listen for player flip actions from server
      socket.on('player_flip_action', (data) => {
        console.log('ðŸŽ° Player flip action:', data);
        // This will be handled by physics_coin_flip_start event
      });
      
      // Listen for glass shatter events
      socket.on('glass_shatter', (data) => {
        console.log('ðŸ’¥ Glass shatter:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          shatterGlass(data.playerSlot, data.power);
        }
      });
    }
    
    // Update client state from server
    function updateClientFromServerState(state) {
      if (!state) return;
      
      // Update game phase
      if (state.phase === 'round_active') {
        startTimer();
      } else if (state.phase === 'game_over') {
        stopTimer();
        gameOver = true;
        
        // Handle server-side game end
        if (state.winner) {
          // Find winner index
          const winnerIndex = players.findIndex(p => p.address && p.address.toLowerCase() === state.winner.toLowerCase());
          if (winnerIndex >= 0) {
            console.log(`ðŸ† Server declared winner: ${players[winnerIndex].name}`);
            showGameOverScreen(winnerIndex, players[winnerIndex].name);
          } else {
            console.log(`ðŸ† Server declared winner but couldn't find player: ${state.winner}`);
            showGameOverScreen(-1, state.winner);
          }
        } else {
          console.log(`ðŸ† Server declared game over with no winner`);
          showGameOverScreen(-1, null);
        }
      }
      
      // Update player data
      if (state.players && walletParam) {
        const normalizedAddress = walletParam.toLowerCase();
        const player = state.players[normalizedAddress];
        if (player) {
          const oldPlayerSlot = playerSlot;
          playerSlot = player.slotNumber;
          console.log(`ðŸŽ® Player slot: ${playerSlot}`);
          
          // Mark this as the current player's tube
          if (playerSlot >= 0 && playerSlot < 4) {
            tubes[playerSlot].isCurrentPlayer = true;
            players[playerSlot].isCurrentPlayer = true;
          }
          
          // Update button visibility for all player cards
          updatePlayerCardButtons();
        }
        
        // Sync all player choices from server state
        Object.keys(state.players).forEach(address => {
          const serverPlayer = state.players[address];
          if (serverPlayer && serverPlayer.slotNumber >= 0 && serverPlayer.slotNumber < 4) {
            const localPlayer = players[serverPlayer.slotNumber];
            if (localPlayer && !localPlayer.isEmpty) {
              // Update choice if it changed
              if (serverPlayer.choice && localPlayer.choice !== serverPlayer.choice) {
                console.log(`ðŸ”„ Syncing player ${serverPlayer.slotNumber + 1} choice: ${serverPlayer.choice}`);
                localPlayer.choice = serverPlayer.choice;
                
                // Update UI for this player
                const tube = tubes[serverPlayer.slotNumber];
                if (tube && tube.cardElement) {
                  const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
                  const choiceBadge = tube.cardElement.querySelector('.choice-badge');
                  
                  if (choiceButtons && choiceBadge) {
                    choiceButtons.style.display = 'none';
                    choiceBadge.style.display = 'inline-block';
                    choiceBadge.textContent = serverPlayer.choice.toUpperCase();
                    choiceBadge.className = `choice-badge ${serverPlayer.choice}`;
                  }
                }
              }
              
              // Update lives if changed
              if (serverPlayer.lives !== undefined && localPlayer.lives !== serverPlayer.lives) {
                localPlayer.lives = serverPlayer.lives;
                updateLivesDisplay(serverPlayer.slotNumber);
              }
            }
          }
        });
      }
      
      // Update timer
      if (state.roundTimer !== undefined) {
        timeRemaining = state.roundTimer;
        updateTimerDisplay();
      }
      
      // Update round
      if (state.currentRound !== undefined) {
        currentRound = state.currentRound;
        updateRoundDisplay();
      }
      
      // Update coin states from server physics
      if (state.coinStates) {
        updateCoinStatesFromServer(state.coinStates);
      }
      
      // Update coin rotations based on player choices (before flipping)
      updateCoinRotationsFromPlayerChoices();
    }
    
    // Update coin rotations based on player choices (before flipping)
    function updateCoinRotationsFromPlayerChoices() {
      tubes.forEach((tube, i) => {
        const player = players[i];
        const coin = coins[i];
        
        if (coin && !tube.isFlipping && !tube.isShattered) {
          if (player && !player.isEmpty) {
            // Only update rotation if player has made a choice and coin is not flipping
            if (player.choice === 'heads') {
              // Show heads face (standing on edge, heads facing camera)
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            } else if (player.choice === 'tails') {
              // Show tails face (standing on edge, tails facing camera)
              coin.rotation.x = 3 * Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            } else {
              // If no choice made, default to standing on edge (heads position)
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            }
          } else {
            // For empty players, ensure coin is in default upright position (not sideways)
            coin.rotation.x = Math.PI / 2;
            coin.rotation.y = Math.PI / 2;
            coin.rotation.z = 0;
          }
        }
      });
    }
    
    // Update coin states from server physics
    function updateCoinStatesFromServer(coinStates) {
      coinStates.forEach((coinState, index) => {
        if (coinState && coinState.position) {
          const coin = coins[index];
          const tube = tubes[index];
          if (coin && tube) {
            // ONLY update from server if we're NOT currently flipping locally
            // Local flip animations take priority to prevent jittery visuals
            if (!tube.isFlipping) {
              // Update coin position from server, but ensure it stays within the correct tube
              const tubeX = tube.tube.position.x;
              coin.position.set(tubeX, coinState.position.y, coinState.position.z);
              
              // Update coin rotation from server, but preserve choice-based rotation when not flipping
              if (coinState.rotation && coinState.isFlipping) {
                // Only update rotation from server if the coin is actually flipping
                coin.quaternion.set(
                  coinState.rotation.x,
                  coinState.rotation.y,
                  coinState.rotation.z,
                  coinState.rotation.w
                );
              } else {
                // When not flipping, ensure coin maintains proper choice-based rotation
                updateCoinRotationsFromPlayerChoices();
              }
            }
            
            // Update flip state
            if (coinState.isFlipping) {
              tubes[index].isFlipping = true;
            } else {
              tubes[index].isFlipping = false;
            }
          }
        }
      });
    }
    
    // Start client coin flip animation (visual only)
    function startClientCoinFlipAnimation(data) {
      console.log('ðŸŽ Received flip reward data:', data.flipReward);
      console.log('ðŸŽ Full data object:', data);
      
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        
        if (tube && coin) {
          tube.isFlipping = true;
          
          // Start visual animation based on server data
          animateCoinFlip(data.playerSlot, data.power, data.duration);
          
          // âœ… Show FLIP reward for everyone to see (more fun!)
          showFlipReward(data.playerSlot, data.flipReward);
        }
      }
    }
    
    // Show coin flip result
    function showCoinFlipResult(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        
        if (tube && coin) {
          tube.isFlipping = false;
          
          // Lock coin to final rotation based on result
          const targetRotationX = data.result === 'heads' ? Math.PI / 2 : (3 * Math.PI / 2);
          const finalCycles = Math.floor(coin.rotation.x / (Math.PI * 2));
          coin.rotation.x = finalCycles * (Math.PI * 2) + targetRotationX;
          coin.rotation.y = Math.PI / 2;
          coin.rotation.z = 0;
          
          console.log(`âœ… Coin ${data.playerSlot + 1} landed on ${data.result} facing camera (server-side)`);
          
          // Show result
          showResult(data.playerSlot, data.won, data.result);
          
          // Update lives if it's our player
          if (data.playerAddress.toLowerCase() === walletParam.toLowerCase()) {
            updateLivesDisplay(data.playerSlot);
          }
        }
      }
    }
    
    // ðŸŽ¯ REFACTORED: Update power charging visual - REAL-TIME for all players
    function updatePowerChargingVisual(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        if (!tube) return;
        
        tube.power = data.power;
        tube.powerLevel = data.powerLevel || Math.min(5, Math.max(1, Math.ceil(data.power / 20)));
        tube.isFilling = data.isFilling;
        
        const powerPercent = tube.power / 100;
        tube.foamIntensity = powerPercent;
        
        console.log(`âš¡ Updated power visual for player ${data.playerSlot + 1}: ${data.power}% (level ${tube.powerLevel}, foamIntensity: ${tube.foamIntensity})`);
        
        // ðŸŽ¯ UNIFIED ANIMATION - Same code for charger and viewers!
        updatePearlColors(tube, powerPercent, data.playerSlot);
        
        // Debug: Check if pearls exist and are visible
        if (tube.liquidParticleMeshes && tube.liquidParticleMeshes.length > 0) {
          const visibleCount = tube.liquidParticleMeshes.filter(mesh => mesh.visible).length;
          console.log(`ðŸ” Tube ${data.playerSlot + 1} has ${tube.liquidParticleMeshes.length} pearls, ${visibleCount} visible`);
        }
      }
    }
    
    // ðŸŽ¯ NEW: Update pearl colors - Extracted for reusability
    function updatePearlColors(tube, powerPercent, tubeIndex) {
      const darkPearl = new THREE.Color(0x1a1a1a); // Dark grey (neutral start)
      
      // Define neon colors for each tube
      const neonColors = [
        new THREE.Color(0x00ff00), // Tube 1: NEON GREEN
        new THREE.Color(0x00ddff), // Tube 2: NEON BLUE
        new THREE.Color(0xff0088), // Tube 3: NEON PINK
        new THREE.Color(0xffff00)  // Tube 4: NEON YELLOW
      ];
      
      const neonColor = neonColors[tubeIndex] || neonColors[0];
      const currentColor = darkPearl.clone().lerp(neonColor, powerPercent);
      
      // Update pearl colors with MAXIMUM NEON - ULTRA VIBRANT with bloom!
      tube.liquidParticleMeshes.forEach(particleMesh => {
        particleMesh.material.color.copy(currentColor);
        particleMesh.material.emissive.copy(currentColor);
        particleMesh.material.emissiveIntensity = 0.2 + (powerPercent * 25.0); // 0.2 to 25.2 - Perfect with bloom!
      });
      
      // Update liquid light to match pearl color
      tube.liquidLight.color.copy(currentColor);
      tube.liquidLight.intensity = 0.3 + (powerPercent * 15.0); // 0.3 to 15.3 - MEGA INTENSE!
    }

    // ðŸŽ¯ NEW: Update pearl physics - Extracted for reusability
    function updatePearlPhysics(tube, powerPercent, tubeIndex, frameCount) {
      const spinSpeed = powerPercent * 0.3; // Rotation speed increases with power
      const spinForce = powerPercent * 1200; // Orbital force
      const buoyancyForce = powerPercent * 800; // Upward float force
      
      tube.liquidParticles.forEach((particleBody, idx) => {
        // BUOYANCY - Float upward!
        particleBody.force.y += buoyancyForce;
        
        // Calculate position relative to tube center
        const dx = particleBody.position.x - tube.tube.position.x;
        const dz = particleBody.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 1) {
          // Calculate tangential force (perpendicular to radius) for circular motion
          const angle = Math.atan2(dz, dx);
          const tangentAngle = angle + Math.PI / 2; // 90 degrees to create orbit
          
          // Apply circular orbital force - pearls spin around the walls!
          const orbitForceX = Math.cos(tangentAngle) * spinForce * (1 + idx * 0.05);
          const orbitForceZ = Math.sin(tangentAngle) * spinForce * (1 + idx * 0.05);
          
          particleBody.force.x += orbitForceX;
          particleBody.force.z += orbitForceZ;
        }
        
        // Add chaotic bouncing movement
        const chaos = Math.sin(frameCount * 0.2 + idx) * 200 * powerPercent;
        particleBody.force.x += chaos;
        particleBody.force.z += Math.cos(frameCount * 0.2 + idx * 1.3) * 200 * powerPercent;
      });
    }
    
    
    // Update coin from server
    function updateCoinFromServer(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        const player = players[data.playerSlot];
        
        if (tube && coin && player && data.coinData) {
          console.log(`ðŸª™ Updating coin for player ${data.playerSlot + 1}: ${data.coinData.name}`);
          
          // Update stored selections
          tube.selectedCoin = data.coinData;
          tube.selectedMaterial = coinMaterials.find(m => m.id === data.coinData.material) || coinMaterials[0];
          
          // Load and apply new coin textures
          const textureLoader = new THREE.TextureLoader();
          textureLoader.load(data.coinData.headsImage, (headsTex) => {
            headsTex.minFilter = THREE.LinearFilter;
            headsTex.magFilter = THREE.LinearFilter;
            headsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
            headsTex.generateMipmaps = false;
            
            textureLoader.load(data.coinData.tailsImage, (tailsTex) => {
              tailsTex.minFilter = THREE.LinearFilter;
              tailsTex.magFilter = THREE.LinearFilter;
              tailsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
              tailsTex.generateMipmaps = false;
              
              // Update textures
              coin.material[1].uniforms.map.value = headsTex;
              coin.material[1].needsUpdate = true;
              coin.material[2].uniforms.map.value = tailsTex;
              coin.material[2].needsUpdate = true;
              
              // Update coin edge color based on material
              const edgeColor = new THREE.Color(tube.selectedMaterial.edgeColor);
              coin.material[0].color.copy(edgeColor);
              coin.material[0].emissive.copy(edgeColor);
              coin.material[0].emissiveIntensity = 0.3;
              coin.material[0].needsUpdate = true;
              
              console.log(`âœ… Applied ${data.coinData.name} with ${tube.selectedMaterial.name} material to ${player.name}'s coin`);
            });
          });
        }
      }
    }
    
    // Update coin angle visual
    function updateCoinAngleVisual(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const coin = coins[data.playerSlot];
        const tube = tubes[data.playerSlot];
        if (coin && tube && !tube.isFlipping) {
          // Only update angle if NOT currently flipping (prevent conflict)
          const angleRad = (data.angle * Math.PI) / 180;
          coin.rotation.z = angleRad;
        }
      }
    }
    
    // Update player choice from server broadcast
    function updatePlayerChoice(data) {
      console.log('ðŸŽ¯ Updating player choice:', data);
      
      // Find player by address or slot
      let playerIndex = -1;
      
      if (data.playerSlot !== undefined && data.playerSlot >= 0 && data.playerSlot < 4) {
        playerIndex = data.playerSlot;
      } else if (data.address) {
        const normalizedAddress = data.address.toLowerCase();
        playerIndex = players.findIndex(p => p.address && p.address.toLowerCase() === normalizedAddress);
      }
      
      if (playerIndex >= 0 && playerIndex < 4) {
        const player = players[playerIndex];
        if (player && !player.isEmpty) {
          // Update player choice
          player.choice = data.choice;
          console.log(`âœ… Updated player ${playerIndex + 1} choice to: ${data.choice}`);
          
          // Update the UI - find the choice badge and update it
          const tube = tubes[playerIndex];
          if (tube && tube.cardElement) {
            const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
            const choiceBadge = tube.cardElement.querySelector('.choice-badge');
            
            if (choiceButtons && choiceBadge) {
              // Replace choice buttons with badge
              choiceButtons.style.display = 'none';
              choiceBadge.style.display = 'inline-block';
              choiceBadge.textContent = data.choice.toUpperCase();
              choiceBadge.className = `choice-badge ${data.choice}`;
            }
          }
          
          // Update coin rotation to show the chosen face
          updateCoinRotationsFromPlayerChoices();
        }
      }
    }
    
    // Initialize socket connection
    initializeSocket();

    // ===== PLAYER CARD BUTTON MANAGEMENT =====
    
    // Update button visibility for all player cards based on current player slot
    function updatePlayerCardButtons() {
      tubes.forEach((tube, i) => {
        if (tube.cardElement) {
          const player = players[i];
          if (!player || player.isEmpty) return;
          
          // Determine if this is the current player's slot
          const isCurrentPlayer = isServerSideMode ? (playerSlot === i) : true;
          
          // Update choice buttons visibility
          const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
          const choiceBadge = tube.cardElement.querySelector('.choice-badge');
          
          if (isCurrentPlayer && !player.choice) {
            // Show choice buttons for current player
            if (choiceBadge) choiceBadge.style.display = 'none';
            if (choiceButtons) choiceButtons.style.display = 'block';
          } else if (player.choice) {
            // Show choice badge
            if (choiceButtons) choiceButtons.style.display = 'none';
            if (choiceBadge) choiceBadge.style.display = 'block';
          } else {
            // Hide everything for other players
            if (choiceButtons) choiceButtons.style.display = 'none';
            if (choiceBadge) choiceBadge.style.display = 'none';
          }
          
          // Update action buttons visibility
          const actionButtons = tube.cardElement.querySelectorAll('.action-btn');
          
          if (isCurrentPlayer) {
            // Show action buttons for current player
            actionButtons.forEach(btn => btn.style.display = 'block');
          } else {
            // Hide action buttons for other players
            actionButtons.forEach(btn => btn.style.display = 'none');
          }
          
          console.log(`ðŸŽ¯ Updated buttons for slot ${i}: isCurrentPlayer=${isCurrentPlayer}, hasChoice=${!!player.choice}`);
        }
      });
    }

    // ===== MISSING HELPER FUNCTIONS =====
    
    // Update round display
    function updateRoundDisplay() {
      const roundElement = document.getElementById('round-number');
      if (roundElement) {
        roundElement.textContent = currentRound;
      }
    }
    
    // Animate coin flip (visual only - for server-side physics)
    function animateCoinFlip(playerSlot, power, duration) {
      const tube = tubes[playerSlot];
      const coin = coins[playerSlot];
      
      if (!tube || !coin) return;
      
      // Visual animation only - no game logic
      const powerPercent = power / 100;
      const material = tube.selectedMaterial || coinMaterials[2]; // Default to glass
      const speedMult = material.speedMultiplier;
      const durationMult = material.durationMultiplier;
      
      const flipDuration = duration || (2000 + (powerPercent * 6000)) * durationMult;
      const basePowerSpeed = Math.max(0.08, 0.05 + (powerPercent * 0.25));
      const flipSpeed = basePowerSpeed * speedMult;
      
      console.log(`ðŸŽ¬ Starting visual coin flip for slot ${playerSlot}: duration=${flipDuration}ms, speed=${flipSpeed}`);
      
      const startTime = Date.now();
      
      const animateFlip = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / flipDuration, 1);
        
        if (progress < 0.7) {
          // Fast spinning phase (first 70%)
          coin.rotation.x += flipSpeed;
        } else {
          // Deceleration phase (last 30%)
          const decelProgress = (progress - 0.7) / 0.3;
          const currentSpeed = flipSpeed * (1 - decelProgress);
          coin.rotation.x += currentSpeed;
        }
        
        if (progress < 1) {
          requestAnimationFrame(animateFlip);
        } else {
          // Animation complete - server will send actual result
          console.log(`ðŸŽ¬ Visual flip animation complete for slot ${playerSlot}`);
        }
      };
      
      animateFlip();
    }

    // ===== AUDIO SYSTEM =====
    let isMuted = false;
    const glassBreakSound = new Audio('../Sound/glassclipped.mp3');
    glassBreakSound.volume = 0.7; // Adjust volume as needed
    
    const powerChargeSound = new Audio('../Sound/powerclipped.mp3');
    powerChargeSound.volume = 0.6; // Adjust volume as needed
    powerChargeSound.loop = true; // Loop while charging
    
    // Function to play sound with mute check
    function playSound(audio) {
      if (!isMuted && audio) {
        audio.currentTime = 0; // Reset to start
        audio.play().catch(err => console.log('Audio play prevented:', err));
      }
    }
    
    // Function to stop sound
    function stopSound(audio) {
      if (audio) {
        audio.pause();
        audio.currentTime = 0;
      }
    }
    
    // Function to toggle mute
    function toggleMute() {
      isMuted = !isMuted;
      console.log(`ðŸ”Š Sound ${isMuted ? 'MUTED' : 'UNMUTED'}`);
      
      // Mute/unmute all audio elements
      glassBreakSound.muted = isMuted;
      powerChargeSound.muted = isMuted;
      
      return isMuted;
    }

    const COLORS = {
      cyan: 0x00ffff,
      neonGreen: 0x00ff00, // NEON GREEN
      brightGreen: 0x39ff14, // Bright neon green
      pink: 0xff1493,
      gold: 0xFFD700,
      glass: 0x88ccff
    };

    let players = [
      { id: 1, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 2, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 3, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 4, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true }
    ];

    // Coin options - MUST be defined before tubes are created
    const coinOptions = [
      { id: 'plain', name: 'Classic', headsImage: '/coins/plainh.png', tailsImage: '/coins/plaint.png' },
      { id: 'skull', name: 'Skull', headsImage: '/coins/skullh.png', tailsImage: '/coins/skullt.png' },
      { id: 'trump', name: 'Trump', headsImage: '/coins/trumpheads.webp', tailsImage: '/coins/trumptails.webp' },
      { id: 'mario', name: 'Mario', headsImage: '/coins/mario.png', tailsImage: '/coins/luigi.png' },
      { id: 'jestress', name: 'Jestress', headsImage: '/coins/jestressh.png', tailsImage: '/coins/jestresst.png' },
      { id: 'dragon', name: 'é¾™', headsImage: '/coins/dragonh.png', tailsImage: '/coins/dragont.png' },
      { id: 'stinger', name: 'Stinger', headsImage: '/coins/stingerh.png', tailsImage: '/coins/stingert.png' },
      { id: 'manga', name: 'Heroine', headsImage: '/coins/mangah.png', tailsImage: '/coins/mangat.png' },
      { id: 'pharaoh', name: 'Pharaoh', headsImage: '/coins/pharaohh.png', tailsImage: '/coins/pharaoht.png' },
      { id: 'calavera', name: 'Calavera', headsImage: '/coins/calaverah.png', tailsImage: '/coins/calaverat.png' }
    ];

    // Coin material options with physics properties - MUST be defined before tubes are created
    const coinMaterials = [
      {
        id: 'graphite',
        name: 'Graphite',
        description: 'Ultra-Light & Swift',
        edgeColor: '#1a1a1a',
        speedMultiplier: 2.0,
        durationMultiplier: 0.5,
        characteristics: 'Ultra-fast flips, chaotic motion'
      },
      {
        id: 'penny',
        name: 'Penny',
        description: 'Lightweight & Fast',
        edgeColor: '#CD7F32',
        speedMultiplier: 1.5,
        durationMultiplier: 0.7,
        characteristics: 'Fast flips, unpredictable'
      },
      {
        id: 'glass',
        name: 'Glass',
        description: 'Crystal Clear & Elegant',
        edgeColor: '#87CEEB',
        speedMultiplier: 1.3,
        durationMultiplier: 0.8,
        characteristics: 'Smooth, elegant flips'
      },
      {
        id: 'silver-dollar',
        name: 'Silver Dollar',
        description: 'Heavy & Controlled',
        edgeColor: '#C0C0C0',
        speedMultiplier: 0.7,
        durationMultiplier: 1.3,
        characteristics: 'Slow, controlled, predictable'
      },
      {
        id: 'titanium',
        name: 'Titanium',
        description: 'Ultra-Heavy & Precise',
        edgeColor: '#2D1B69',
        speedMultiplier: 0.5,
        durationMultiplier: 1.6,
        characteristics: 'Very slow, precise flips'
      }
    ];

    // Game state
    let currentRound = 1;
    let timeRemaining = 30;
    let timerInterval = null;
    let roundCounterElement = null;
    let timerElement = null;
    let gameOver = false;
    let allPlayersFlipped = false;
    let roundEndTimer = null;
    let roundStartLives = []; // Track lives at start of each round

    // Color Management - ENABLED for proper emissive glow
    THREE.ColorManagement.enabled = true;
    
    // Scene
    const scene = new THREE.Scene();
    scene.background = null; // Transparent to show CSS background image
    
    // ===== ADD BACKGROUND IMAGE AS TEXTURED PLANE (1920x1080) =====
    const bgTextureLoader = new THREE.TextureLoader();
    const bgCandidates = [
      '/images/background/game room2.png'
    ];
    function loadBackground(paths, onSuccess, onFail) {
      if (!paths.length) { onFail && onFail(new Error('No background paths worked')); return; }
      const path = paths[0];
      bgTextureLoader.load(path, onSuccess, undefined, () => loadBackground(paths.slice(1), onSuccess, onFail));
    }
    loadBackground(bgCandidates, (bgTexture) => {
      // Keep texture in sRGB color space - don't convert
      bgTexture.colorSpace = THREE.SRGBColorSpace;
      bgTexture.minFilter = THREE.LinearFilter;
      bgTexture.magFilter = THREE.LinearFilter;
      
      // Calculate correct plane size based on camera FOV and distance
      // Camera: FOV=30Â°, position z=1400, background z=-500
      const distanceFromCamera = 1400 - (-500); // 1900 units
      const vFOV = camera.fov * Math.PI / 180; // Convert to radians
      const planeHeight = 2 * Math.tan(vFOV / 2) * distanceFromCamera;
      const planeWidth = planeHeight * camera.aspect; // Match screen aspect ratio
      
      // Create plane with calculated dimensions
      const bgGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: bgTexture,
        side: THREE.FrontSide,
        depthWrite: false, // Don't write to depth buffer
        depthTest: false, // Always render behind
        toneMapped: false, // CRITICAL: Don't apply tone mapping to background!
        fog: false, // Not affected by fog
        color: 0xcccccc // Slightly darkened (80% brightness) - adjust this if needed
      });
      const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
      bgPlane.position.set(0, 150, -500); // Behind the tubes
      bgPlane.renderOrder = -1; // Render first (behind everything)
      bgPlane.layers.set(0); // Layer 0 - main scene
      scene.add(bgPlane);
      scene.background = null; // Remove fallback color now that we have the texture
      console.log(`ðŸ–¼ï¸ Background image loaded! Size: ${planeWidth.toFixed(0)}x${planeHeight.toFixed(0)} at distance ${distanceFromCamera}`);
    }, undefined, (error) => {
      console.error('âŒ Failed to load background image:', error);
    });

    // Camera - FLATTER VIEW
    const width = window.innerWidth;
    const height = window.innerHeight;
    const camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000); // Narrower FOV
    camera.position.set(0, 150, 1400); // Higher camera position
    camera.lookAt(0, 150, 0); // Look at raised tubes
    camera.layers.enable(0); // Default layer - tubes, coins, etc.
    camera.layers.enable(1); // Bloom layer - pearls and plasma
    console.log('ðŸ“· Camera positioned for shorter tubes with dual-layer support');

    // WebGL Renderer
    const webglRenderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: true // Enable transparency for video background
    });
    webglRenderer.setSize(width, height);
    webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    webglRenderer.setClearColor(0x000000, 0); // Transparent clear color
    webglRenderer.autoClear = true;
    webglRenderer.toneMapping = THREE.ACESFilmicToneMapping; // Filmic tone mapping for vibrant colors
    webglRenderer.toneMappingExposure = 1.0; // Neutral exposure - don't brighten anything
    webglRenderer.outputColorSpace = THREE.SRGBColorSpace; // Proper color space
    console.log('ðŸŽ¨ WebGL Renderer initialized with transparency');
    document.getElementById('container').appendChild(webglRenderer.domElement);

    // ===== SELECTIVE BLOOM SETUP - Layer 1 (pearls) only! =====
    
    // Create bloom render target for layer 1 (pearls + plasma)
    const bloomRenderTarget = new THREE.WebGLRenderTarget(width, height, {
      type: THREE.HalfFloatType,
      format: THREE.RGBAFormat,
      colorSpace: THREE.SRGBColorSpace,
      stencilBuffer: false,
      depthBuffer: true
    });
    
    // Bloom composer - renders ONLY layer 1
    const bloomComposer = new EffectComposer(webglRenderer, bloomRenderTarget);
    
    // Render pass for layer 1 only (pearls + plasma)
    const bloomRenderPass = new RenderPass(scene, camera);
    bloomRenderPass.clear = true;
    bloomRenderPass.clearColor = new THREE.Color(0, 0, 0);
    bloomRenderPass.clearAlpha = 0; // Clear to transparent black
    bloomComposer.addPass(bloomRenderPass);
    
    // Bloom effect - ULTRA CRISP neon glow with minimal blur!
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(width, height),
      1.0,  // Strength - increased for better visibility
      0.3,  // Radius - slightly increased for better glow
      0.1   // Threshold - VERY LOW to catch all pearl emission
    );
    bloomPass.renderToScreen = false; // DON'T render to screen - keep in buffer!
    bloomComposer.addPass(bloomPass);
    
    bloomComposer.renderToScreen = false; // Keep result in render target!
    
    console.log('âœ¨ Selective bloom composer created for layer 1 (pearls)!');
    
    // ===== ADDITIVE BLEND SHADER - Composites bloomed pearls on top =====
    const AdditiveBlendShader = {
      uniforms: {
        baseTexture: { value: null },
        bloomTexture: { value: null }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D baseTexture;
        uniform sampler2D bloomTexture;
        varying vec2 vUv;
        void main() {
          vec4 base = texture2D(baseTexture, vUv);
          vec4 bloom = texture2D(bloomTexture, vUv);
          // Additive blending - add bloom on top
          gl_FragColor = base + bloom;
        }
      `
    };
    
    console.log('ðŸŽ¨ Additive blend shader created for compositing!');

    // CSS3D Renderer
    const cssRenderer = new CSS3DRenderer();
    cssRenderer.setSize(width, height);
    cssRenderer.domElement.style.position = 'absolute';
    cssRenderer.domElement.style.top = '0';
    cssRenderer.domElement.style.pointerEvents = 'auto';
    document.getElementById('container').appendChild(cssRenderer.domElement);

    // ===== LEAVE GAME BUTTON =====
    const leaveBtn = document.createElement('button');
    leaveBtn.textContent = 'Leave Game';
    leaveBtn.style.cssText = `
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10001;
      padding: 10px 14px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 1px;
      color: #fff;
      background: linear-gradient(135deg, #ff4444, #cc0000);
      border: 2px solid #ff4444;
      border-radius: 10px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
    `;
    leaveBtn.addEventListener('mouseenter', () => {
      leaveBtn.style.transform = 'translateY(-2px)';
      leaveBtn.style.boxShadow = '0 8px 18px rgba(255, 68, 68, 0.6)';
    });
    leaveBtn.addEventListener('mouseleave', () => {
      leaveBtn.style.transform = 'translateY(0)';
      leaveBtn.style.boxShadow = '0 0 15px rgba(255, 68, 68, 0.5)';
    });
    leaveBtn.onclick = () => {
      const confirmLeave = confirm('Leave game? You may forfeit if the match is active.');
      if (!confirmLeave) return;
      const lobbyUrl = gameIdParam ? `/battle-royale/${gameIdParam}` : '/';
      window.location.href = lobbyUrl;
    };
    document.body.appendChild(leaveBtn);

    // XP Counter for current player
    let currentPlayerXP = 0;
    const xpCounter = document.createElement('div');
    xpCounter.id = 'xp-counter';
    xpCounter.style.cssText = `
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10001;
      padding: 12px 18px;
      background: #0a0f2e;
      border: 2px solid #00ff88;
      border-radius: 12px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 14px;
      color: #00ff88;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      backdrop-filter: blur(10px);
      pointer-events: none;
    `;
    xpCounter.innerHTML = `
      <div style="font-size: 12px; color: #ffffff; opacity: 0.8; margin-bottom: 4px;">Total Earnings</div>
      <div style="font-size: 18px; margin-bottom: 2px;">${currentPlayerXP} FLIP</div>
      <div style="font-size: 10px; color: #ffffff; opacity: 0.8;">This Game</div>
    `;
    document.body.appendChild(xpCounter);

    // Function to update XP counter
    function updateXPCounter(amount) {
      currentPlayerXP += amount;
      const xpDisplay = xpCounter.querySelectorAll('div')[1]; // Second div contains the FLIP amount
      xpDisplay.textContent = `${currentPlayerXP} FLIP`;
      
      // Add a subtle glow effect when XP increases
      xpCounter.style.boxShadow = '0 0 30px rgba(0, 255, 136, 0.6)';
      setTimeout(() => {
        xpCounter.style.boxShadow = '0 0 20px rgba(0, 255, 136, 0.3)';
      }, 500);
    }

    // Function to show floating messages
    function showFloatingMessage(message, color, duration = 3000) {
      const floatingMsg = document.createElement('div');
      floatingMsg.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: ${color};
        padding: 15px 25px;
        border-radius: 12px;
        border: 2px solid ${color};
        font-family: 'Orbitron', sans-serif;
        font-size: 18px;
        font-weight: bold;
        z-index: 10000;
        text-align: center;
        box-shadow: 0 0 40px ${color}99;
        pointer-events: none;
        animation: floatIn 0.5s ease-out;
      `;
      
      floatingMsg.textContent = message;
      document.body.appendChild(floatingMsg);
      
      // Add CSS animation if not already added
      if (!document.getElementById('floating-animations')) {
        const style = document.createElement('style');
        style.id = 'floating-animations';
        style.textContent = `
          @keyframes floatIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          }
        `;
        document.head.appendChild(style);
      }
      
      setTimeout(() => {
        floatingMsg.style.animation = 'floatIn 0.5s ease-out reverse';
        setTimeout(() => {
          if (floatingMsg.parentNode) {
            floatingMsg.parentNode.removeChild(floatingMsg);
          }
        }, 500);
      }, duration);
    }

    // Global variables for collection UI
    let currentCollectionId = null;
    let collectionExpiryTimer = null;

    // Function to show collection UI
    function showCollectionUI(collectionId, totalFlip, gameResult, expiresAt) {
      currentCollectionId = collectionId;
      
      // Create collection overlay
      const overlay = document.createElement('div');
      overlay.id = 'collection-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.5s ease-out;
      `;

      // Create collection box
      const collectionBox = document.createElement('div');
      collectionBox.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 3px solid ${gameResult === 'won' ? '#FFD700' : '#00ff00'};
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 0 50px ${gameResult === 'won' ? '#FFD700' : '#00ff00'}99;
        animation: scaleIn 0.5s ease-out;
      `;

      const title = gameResult === 'won' ? 'ðŸ† VICTORY!' : 'ðŸ’° Game Complete';
      const titleColor = gameResult === 'won' ? '#FFD700' : '#00ff00';
      
      collectionBox.innerHTML = `
        <h2 style="color: ${titleColor}; margin: 0 0 20px 0; font-size: 28px;">${title}</h2>
        <div style="font-size: 24px; margin: 20px 0; color: #FFD700;">
          ðŸ’Ž ${totalFlip} FLIP Tokens Earned
        </div>
        <div style="font-size: 14px; color: #888; margin: 20px 0;">
          â° Collect within 24 hours or they expire!
        </div>
        <div style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
          <button id="collect-flip-btn" style="
            background: linear-gradient(45deg, #00ff00, #00cc00);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
          ">ðŸ’Ž Claim FLIP</button>
          ${gameResult === 'won' ? `
          <button id="claim-nft-btn" style="
            background: linear-gradient(45deg, #ff0088, #cc0066);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
          ">ðŸ† Claim NFT</button>
          ` : ''}
        </div>
        <div style="font-size: 12px; color: #666; margin-top: 15px;">
          Collection expires: ${new Date(expiresAt).toLocaleString()}
        </div>
      `;

      overlay.appendChild(collectionBox);
      document.body.appendChild(overlay);

      // Add button hover effects
      const collectBtn = document.getElementById('collect-flip-btn');
      const claimNftBtn = document.getElementById('claim-nft-btn');
      
      collectBtn.addEventListener('mouseenter', () => {
        collectBtn.style.transform = 'scale(1.05)';
        collectBtn.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.6)';
      });
      collectBtn.addEventListener('mouseleave', () => {
        collectBtn.style.transform = 'scale(1)';
        collectBtn.style.boxShadow = 'none';
      });

      if (claimNftBtn) {
        claimNftBtn.addEventListener('mouseenter', () => {
          claimNftBtn.style.transform = 'scale(1.05)';
          claimNftBtn.style.boxShadow = '0 0 20px rgba(255, 0, 136, 0.6)';
        });
        claimNftBtn.addEventListener('mouseleave', () => {
          claimNftBtn.style.transform = 'scale(1)';
          claimNftBtn.style.boxShadow = 'none';
        });
      }

      // Add event listeners
      collectBtn.addEventListener('click', () => {
        if (isServerSideMode && socket && gameIdParam && walletParam) {
          socket.emit('collect_flip_tokens', {
            collectionId: collectionId,
            address: walletParam
          });
        }
      });

      if (claimNftBtn) {
        claimNftBtn.addEventListener('click', () => {
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('claim_nft', {
              collectionId: collectionId,
              address: walletParam
            });
          }
        });
      }

      // Set expiry timer
      const expiryTime = new Date(expiresAt).getTime() - Date.now();
      if (expiryTime > 0) {
        collectionExpiryTimer = setTimeout(() => {
          showFloatingMessage('â° Collection expired!', '#ff4444', 3000);
          hideCollectionUI();
        }, expiryTime);
      }

      // Add CSS animations if not already added
      if (!document.getElementById('collection-animations')) {
        const style = document.createElement('style');
        style.id = 'collection-animations';
        style.textContent = `
          @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
          }
          @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
          }
        `;
        document.head.appendChild(style);
      }
    }

    // Function to hide collection UI
    function hideCollectionUI() {
      const overlay = document.getElementById('collection-overlay');
      if (overlay) {
        overlay.style.animation = 'fadeIn 0.5s ease-out reverse';
        setTimeout(() => {
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        }, 500);
      }
      
      currentCollectionId = null;
      if (collectionExpiryTimer) {
        clearTimeout(collectionExpiryTimer);
        collectionExpiryTimer = null;
      }
    }

    // Lighting - Very low ambient to protect background from any indirect brightening
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Minimal ambient
    scene.add(ambientLight);

    const topLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced
    topLight.position.set(0, 600, 400);
    scene.add(topLight);

    const leftAccent = new THREE.PointLight(COLORS.cyan, 1, 1500); // Reduced
    leftAccent.position.set(-800, 200, 400);
    scene.add(leftAccent);

    const rightAccent = new THREE.PointLight(COLORS.pink, 1, 1500); // Reduced
    rightAccent.position.set(800, 200, 400);
    scene.add(rightAccent);

    // Front light - illuminates the tubes from camera position
    const frontLight = new THREE.DirectionalLight(0xffffff, 1.0); // Good brightness for tubes
    frontLight.position.set(0, 200, 1200); // From camera position
    frontLight.target.position.set(0, 200, 0); // Pointing at tubes
    scene.add(frontLight);
    scene.add(frontLight.target);

    // Create tubes
    const NUM_TUBES = 4;
    const TUBE_RADIUS = 80;
    const TUBE_HEIGHT = 350; // Shorter tubes
    const SPACING = 350;

    // Calculate tube positions
    const totalWidth = SPACING * (NUM_TUBES - 1);
    const startX = -totalWidth / 2;

    // ===== LOAD BRASS/METALLIC TEXTURES =====
    const textureLoader = new THREE.TextureLoader();
    const brassColorMap = textureLoader.load('/Images/textures/Brass/textures/rusty_metal_04_diff_4k.jpg');
    const brassDisplacementMap = textureLoader.load('/Images/textures/Brass/textures/rusty_metal_04_disp_4k.png');
    
    brassColorMap.wrapS = THREE.RepeatWrapping;
    brassColorMap.wrapT = THREE.RepeatWrapping;
    brassColorMap.repeat.set(2, 2);
    
    brassDisplacementMap.wrapS = THREE.RepeatWrapping;
    brassDisplacementMap.wrapT = THREE.RepeatWrapping;
    brassDisplacementMap.repeat.set(2, 2);

    console.log('ðŸŽ¨ Brass metallic textures loaded');

    // ===== CREATE SHARED ALPHA MAP FOR GLASS CUTOUT (ONE FOR ALL TUBES) =====
    const tubeAlphaCanvas = document.createElement('canvas');
    tubeAlphaCanvas.width = 512;
    tubeAlphaCanvas.height = 512;
    const tubeAlphaCtx = tubeAlphaCanvas.getContext('2d');
    
    // Fill with white (visible glass)
    tubeAlphaCtx.fillStyle = 'white';
    tubeAlphaCtx.fillRect(0, 0, 512, 512);
    
    // Create rectangular cutout with rounded corners (centered on front, where coin is)
    tubeAlphaCtx.globalCompositeOperation = 'destination-out';
    tubeAlphaCtx.fillStyle = 'black';
    
    // Rectangle dimensions (full height of glass, centered horizontally)
    const rectWidth = 200;
    const rectHeight = 440; // Full height of tube
    const rectX = 256 - rectWidth / 2;
    const rectY = 36; // Start near top
    const cornerRadius = 30; // Larger rounded corners
    
    // Draw rounded rectangle cutout
    tubeAlphaCtx.beginPath();
    tubeAlphaCtx.moveTo(rectX + cornerRadius, rectY);
    tubeAlphaCtx.lineTo(rectX + rectWidth - cornerRadius, rectY);
    tubeAlphaCtx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + cornerRadius);
    tubeAlphaCtx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerRadius);
    tubeAlphaCtx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - cornerRadius, rectY + rectHeight);
    tubeAlphaCtx.lineTo(rectX + cornerRadius, rectY + rectHeight);
    tubeAlphaCtx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - cornerRadius);
    tubeAlphaCtx.lineTo(rectX, rectY + cornerRadius);
    tubeAlphaCtx.quadraticCurveTo(rectX, rectY, rectX + cornerRadius, rectY);
    tubeAlphaCtx.closePath();
    tubeAlphaCtx.fill();
    
    const tubeAlphaTexture = new THREE.CanvasTexture(tubeAlphaCanvas);
    tubeAlphaTexture.wrapS = THREE.RepeatWrapping;
    tubeAlphaTexture.wrapT = THREE.ClampToEdgeWrapping;

    // ===== PHYSICS WORLD SETUP =====
    const physicsWorld = new CANNON.World({
      gravity: new CANNON.Vec3(0, -980, 0) // Gravity in cm/s^2
    });
    physicsWorld.defaultContactMaterial.friction = 0.1;
    physicsWorld.defaultContactMaterial.restitution = 0.3;

    console.log('âš™ï¸ Physics world created with gravity');

    const tubes = [];
    const coins = [];

    for (let i = 0; i < NUM_TUBES; i++) {
      const x = startX + (i * SPACING);
      const player = players[i];

      // Glass tube - METALLIC SILVER with RECTANGULAR CUTOUT around coin
      const tubeGeometry = new THREE.CylinderGeometry(TUBE_RADIUS, TUBE_RADIUS, TUBE_HEIGHT, 64, 1, true);
      
      const glassMaterial = new THREE.MeshStandardMaterial({
        color: 0xd0d0d0, // Bright silver
        transparent: true,
        opacity: 0.15, // Very transparent to see video background
        alphaMap: tubeAlphaTexture, // Apply shared rectangular cutout
        roughness: 0.2,
        metalness: 1.0, // Full metallic
        emissive: 0x505050, // Slight silver glow
        emissiveIntensity: 0.15,
        side: THREE.DoubleSide
      });
      const tube = new THREE.Mesh(tubeGeometry, glassMaterial);
      tube.position.set(x, 200, 0); // Move tubes higher up
      tube.rotation.y = Math.PI; // Rotate 180Â° so cutout faces camera
      scene.add(tube);

      // ===== CHROME BACKING PANEL - Creates contrast with background image =====
      const backingGeometry = new THREE.CylinderGeometry(TUBE_RADIUS + 5, TUBE_RADIUS + 5, TUBE_HEIGHT + 20, 32, 1, false);
      const backingMaterial = new THREE.MeshStandardMaterial({
        color: 0xe0e0e0, // Bright chrome/silver
        roughness: 0.1,
        metalness: 0.98,
        emissive: 0x404040,
        emissiveIntensity: 0.1,
        side: THREE.BackSide // Only visible from inside
      });
      const backing = new THREE.Mesh(backingGeometry, backingMaterial);
      backing.position.set(x, 200, -10); // Position slightly behind the tube
      scene.add(backing);

      // ===== BRASS CAPS (TOP & BOTTOM LIDS) - METALLIC =====
      const brassCapMaterial = new THREE.MeshStandardMaterial({
        map: brassColorMap,
        displacementMap: brassDisplacementMap,
        displacementScale: 0.2,
        metalness: 0.98,
        roughness: 0.1,
      });

      // Top cap with transparent circle cutout for coin viewing
      const capGeometry = new THREE.CylinderGeometry(TUBE_RADIUS + 10, TUBE_RADIUS + 10, 15, 64);
      
      // Create alpha map with transparent circle
      const capCanvas = document.createElement('canvas');
      capCanvas.width = 256;
      capCanvas.height = 256;
      const capCtx = capCanvas.getContext('2d');
      
      // Fill with white (opaque brass)
      capCtx.fillStyle = 'white';
      capCtx.fillRect(0, 0, 256, 256);
      
      // Cut out transparent circle in center
      capCtx.globalCompositeOperation = 'destination-out';
      capCtx.fillStyle = 'black';
      capCtx.beginPath();
      capCtx.arc(128, 128, 60, 0, Math.PI * 2); // Circle cutout
      capCtx.fill();
      
      const capAlphaTexture = new THREE.CanvasTexture(capCanvas);
      
      const topCapMaterial = brassCapMaterial.clone();
      topCapMaterial.alphaMap = capAlphaTexture;
      topCapMaterial.transparent = true;
      
      const topCap = new THREE.Mesh(capGeometry, topCapMaterial);
      topCap.position.set(x, 200 + (TUBE_HEIGHT / 2) + 7.5, 0);
      scene.add(topCap);

      // Bottom cap (solid brass metallic disc)
      const bottomCap = new THREE.Mesh(capGeometry, brassCapMaterial.clone());
      bottomCap.position.set(x, 200 - (TUBE_HEIGHT / 2) - 7.5, 0);
      scene.add(bottomCap);

      // Decorative rims (ORANGE - SMOOTH & GLOSSY)
      const rimGeometry = new THREE.TorusGeometry(TUBE_RADIUS + 5, 8, 32, 64);
      const rimMaterial = new THREE.MeshStandardMaterial({
        color: 0xff8800, // BRIGHT ORANGE
        metalness: 0.95,
        roughness: 0.1,
      });
      
      const topRim = new THREE.Mesh(rimGeometry, rimMaterial);
      topRim.position.set(x, 200 + TUBE_HEIGHT / 2, 0);
      topRim.rotation.x = Math.PI / 2;
      scene.add(topRim);

      const bottomRim = topRim.clone();
      bottomRim.position.y = 200 - TUBE_HEIGHT / 2;
      scene.add(bottomRim);

      // ===== PHYSICS-BASED LIQUID SYSTEM =====
      
      // Create glass container collision boundaries (SEALED CONTAINER)
      const glassBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        position: new CANNON.Vec3(x, 200, 0)
      });
      
      // SOLID BOTTOM CAP - thick box to seal bottom completely
      const bottomCapShape = new CANNON.Box(new CANNON.Vec3(TUBE_RADIUS + 5, 20, TUBE_RADIUS + 5));
      const bottomCapOffset = new CANNON.Vec3(0, -(TUBE_HEIGHT / 2) - 15, 0);
      glassBody.addShape(bottomCapShape, bottomCapOffset);
      
      // SOLID TOP CAP - VERY THICK box to seal top completely (prevents all escape!)
      const topCapShape = new CANNON.Box(new CANNON.Vec3(TUBE_RADIUS + 5, 30, TUBE_RADIUS + 5));
      const topCapOffset = new CANNON.Vec3(0, (TUBE_HEIGHT / 2) + 20, 0);
      glassBody.addShape(topCapShape, topCapOffset);
      
      // Cylindrical walls - 16 segments for smooth circular containment
      const numWalls = 16;
      const wallThickness = 3;
      for (let w = 0; w < numWalls; w++) {
        const angle = (w / numWalls) * Math.PI * 2;
        const wallX = Math.cos(angle) * (TUBE_RADIUS - 6);
        const wallZ = Math.sin(angle) * (TUBE_RADIUS - 6);
        
        const wallShape = new CANNON.Box(new CANNON.Vec3(wallThickness, (TUBE_HEIGHT - 10) / 2, wallThickness));
        const wallOffset = new CANNON.Vec3(wallX, 0, wallZ);
        glassBody.addShape(wallShape, wallOffset);
      }
      
      physicsWorld.addBody(glassBody);
      console.log(`âš™ï¸ Sealed physics container created for tube ${i + 1}`);

      // Create PEARL particles (glowing pink balls inside the tube)
      const liquidParticles = [];
      const liquidParticleMeshes = [];
      const particleRadius = 7; // Pearl-sized
      const maxLayers = 80; // Double the pearls for more dramatic effect
      const pRadius = particleRadius;
      
      // Start pearls at the bottom of the tube
      for (let p = 0; p < maxLayers; p++) {
        // Random position inside cylinder at bottom
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * (TUBE_RADIUS - 25);
        const pearlX = x + Math.cos(angle) * radius;
        const pearlZ = Math.sin(angle) * radius;
        const pearlY = 200 - (TUBE_HEIGHT / 2) + 30 + Math.random() * 60; // Start at bottom
        
        // Create physics body - BOUNCY!
        const particleShape = new CANNON.Sphere(particleRadius);
        const particleBody = new CANNON.Body({
          mass: 0.3, // Lighter so they float easier
          position: new CANNON.Vec3(pearlX, pearlY, pearlZ),
          material: new CANNON.Material({ friction: 0.1, restitution: 0.8 }) // VERY BOUNCY!
        });
        particleBody.addShape(particleShape);
        particleBody.linearDamping = 0.6; // Less damping = more movement
        particleBody.angularDamping = 0.6;
        particleBody.collisionFilterGroup = 1;
        particleBody.collisionFilterMask = -1;
        
        // Add to physics world immediately
        physicsWorld.addBody(particleBody);
        
        // Create visual PEARL - starts neutral dark (will transition to tube's color)
        const particleGeometry = new THREE.SphereGeometry(particleRadius, 32, 32); // Higher segments for perfect sphere
        const particleMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x1a1a1a, // Neutral dark grey
          metalness: 0.0, // No metalness for pure emissive glow
          roughness: 0.3,
          transparent: true,
          opacity: 0.7, // More transparent to see video
          emissive: 0x0a0a0a, // Very faint neutral glow
          emissiveIntensity: 0.2,
          toneMapped: false, // Bypass tone mapping for maximum brightness!
          clearcoat: 1.0,
          clearcoatRoughness: 0.05
        });
        const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
        particleMesh.visible = true;
        particleMesh.layers.set(1); // LAYER 1 - For selective bloom!
        scene.add(particleMesh);
        
        liquidParticles.push(particleBody);
        liquidParticleMeshes.push(particleMesh);
      }

      // Visual liquid surface (smooth mesh - PRE-FILLED with darkish liquid)
      const liquidHeight = TUBE_HEIGHT - 20;
      const liquidGeometry = new THREE.CylinderGeometry(TUBE_RADIUS - 6, TUBE_RADIUS - 6, liquidHeight, 32, 32);
      const liquidMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x1a1a2e, // Dark blue-grey
        metalness: 0.05,
        roughness: 0.3,
        transparent: true,
        opacity: 0.25, // Much more transparent to see video through
        transmission: 0.6, // Higher transmission for see-through effect
        thickness: 1.5,
        clearcoat: 0.6,
        clearcoatRoughness: 0.05,
        emissive: 0x0a0a1a, // Very faint blue glow
        emissiveIntensity: 0.2,
        ior: 1.33,
        reflectivity: 0.3,
        envMapIntensity: 1.2,
        side: THREE.DoubleSide
      });
      const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
      const liquidY = 200 - (TUBE_HEIGHT / 2) + (liquidHeight / 2);
      liquid.position.set(x, liquidY, 0);
      liquid.scale.y = 1.0; // Pre-filled to 100%
      liquid.visible = true; // Visible from start
      scene.add(liquid);

      // Liquid light (starts very dim)
      const liquidLight = new THREE.PointLight(0x1a1a2e, 0.3, 400); // Dim blue-grey
      liquidLight.position.set(0, 0, 0);
      liquid.add(liquidLight);

      // Spotlight - illuminates each tube/cylinder nicely without affecting background
      const spotlight = new THREE.SpotLight(0xffffff, 0.7, 700, Math.PI / 6, 0.5, 2);
      spotlight.position.set(x, 200 + TUBE_HEIGHT / 2 + 300, 150);
      spotlight.target.position.set(x, 200, 0);
      scene.add(spotlight);
      scene.add(spotlight.target);

      // Platform (BRASS METALLIC BASE)
      const platformGeometry = new THREE.CylinderGeometry(TUBE_RADIUS + 20, TUBE_RADIUS + 20, 15, 32);
      const platformMaterial = new THREE.MeshStandardMaterial({
        map: brassColorMap,
        displacementMap: brassDisplacementMap,
        displacementScale: 0.2,
        metalness: 0.98,
        roughness: 0.1,
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.set(x, 200 - (TUBE_HEIGHT / 2) - 30, 0);
      scene.add(platform);

      // Gold coin (centered in tube) - with HEADS and TAILS textures
      const coinRadius = 65; // 30% larger (was 50)
      const coinThickness = 16; // Scaled proportionally
      const coinGeometry = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);
      const textureLoader = new THREE.TextureLoader();
      
      // Load default coin textures (will be replaced by default selection logic below)
      const headsTexture = textureLoader.load('/coins/plainh.png'); // Temporary placeholder
      const tailsTexture = textureLoader.load('/coins/plaint.png'); // Temporary placeholder
      
      headsTexture.minFilter = THREE.LinearFilter;
      headsTexture.magFilter = THREE.LinearFilter;
      headsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
      headsTexture.generateMipmaps = false;
      
      tailsTexture.minFilter = THREE.LinearFilter;
      tailsTexture.magFilter = THREE.LinearFilter;
      tailsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
      tailsTexture.generateMipmaps = false;
      
      // Custom shader that outputs RAW texture colors (no gamma, no processing)
      const rawTextureShader = {
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D map;
          varying vec2 vUv;
          void main() {
            gl_FragColor = texture2D(map, vUv);
          }
        `
      };
      
      // Create materials using RAW shader (bypasses ALL THREE.js color processing)
      const coinMaterials = [
        new THREE.MeshStandardMaterial({ 
          color: 0xFFD700,
          emissive: 0xFFD700,
          emissiveIntensity: 0.3,
          metalness: 0.8,
          roughness: 0.2,
          side: THREE.DoubleSide,
          transparent: false
        }), // Side - glowing gold
        new THREE.ShaderMaterial({
          uniforms: { 
            map: { value: headsTexture }
          },
          vertexShader: rawTextureShader.vertexShader,
          fragmentShader: rawTextureShader.fragmentShader,
          side: THREE.DoubleSide,
          depthWrite: true,
          depthTest: true,
          transparent: false
        }), // Top (heads) - RAW texture pixels
        new THREE.ShaderMaterial({
          uniforms: { 
            map: { value: tailsTexture }
          },
          vertexShader: rawTextureShader.vertexShader,
          fragmentShader: rawTextureShader.fragmentShader,
          side: THREE.DoubleSide,
          depthWrite: true,
          depthTest: true,
          transparent: false
        })  // Bottom (tails) - RAW texture pixels
      ];
      
      const coin = new THREE.Mesh(coinGeometry, coinMaterials);
      coin.rotation.x = Math.PI / 2; // Standing on edge (90 degrees)
      coin.rotation.y = Math.PI / 2; // Rotated 90 degrees left for proper facing
      coin.rotation.z = 0; // No tilt
      coin.position.set(x, 200, 0); // Centered in tube
      coin.visible = true; // Explicitly set visible
      coin.frustumCulled = false; // Never cull from view - always render
      coin.renderOrder = 1; // Render after background but before UI
      coin.layers.set(0); // Main rendering layer
      coin.matrixAutoUpdate = true; // Ensure matrix updates
      
      // Force materials to update on next render
      coin.material.forEach(mat => {
        if (mat.needsUpdate !== undefined) mat.needsUpdate = true;
      });
      
      scene.add(coin);

      // Diffused dark navy shadow backdrop (hidden initially, shows after glass breaks)
      const shadowGeometry = new THREE.CircleGeometry(coinRadius * 1.5, 64);
      
      // Create gradient shadow with custom shader for soft diffusion
      const shadowMaterial = new THREE.ShaderMaterial({
        transparent: true,
        side: THREE.DoubleSide,
        uniforms: {
          centerColor: { value: new THREE.Color(0x0a0a2e) }, // Dark navy
          edgeColor: { value: new THREE.Color(0x000000) }, // Black at edges
          opacity: { value: 0.85 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 centerColor;
          uniform vec3 edgeColor;
          uniform float opacity;
          varying vec2 vUv;
          void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(vUv, center);
            float gradient = smoothstep(0.0, 0.5, dist);
            vec3 color = mix(centerColor, edgeColor, gradient);
            float alpha = opacity * (1.0 - smoothstep(0.3, 0.5, dist));
            gl_FragColor = vec4(color, alpha);
          }
        `
      });
      
      const coinShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
      coinShadow.position.set(x, 200, -8); // Behind coin, slightly further back
      coinShadow.visible = false; // Hidden initially
      scene.add(coinShadow);

      coins.push(coin);

      // Player card (CSS3D)
      const cardElement = document.createElement('div');
      cardElement.className = 'player-card';
      
      // Initially hide buttons - they will be shown when player slot is determined
      let showButtons = false;
      if (!isServerSideMode) {
        // Fallback for local mode
        showButtons = !player.isEmpty;
      }
      // In server-side mode, buttons will be shown via updatePlayerCardButtons() when playerSlot is set
      
      console.log(`ðŸŽ¯ Initial Player ${i + 1} button logic (DEBUGGING MODE):`, {
        playerAddress: player.address,
        isEmpty: player.isEmpty,
        showButtons: showButtons
      });
      
      // Create empty slot overlay for empty players
      const emptySlotOverlay = player.isEmpty ? `
        <div class="empty-slot-overlay" style="
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(255, 20, 147, 0.8);
          border-radius: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 48px;
          font-weight: bold;
          color: white;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
          z-index: 10;
        ">âœ•</div>
      ` : '';
      
      cardElement.innerHTML = `
        ${emptySlotOverlay}
        <div class="card-header">
          <img src="${player.isEmpty ? '/images/potion.png' : (player.avatar || '/images/default-avatar.png')}" class="player-avatar" alt="${player.name}" style="width: 80px; height: 100px;" />
          <div class="player-info">
            <div class="player-name">${player.name}</div>
            <div class="lives-container" style="display: flex; gap: 8px; margin-top: 8px;">
              ${Array.from({ length: 3 }, (_, idx) => 
                `<div class="life ${idx < player.lives ? 'active' : ''}" style="width: 54px; height: 54px; display: flex; align-items: center; justify-content: center; font-size: 40.5px; color: ${idx < player.lives ? '#ff4444' : '#666'};">
                  â¤ï¸
                </div>`
              ).join('')}
            </div>
          </div>
        </div>
        ${player.choice ? `
          <div class="choice-badge ${player.choice}" style="display: ${player.choice ? 'block' : 'none'};">
            ${player.choice.toUpperCase()}
          </div>
        ` : ''}
        <div class="choice-buttons" style="display: ${showButtons && !player.choice ? 'block' : 'none'};">
          <button class="choice-btn heads">HEADS</button>
          <button class="choice-btn tails">TAILS</button>
        </div>
        <div style="margin: 15px 0;">
          <div style="height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; margin-bottom: 8px;">
            <div class="power-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #00ff00, #39ff14); border-radius: 10px; transition: width 0.1s;"></div>
          </div>
          <div class="power-text" style="color: #00ff00; font-size: 14px; text-align: center;">POWER: 0%</div>
        </div>
        <button class="action-btn change-coin-btn" data-player="${i}" style="display: ${showButtons ? 'block' : 'none'};">CHANGE COIN</button>
        <button class="action-btn" style="display: ${showButtons ? 'block' : 'none'};">CHARGE POWER</button>
      `;

      cardElement.style.pointerEvents = 'auto';
      
      // Add choice button handlers (always add, visibility controlled by CSS)
      const choiceButtons = cardElement.querySelectorAll('.choice-btn');
      choiceButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          const choice = button.classList.contains('heads') ? 'heads' : 'tails';
          
          // Update local player choice immediately
          players[i].choice = choice;
          
          // Update local UI immediately
          const choiceBadge = cardElement.querySelector('.choice-badge');
          const choiceButtons = cardElement.querySelector('.choice-buttons');
          if (choiceButtons && choiceBadge) {
            choiceButtons.style.display = 'none';
            choiceBadge.style.display = 'inline-block';
            choiceBadge.textContent = choice.toUpperCase();
            choiceBadge.className = `choice-badge ${choice}`;
          }
          
          // Update coin rotation locally
          updateCoinRotationsFromPlayerChoices();
          
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            // Send choice to server (will broadcast to other players)
            socket.emit('physics_set_choice', {
              gameId: gameIdParam,
              address: walletParam,
              choice: choice
            });
            console.log(`ðŸŽ¯ Sent choice to server: ${choice}`);
          }
        });
      });

      // Add change coin button handler (always add, visibility controlled by CSS)
      const changeCoinButton = cardElement.querySelector('.change-coin-btn');
      if (changeCoinButton) {
        changeCoinButton.style.pointerEvents = 'auto';
        changeCoinButton.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log(`ðŸŽ¨ Change coin for player ${i + 1}`);
          showCoinSelector(i);
        });
      }

      // Add power charge button handler (HOLD TO CHARGE) - always add, visibility controlled by CSS
      const flipButtons = cardElement.querySelectorAll('.action-btn');
      const powerButton = flipButtons[1]; // The second action button
      const powerBar = cardElement.querySelector('.power-bar');
      
      if (powerButton) {
        const powerText = cardElement.querySelector('.power-text');
        powerButton.style.pointerEvents = 'auto';
        
        let isCharging = false;
        
        powerButton.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          
          // Prevent charging if player has no lives
          if (players[i].lives <= 0) {
            console.log(`âŒ Player ${i + 1} has no lives - cannot flip coin`);
            return;
          }
          
          // Prevent charging if player hasn't chosen heads or tails
          if (!players[i].choice) {
            showChoiceRequiredMessage(i);
            console.log(`âŒ Player ${i + 1} must choose heads or tails first!`);
            return;
          }
          
          // Prevent charging if already used this round
          if (tubes[i].hasUsedPower) return;
          
          console.log(`âš¡ Charging power for tube ${i + 1}`);
          isCharging = true;
          tubes[i].isFilling = true;
          tubes[i].power = 0;
          tubes[i].chargingStartTime = Date.now(); // Track start time for sync
          
          // Play power charging sound
          playSound(powerChargeSound);
          
          // ðŸŽ¯ NEW: INSTANT BROADCAST - Tell everyone charging started
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_start', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: i
            });
            console.log(`ðŸ“¢ Broadcast: Player ${i + 1} started charging`);
          }
        });
        
        powerButton.addEventListener('mouseup', (e) => {
          e.stopPropagation();
          const finalPower = tubes[i].power;
          console.log(`âš¡ Power released at ${finalPower.toFixed(0)}%`);
          isCharging = false;
          tubes[i].isFilling = false;
          
          // Stop power charging sound
          stopSound(powerChargeSound);
          
          // ðŸŽ¯ NEW: INSTANT BROADCAST - Tell everyone charging stopped
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_stop', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: i,
              finalPower: finalPower
            });
            console.log(`ðŸ“¢ Broadcast: Player ${i + 1} stopped charging at ${finalPower}%`);
          }
          
          // Shatter glass and flip coin (minimum 5% power to prevent instant flips)
          if (finalPower >= 5) {
            // Server-side physics: Send flip request to server
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              // Get player choice from the card
              const playerChoice = players[i].choice;
              
              // Send flip request to server (server will broadcast glass shatter to all)
              socket.emit('physics_flip_coin', {
                gameId: gameIdParam,
                address: walletParam,
                power: finalPower,
                angle: 0 // Default angle for now
              });
              
              console.log(`ðŸª™ Sent flip request to server: power=${finalPower}, choice=${playerChoice}`);
            } else {
              // Fallback to local physics (for testing)
              shatterGlass(i, finalPower);
              const playerChoice = players[i].choice;
              flipCoinWithPower(i, finalPower, playerChoice);
            }
            
            // Disable button after use
            powerButton.disabled = true;
            powerButton.style.opacity = '0.5';
            powerButton.style.cursor = 'not-allowed';
            powerButton.style.background = '#cccccc';
            powerButton.style.color = '#666666';
            powerButton.style.borderColor = '#999999';
            tubes[i].hasUsedPower = true;
          }
        });
        
        powerButton.addEventListener('mouseleave', (e) => {
          if (isCharging) {
            const finalPower = tubes[i].power;
            console.log(`âš¡ Power released at ${finalPower.toFixed(0)}%`);
            
            // Stop power charging sound
            stopSound(powerChargeSound);
            
            // ðŸŽ¯ NEW: INSTANT BROADCAST - Tell everyone charging stopped
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              socket.emit('physics_power_charging_stop', {
                gameId: gameIdParam,
                address: walletParam,
                playerSlot: i,
                finalPower: finalPower
              });
              console.log(`ðŸ“¢ Broadcast: Player ${i + 1} stopped charging (mouseleave) at ${finalPower}%`);
            }
            
            // Shatter glass and flip coin (minimum 5% power)
            if (finalPower >= 5) {
              // Server-side physics: Send flip request to server
              if (isServerSideMode && socket && gameIdParam && walletParam) {
                // Get player choice from the card
                const playerChoice = players[i].choice;
                
                // Send flip request to server (server will broadcast glass shatter to all)
                socket.emit('physics_flip_coin', {
                  gameId: gameIdParam,
                  address: walletParam,
                  power: finalPower,
                  angle: 0 // Default angle for now
                });
                
                console.log(`ðŸª™ Sent flip request to server (mouseleave): power=${finalPower}, choice=${playerChoice}`);
              } else {
                // Fallback to local physics (for testing)
                shatterGlass(i, finalPower);
                const playerChoice = players[i].choice;
                flipCoinWithPower(i, finalPower, playerChoice);
              }
              
              // Disable button after use
              powerButton.disabled = true;
              powerButton.style.opacity = '0.5';
              powerButton.style.cursor = 'not-allowed';
              powerButton.style.background = '#cccccc';
              powerButton.style.color = '#666666';
              powerButton.style.borderColor = '#999999';
              tubes[i].hasUsedPower = true;
            }
          }
          isCharging = false;
          tubes[i].isFilling = false;
        });
        
        // Add choice button handlers (only for current player)
        const choiceButtons = cardElement.querySelectorAll('.choice-btn');
        choiceButtons.forEach(btn => {
          btn.style.pointerEvents = 'auto';
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            
            // Don't allow choices if player has no lives
            if (players[i].lives <= 0) {
              console.log(`âŒ Player ${i + 1} has no lives - cannot make choice`);
              return;
            }
            
            const choice = btn.textContent.toLowerCase();
            players[i].choice = choice;
            console.log(`Player ${i + 1} selected: ${choice}`);
            
            // Update coin rotation immediately
            updateCoinRotationsFromPlayerChoices();
            
            // Send choice to server
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              socket.emit('physics_set_choice', {
                gameId: gameIdParam,
                address: walletParam,
                choice: choice
              });
              console.log(`ðŸŽ¯ Sent choice to server: ${choice}`);
            }
            
            // Replace buttons with choice badge
            const choiceButtonContainer = cardElement.querySelector('.choice-buttons');
            if (choiceButtonContainer) {
              choiceButtonContainer.outerHTML = `
                <div class="choice-badge ${choice}">
                  ${choice.toUpperCase()}
                </div>
              `;
            }
          });
        });
      }

      const cssObject = new CSS3DObject(cardElement);
      // Position cards BELOW the tubes
      cssObject.position.set(x, 200 - (TUBE_HEIGHT / 2) - 140, 0);
      cssObject.scale.set(0.6, 0.45, 0.6); // Wider, less tall
      scene.add(cssObject);

      // Auto-apply default selections to fix coin picker gradient issue
      const defaultCoin = coinOptions[0]; // Classic coin
      const defaultMaterial = coinMaterials[0]; // Graphite material
      
      // Load and apply the default coin textures (heads and tails)
      textureLoader.load(defaultCoin.headsImage, (headsTex) => {
        headsTex.minFilter = THREE.LinearFilter;
        headsTex.magFilter = THREE.LinearFilter;
        headsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
        headsTex.generateMipmaps = false;
        
        textureLoader.load(defaultCoin.tailsImage, (tailsTex) => {
          tailsTex.minFilter = THREE.LinearFilter;
          tailsTex.magFilter = THREE.LinearFilter;
          tailsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
          tailsTex.generateMipmaps = false;
          
          // Update both textures
          coin.material[1].uniforms.map.value = headsTex;
          coin.material[1].needsUpdate = true;
          coin.material[2].uniforms.map.value = tailsTex;
          coin.material[2].needsUpdate = true;
          coin.visible = true;
          
          console.log(`âœ… Applied default ${defaultCoin.name} textures to ${player.name}'s coin`);
        });
      });
      
      // Update coin edge color based on default material
      const edgeColor = new THREE.Color(defaultMaterial.edgeColor);
      coin.material[0].color.copy(edgeColor);
      coin.material[0].emissive.copy(edgeColor);
      coin.material[0].emissiveIntensity = 0.3;
      coin.material[0].needsUpdate = true;
      
      console.log(`âœ… Applied default ${defaultCoin.name} with ${defaultMaterial.name} material to ${player.name}'s coin`);

      tubes.push({ 
        tube, backing, topRim, bottomRim, liquid, liquidLight, spotlight, platform, coin,
        coinShadow, // Dark backdrop for coin visibility
        liquidParticles, // Physics bodies (pearls)
        liquidParticleMeshes, // Visual meshes
        glassBody, // Container collision
        cardElement, // Store card element for power bar updates
        powerButton, // Store power button for enable/disable
        particleRadius: pRadius, // Store particle size
        liquidBaseY: liquidY,
        liquidBaseHeight: liquidHeight,
        isFilling: false,
        power: 0, // Power level (0-100)
        isShattered: false, // Glass shattered state
        isFlipping: false, // Coin flip state
        glassShards: [], // Will hold glass shards when shattered
        winLight: null, // Win glow light
        loseLight: null, // Lose glow light
        resultBox: null, // Result text CSS3D object
        foamIntensity: 0, // Bubbling/frothing intensity (0-1)
        hasUsedPower: false, // Track if player has used their turn
        selectedCoin: defaultCoin, // Default to Classic coin
        selectedMaterial: defaultMaterial // Default to Graphite material
      });
    }

    // ===== APPLY DEFAULT COIN SELECTIONS ON GAME START =====
    console.log('ðŸŽ® Game started - applying default coin selections to all players...');
    
    tubes.forEach((tube, tubeIndex) => {
      const player = players[tubeIndex];
      const defaultCoin = tube.selectedCoin;
      const defaultMaterial = tube.selectedMaterial;
      
      // Apply default material edge color
      const edgeColor = new THREE.Color(defaultMaterial.edgeColor);
      tube.coin.material[0].color.copy(edgeColor);
      tube.coin.material[0].emissive.copy(edgeColor);
      tube.coin.material[0].emissiveIntensity = 0.3;
      tube.coin.material[0].needsUpdate = true;
      
      // Load and apply default coin textures
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(defaultCoin.headsImage, (headsTex) => {
        headsTex.minFilter = THREE.LinearFilter;
        headsTex.magFilter = THREE.LinearFilter;
        headsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
        headsTex.generateMipmaps = false;
        
        textureLoader.load(defaultCoin.tailsImage, (tailsTex) => {
          tailsTex.minFilter = THREE.LinearFilter;
          tailsTex.magFilter = THREE.LinearFilter;
          tailsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
          tailsTex.generateMipmaps = false;
          
          // Update both textures
          tube.coin.material[1].uniforms.map.value = headsTex;
          tube.coin.material[1].needsUpdate = true;
          tube.coin.material[2].uniforms.map.value = tailsTex;
          tube.coin.material[2].needsUpdate = true;
          
          console.log(`âœ… Applied default ${defaultCoin.name} with ${defaultMaterial.name} material to ${player.name}'s coin`);
        });
      });
    });

    // ===== CREATE GAME INFO CONTAINER (Round + Timer + Controls) =====
    const gameInfoDiv = document.createElement('div');
    gameInfoDiv.style.cssText = `
      width: 200px;
      background: rgba(10, 15, 35, 0.95);
      border: 3px solid #9d00ff;
      border-radius: 16px;
      padding: 15px;
      font-family: 'Orbitron', sans-serif;
      color: white;
      box-shadow: 0 0 30px rgba(157, 0, 255, 0.6);
      pointer-events: auto;
      text-align: center;
    `;
    
    gameInfoDiv.innerHTML = `
      <!-- Round Counter -->
      <div style="
        font-size: 18px;
        font-weight: bold;
        color: #00ffff;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 10px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      ">ROUND <span id="round-number">1</span></div>
      
      <!-- Timer Display -->
      <div style="
        font-size: 50px;
        font-weight: bold;
        color: #00ff00;
        margin: 5px 0;
        font-family: 'Orbitron', monospace;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      " id="timer-display">30</div>
      <div style="
        font-size: 12px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 10px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      ">SECONDS</div>
      
      <!-- Control Buttons Column -->
      <div style="
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 10px;
      ">
        <!-- Mute Button -->
        <button id="mute-btn" style="
          width: 100%;
          padding: 8px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          border: 2px solid #9d00ff;
          border-radius: 8px;
          color: white;
          font-weight: bold;
          font-size: 13px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-transform: uppercase;
          letter-spacing: 1px;
          box-shadow: 0 0 15px rgba(157, 0, 255, 0.4);
        ">ðŸ”Š MUTE</button>
        
        <!-- Chat Button -->
        <button id="chat-btn" style="
          width: 100%;
          padding: 8px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          border: 2px solid #9d00ff;
          border-radius: 8px;
          color: white;
          font-weight: bold;
          font-size: 13px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-transform: uppercase;
          letter-spacing: 1px;
          box-shadow: 0 0 15px rgba(157, 0, 255, 0.4);
        ">ðŸ’¬ CHAT</button>
      </div>
    `;
    
    const gameInfoObject = new CSS3DObject(gameInfoDiv);
    gameInfoObject.position.set(0, 200 - (TUBE_HEIGHT / 2) - 160, 0);
    gameInfoObject.scale.set(0.5, 0.5, 0.5);
    scene.add(gameInfoObject);

    // Get element references
    roundCounterElement = gameInfoDiv;
    timerElement = gameInfoDiv;
    const timerDisplay = gameInfoDiv.querySelector('#timer-display');
    const muteBtn = gameInfoDiv.querySelector('#mute-btn');
    const chatBtn = gameInfoDiv.querySelector('#chat-btn');

    // Add hover effects to buttons
    [muteBtn, chatBtn].forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.transform = 'translateY(-2px)';
        btn.style.boxShadow = '0 5px 20px rgba(157, 0, 255, 0.8)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.transform = 'translateY(0)';
        btn.style.boxShadow = '0 0 15px rgba(157, 0, 255, 0.4)';
      });
    });

    // Mute button handler
    muteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const muted = toggleMute();
      
      // Update button text and style
      if (muted) {
        muteBtn.textContent = 'ðŸ”‡ UNMUTE';
        muteBtn.style.background = 'linear-gradient(135deg, #666666, #888888)';
        muteBtn.style.borderColor = '#666666';
      } else {
        muteBtn.textContent = 'ðŸ”Š MUTE';
        muteBtn.style.background = 'linear-gradient(135deg, #9d00ff, #c44aff)';
        muteBtn.style.borderColor = '#9d00ff';
      }
    });

    chatBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (!gameIdParam) {
        alert('Chat unavailable: missing gameId');
        return;
      }
      // Build overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 320px;
        height: 420px;
        background: rgba(10, 15, 35, 0.98);
        border: 2px solid #9d00ff;
        border-radius: 12px;
        z-index: 10002;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
      const header = document.createElement('div');
      header.style.cssText = `
        padding: 10px 12px; color: #fff; font-weight: bold;
        background: linear-gradient(135deg, #9d00ff, #c44aff);
        display: flex; align-items: center; justify-content: space-between;
      `;
      header.innerHTML = `<span>Lobby Chat</span><button style="all: unset; cursor: pointer; font-weight: bold;">âœ–</button>`;
      const closeBtn = header.querySelector('button');
      closeBtn.onclick = () => overlay.remove();
      const list = document.createElement('div');
      list.style.cssText = `flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px;`;
      const inputRow = document.createElement('div');
      inputRow.style.cssText = `display: flex; gap: 6px; padding: 8px; background: rgba(255,255,255,0.05);`;
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Type message (read-only for now)';
      input.disabled = true;
      input.style.cssText = `flex:1; background: rgba(0,0,0,0.4); border: 1px solid #444; color: #fff; padding: 8px; border-radius: 8px;`;
      const sendBtn = document.createElement('button');
      sendBtn.textContent = 'Send';
      sendBtn.disabled = true;
      sendBtn.style.cssText = `padding: 8px 10px; color: #000; background: #ccc; border-radius: 8px; border: none; cursor: not-allowed;`;
      inputRow.appendChild(input);
      inputRow.appendChild(sendBtn);
      overlay.appendChild(header);
      overlay.appendChild(list);
      overlay.appendChild(inputRow);
      document.body.appendChild(overlay);

      try {
        const res = await fetch(`/api/chat/${encodeURIComponent(gameIdParam)}?limit=50`);
        if (res.ok) {
          const data = await res.json();
          const messages = data.messages || [];
          messages.forEach(m => {
            const row = document.createElement('div');
            row.style.cssText = `background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px; color:#fff;`;
            const name = m.username || (m.address ? m.address.slice(0,6)+'...'+m.address.slice(-4) : 'User');
            const content = m.message || '';
            row.innerHTML = `<div style="font-weight:bold; color:#9d00ff;">${name}</div><div style="font-size: 0.9rem;">${content}</div>`;
            list.appendChild(row);
          });
          list.scrollTop = list.scrollHeight;
        } else {
          const row = document.createElement('div');
          row.style.cssText = `padding:8px; color:#fff;`;
          row.textContent = 'Failed to load chat history';
          list.appendChild(row);
        }
      } catch (err) {
        const row = document.createElement('div');
        row.style.cssText = `padding:8px; color:#fff;`;
        row.textContent = 'Error loading chat history';
        list.appendChild(row);
      }
    });

    // ===== TIMER FUNCTIONS =====
    function startTimer() {
      if (timerInterval) return; // Already running
      
      console.log('â±ï¸ Timer started!');
      
      // Show game in progress indicator
      showGamePhaseIndicator('in_progress', `Round ${currentRound} - Choose your side!`);
      
      timerInterval = setInterval(() => {
        timeRemaining--;
        updateTimerDisplay();
        
        if (timeRemaining <= 0) {
          stopTimer();
          // Only auto-flip in local mode - server handles timing in server-side mode
          if (!isServerSideMode) {
            autoFlipCoins();
          }
        }
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function resetTimer() {
      stopTimer();
      timeRemaining = 30;
      updateTimerDisplay();
      console.log('â±ï¸ Timer reset');
    }

    function updateTimerDisplay() {
      timerDisplay.textContent = timeRemaining;
      
      // Change color based on time remaining
      if (timeRemaining <= 5) {
        timerDisplay.style.color = '#ff0000';
      } else if (timeRemaining <= 10) {
        timerDisplay.style.color = '#ffaa00';
      } else {
        timerDisplay.style.color = '#00ff00';
      }
    }

    function autoFlipCoins() {
      console.log('â±ï¸ TIME\'S UP! Auto-flipping all coins...');
      
      // Auto flip all tubes that haven't flipped yet (only for players with lives)
      tubes.forEach((tube, i) => {
        if (!tube.isFlipping && !tube.isShattered && players[i].lives > 0) {
          // Set power to 50% for auto-flip
          const autoPower = 50;
          tube.power = autoPower;
          
          // Shatter glass
          shatterGlass(i, autoPower);
          
          // Get player choice (or default to heads if none selected)
          const playerChoice = players[i].choice || 'heads';
          
          // Start coin flip
          flipCoinWithPower(i, autoPower, playerChoice);
        }
      });
      
      // Game progression is now handled by checkAllPlayersFlipped() after each coin lands
    }

    function nextRound() {
      currentRound++;
      const roundNumber = roundCounterElement.querySelector('#round-number');
      if (roundNumber) {
        roundNumber.textContent = currentRound;
      }
      
      console.log(`ðŸ“Š Starting Round ${currentRound}`);
      
      // Track starting lives for this round
      roundStartLives = players.map(player => player.lives);
      console.log(`ðŸ“Š Round ${currentRound} starting lives:`, roundStartLives);
      
      // Reset round state
      allPlayersFlipped = false;
      if (roundEndTimer) {
        clearTimeout(roundEndTimer);
        roundEndTimer = null;
      }
      
      resetRound();
      resetTimer();
      startTimer();
    }

    // Coin selector modal
    function showCoinSelector(tubeIndex) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 20px;
      `;

      const content = document.createElement('div');
      content.style.cssText = `
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #FFD700;
        border-radius: 15px;
        padding: 40px 50px;
        width: 95%;
        max-width: 1600px;
        max-height: 85vh;
        overflow-y: auto;
      `;

      content.innerHTML = `
        <h2 style="color: #FFD700; text-align: center; margin-bottom: 35px; font-family: 'Orbitron', sans-serif; font-size: 1.8rem;">Customize Your Coin</h2>
        
        <!-- Coin Design Section -->
        <h3 style="color: #FFD700; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; font-size: 1.2rem;">Coin Design</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 15px; margin-bottom: 40px;">
          ${coinOptions.map(coin => `
            <div class="coin-option" data-coin-id="${coin.id}" style="
              background: rgba(255, 215, 0, 0.08);
              border: 2px solid rgba(255, 215, 0, 0.25);
              border-radius: 12px;
              padding: 15px;
              text-align: center;
              cursor: pointer;
              transition: all 0.3s ease;
            ">
              <img src="${coin.headsImage}" style="width: 65px; height: 65px; object-fit: contain; margin-bottom: 8px; display: block; margin-left: auto; margin-right: auto;" />
              <div style="color: #FFD700; font-weight: bold; font-family: 'Orbitron', sans-serif; font-size: 0.85rem;">${coin.name}</div>
            </div>
          `).join('')}
        </div>
        
        <!-- Material Selection Section -->
        <div style="height: 1px; background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent); margin: 30px 0;"></div>
        <h3 style="color: #FFD700; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; font-size: 1.2rem;">Coin Material</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 30px;">
          ${coinMaterials.map(material => `
            <div class="material-option" data-material-id="${material.id}" style="
              background: rgba(255, 255, 255, 0.05);
              border: 2px solid rgba(255, 255, 255, 0.15);
              border-radius: 12px;
              padding: 18px;
              cursor: pointer;
              transition: all 0.3s ease;
              text-align: center;
            ">
              <div style="
                width: 55px;
                height: 55px;
                border-radius: 50%;
                margin: 0 auto 12px;
                border: 3px solid ${material.edgeColor};
                background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3), rgba(0,0,0,0.2));
                box-shadow: 0 0 15px ${material.edgeColor}60;
              "></div>
              <div style="color: #fff; font-weight: bold; font-size: 1rem; margin-bottom: 6px;">${material.name}</div>
              <div style="color: ${material.edgeColor}; font-size: 0.8rem; margin-bottom: 8px;">${material.description}</div>
              <div style="color: #fff; font-size: 0.7rem; opacity: 0.7; line-height: 1.4;">${material.characteristics}</div>
            </div>
          `).join('')}
        </div>
        
        <button class="close-btn" style="
          width: 100%;
          max-width: 400px;
          margin: 20px auto 0;
          padding: 16px;
          background: linear-gradient(135deg, #ff1493, #ff69b4);
          border: none;
          border-radius: 12px;
          color: white;
          font-weight: bold;
          cursor: pointer;
          font-family: 'Orbitron', sans-serif;
          font-size: 1rem;
          letter-spacing: 1px;
          display: block;
          box-shadow: 0 4px 15px rgba(255, 20, 147, 0.4);
          transition: all 0.3s ease;
        ">APPLY CHANGES</button>
      `;

      modal.appendChild(content);
      document.body.appendChild(modal);
      
      let selectedCoin = tubes[tubeIndex].selectedCoin || coinOptions[0];
      let selectedMaterial = tubes[tubeIndex].selectedMaterial || coinMaterials[0]; // Default to graphite
      
      // Force reset to Graphite if material is invalid
      if (!selectedMaterial || !selectedMaterial.id || selectedMaterial.id !== 'graphite') {
        selectedMaterial = coinMaterials[0]; // Force to Graphite
        tubes[tubeIndex].selectedMaterial = selectedMaterial; // Update the stored material
        console.log(`ðŸ”§ Forced material reset to: ${selectedMaterial.name}`);
      }
      
      console.log(`ðŸŽ¨ Auto-selecting: Coin="${selectedCoin.name}", Material="${selectedMaterial.name}" (ID: ${selectedMaterial.id})`);
      
      // Auto-select the current coin and material in the modal - VISUALLY HIGHLIGHTED
      // Use setTimeout to ensure DOM elements are ready
      setTimeout(() => {
        const currentCoinOption = content.querySelector(`[data-coin-id="${selectedCoin.id}"]`);
        if (currentCoinOption) {
          currentCoinOption.style.background = 'rgba(255, 215, 0, 0.3)';
          currentCoinOption.style.borderColor = '#FFD700';
          currentCoinOption.style.transform = 'scale(1.05)'; // Make it slightly bigger to show it's selected
          console.log(`âœ… Auto-selected coin: ${selectedCoin.name}`);
        } else {
          console.log(`âŒ Could not find coin option for ID: ${selectedCoin.id}`);
        }
        
        const currentMaterialOption = content.querySelector(`[data-material-id="${selectedMaterial.id}"]`);
        if (currentMaterialOption) {
          currentMaterialOption.style.background = 'rgba(255, 215, 0, 0.2)';
          currentMaterialOption.style.borderColor = '#FFD700';
          currentMaterialOption.style.transform = 'scale(1.05)'; // Make it slightly bigger to show it's selected
          console.log(`âœ… Auto-selected material: ${selectedMaterial.name}`);
        } else {
          console.log(`âŒ Could not find material option for ID: ${selectedMaterial.id}`);
          console.log(`Available material IDs: ${coinMaterials.map(m => m.id).join(', ')}`);
        }
      }, 10); // Small delay to ensure DOM is ready

      // Add click handlers to coin design options
      content.querySelectorAll('.coin-option').forEach(option => {
        option.addEventListener('click', () => {
          const coinId = option.dataset.coinId;
          selectedCoin = coinOptions.find(c => c.id === coinId);
          
          // Update visual selection
          content.querySelectorAll('.coin-option').forEach(opt => {
            opt.style.background = 'rgba(255, 215, 0, 0.1)';
            opt.style.borderColor = 'rgba(255, 215, 0, 0.3)';
          });
          option.style.background = 'rgba(255, 215, 0, 0.3)';
          option.style.borderColor = '#FFD700';
          
          console.log(`Coin design selected:`, selectedCoin.name);
        });
        
        // Hover effect
        option.addEventListener('mouseenter', () => {
          if (selectedCoin.id !== option.dataset.coinId) {
            option.style.background = 'rgba(255, 215, 0, 0.2)';
            option.style.transform = 'scale(1.05)';
          } else {
            // Already selected - make it even more prominent on hover
            option.style.background = 'rgba(255, 215, 0, 0.4)';
            option.style.transform = 'scale(1.1)';
          }
        });
        option.addEventListener('mouseleave', () => {
          if (selectedCoin.id !== option.dataset.coinId) {
            option.style.background = 'rgba(255, 215, 0, 0.1)';
            option.style.transform = 'scale(1)';
          } else {
            // Already selected - return to selected state
            option.style.background = 'rgba(255, 215, 0, 0.3)';
            option.style.transform = 'scale(1.05)';
          }
        });
      });
      
      // Add click handlers to material options
      content.querySelectorAll('.material-option').forEach(option => {
        option.addEventListener('click', () => {
          const materialId = option.dataset.materialId;
          selectedMaterial = coinMaterials.find(m => m.id === materialId);
          
          // Update visual selection
          content.querySelectorAll('.material-option').forEach(opt => {
            opt.style.background = 'rgba(255, 255, 255, 0.05)';
            opt.style.borderColor = 'rgba(255, 255, 255, 0.2)';
          });
          option.style.background = 'rgba(255, 215, 0, 0.2)';
          option.style.borderColor = '#FFD700';
          
          console.log(`Material selected:`, selectedMaterial.name);
        });
        
        // Hover effect
        option.addEventListener('mouseenter', () => {
          if (selectedMaterial.id !== option.dataset.materialId) {
            option.style.background = 'rgba(255, 255, 255, 0.1)';
            option.style.transform = 'scale(1.05)';
          } else {
            // Already selected - make it even more prominent on hover
            option.style.background = 'rgba(255, 215, 0, 0.3)';
            option.style.transform = 'scale(1.1)';
          }
        });
        option.addEventListener('mouseleave', () => {
          if (selectedMaterial.id !== option.dataset.materialId) {
            option.style.background = 'rgba(255, 255, 255, 0.05)';
            option.style.transform = 'scale(1)';
          } else {
            // Already selected - return to selected state
            option.style.background = 'rgba(255, 215, 0, 0.2)';
            option.style.transform = 'scale(1.05)';
          }
        });
      });
      
      // Apply button handler
      const closeBtn = content.querySelector('.close-btn');
      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.transform = 'translateY(-2px)';
        closeBtn.style.boxShadow = '0 6px 20px rgba(255, 20, 147, 0.6)';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.transform = 'translateY(0)';
        closeBtn.style.boxShadow = '0 4px 15px rgba(255, 20, 147, 0.4)';
      });
      closeBtn.addEventListener('click', () => {
        // Store selections in tube
        tubes[tubeIndex].selectedCoin = selectedCoin;
        tubes[tubeIndex].selectedMaterial = selectedMaterial;
        
        // Load both heads and tails textures
        const loader = new THREE.TextureLoader();
        loader.load(selectedCoin.headsImage, (headsTexture) => {
          headsTexture.minFilter = THREE.LinearFilter;
          headsTexture.magFilter = THREE.LinearFilter;
          headsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
          headsTexture.generateMipmaps = false;
          
          loader.load(selectedCoin.tailsImage, (tailsTexture) => {
            tailsTexture.minFilter = THREE.LinearFilter;
            tailsTexture.magFilter = THREE.LinearFilter;
            tailsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
            tailsTexture.generateMipmaps = false;
            
            // Update shader uniforms
            tubes[tubeIndex].coin.material[1].uniforms.map.value = headsTexture;
            tubes[tubeIndex].coin.material[1].needsUpdate = true;
            tubes[tubeIndex].coin.material[2].uniforms.map.value = tailsTexture;
            tubes[tubeIndex].coin.material[2].needsUpdate = true;
            
            // Update coin edge color based on material
            const edgeColor = new THREE.Color(selectedMaterial.edgeColor);
            tubes[tubeIndex].coin.material[0].color.copy(edgeColor);
            tubes[tubeIndex].coin.material[0].emissive.copy(edgeColor);
            tubes[tubeIndex].coin.material[0].emissiveIntensity = 0.3;
            tubes[tubeIndex].coin.material[0].needsUpdate = true;
            
            console.log(`âœ… Applied ${selectedCoin.name} with ${selectedMaterial.name} material to ${players[tubeIndex].name}'s coin`);
            
            // Send coin update to server
            if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === tubeIndex) {
              socket.emit('physics_update_coin', {
                gameId: gameIdParam,
                address: walletParam,
                coinData: {
                  id: selectedCoin.id,
                  type: selectedCoin.type,
                  name: selectedCoin.name,
                  headsImage: selectedCoin.headsImage,
                  tailsImage: selectedCoin.tailsImage,
                  material: selectedMaterial
                }
              });
              console.log(`ðŸŽ¯ Sent coin update to server: ${selectedCoin.name}`);
            }
          });
        });
        
        modal.remove();
      });

      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    }

    // ===== GLASS SHATTERING FUNCTION (POWER-BASED) =====
    function shatterGlass(tubeIndex, powerLevel) {
      const tube = tubes[tubeIndex];
      if (tube.isShattered) return;
      
      const powerPercent = powerLevel / 100;
      console.log(`ðŸ’¥ Shattering glass for tube ${tubeIndex + 1} at ${powerLevel.toFixed(0)}% power`);
      
      // Stop power charging sound and play glass breaking sound
      stopSound(powerChargeSound);
      playSound(glassBreakSound);
      
      tube.isShattered = true;
      
      // Hide glass tube, backing, rims, and liquid surface
      tube.tube.visible = false;
      tube.backing.visible = false;
      tube.topRim.visible = false;
      tube.bottomRim.visible = false;
      tube.liquid.visible = false; // Hide the transparent liquid surface mesh
      
      // Show dark shadow behind coin for better visibility
      tube.coinShadow.visible = true;
      
      // REMOVE PHYSICS CONTAINER so particles can escape
      physicsWorld.removeBody(tube.glassBody);
      
      // Shard count scales with power (20-80 shards)
      const shardCount = Math.floor(20 + (powerPercent * 60));
      const tubeY = 200;
      
      for (let s = 0; s < shardCount; s++) {
        // Random triangle shard
        const size = Math.random() * 12 + 5;
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0, 0, 0,
          size, 0, 0,
          size * 0.5, size, 0
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        const material = new THREE.MeshStandardMaterial({
          color: 0xe0e0e0, // Bright silver
          metalness: 0.95, // Very metallic silver
          roughness: 0.1,
          emissive: 0xc0c0c0, // Silver glow
          emissiveIntensity: 0.4,
          side: THREE.DoubleSide
        });
        
        const shard = new THREE.Mesh(geometry, material);
        
        // Position along tube surface
        const angle = (s / shardCount) * Math.PI * 2;
        const heightPos = (Math.random() - 0.5) * TUBE_HEIGHT;
        shard.position.set(
          tube.tube.position.x + Math.cos(angle) * TUBE_RADIUS,
          tubeY + heightPos,
          Math.sin(angle) * TUBE_RADIUS
        );
        
        // Random rotation
        shard.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        // Explode velocity SCALES WITH POWER (2-14 units/frame)
        const baseSpeed = 2 + (powerPercent * 12);
        const velocity = {
          x: Math.cos(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5),
          y: Math.random() * 3 - 1.5,
          z: Math.sin(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5)
        };
        
        const rotVelocity = {
          x: (Math.random() - 0.5) * 0.3,
          y: (Math.random() - 0.5) * 0.3,
          z: (Math.random() - 0.5) * 0.3
        };
        
        scene.add(shard);
        
        tube.glassShards.push({
          mesh: shard,
          velocity,
          rotVelocity,
          lifetime: 0
        });
      }
      
      // EXPLODE LIQUID PARTICLES (FORCE SCALES WITH POWER)
      tube.liquidParticles.forEach((particleBody, idx) => {
        // Calculate outward direction
        const dx = particleBody.position.x - tube.tube.position.x;
        const dz = particleBody.position.z - tube.tube.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz) || 1;
        
        // Explosion force scales with power (2000-18000)
        const baseForce = 2000 + (powerPercent * 16000);
        const explosionForce = baseForce + Math.random() * (baseForce * 0.3);
        
        particleBody.velocity.set(
          (dx / distance) * explosionForce,
          Math.random() * 800 - 400,
          (dz / distance) * explosionForce
        );
        
        // Spinning scales with power
        const spinForce = 15 * powerPercent;
        particleBody.angularVelocity.set(
          Math.random() * spinForce * 2 - spinForce,
          Math.random() * spinForce * 2 - spinForce,
          Math.random() * spinForce * 2 - spinForce
        );
      });
      
      console.log(`ðŸ’¥ Glass shattered! ${shardCount} shards + ${tube.liquidParticles.length} liquid particles at ${powerLevel.toFixed(0)}% power`);
    }

    // ===== FLIP TOKEN REWARD SYSTEM =====
    const FLIP_REWARDS = [
      { amount: 50, color: '#ffffff', weight: 40 },      // White - Very common
      { amount: 100, color: '#87ceeb', weight: 25 },     // Sky blue - Common
      { amount: 250, color: '#ffff00', weight: 15 },     // Yellow - Uncommon
      { amount: 300, color: '#00ff00', weight: 10 },     // Green - Uncommon
      { amount: 500, color: '#ff8800', weight: 5 },      // Orange - Rare
      { amount: 750, color: '#9d00ff', weight: 3 },      // Purple - Very rare
      { amount: 1000, color: '#FFD700', weight: 2 }      // Gold - Extremely rare
    ];

    // Weighted random reward selection
    function getRandomFlipReward() {
      const totalWeight = FLIP_REWARDS.reduce((sum, r) => sum + r.weight, 0);
      let random = Math.random() * totalWeight;
      
      for (const reward of FLIP_REWARDS) {
        random -= reward.weight;
        if (random <= 0) {
          return reward;
        }
      }
      
      return FLIP_REWARDS[0]; // Fallback to 50
    }

    // Show FLIP reward animation as floating box above tube
    function showFlipReward(tubeIndex, serverReward = null) {
      const tube = tubes[tubeIndex];
      const player = players[tubeIndex];
      
      // Only reward if player still has lives
      if (player.lives <= 0) {
        console.log(`âŒ Player ${tubeIndex + 1} has no lives - no FLIP reward`);
        return;
      }
      
      // Use server-provided reward if available, otherwise fallback to local generation
      const reward = serverReward || getRandomFlipReward();
      console.log(`ðŸ’° Player ${tubeIndex + 1} earned ${reward.amount} FLIP!`);
      
      // Award FLIP tokens to player via server
      if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === tubeIndex) {
        socket.emit('award_flip_tokens', {
          gameId: gameIdParam,
          address: walletParam,
          amount: reward.amount,
          reason: 'coin_flip_reward'
        });
        console.log(`ðŸŽ¯ Sent FLIP token award to server: ${reward.amount} tokens`);
        
        // Update XP counter for current player
        updateXPCounter(reward.amount);
      }
      
      // Create floating reward box styled like win/lose boxes
      const rewardBox = document.createElement('div');
      rewardBox.style.cssText = `
        width: 200px;
        padding: 12px 18px;
        background: #0a0f2e;
        border: 3px solid ${reward.color};
        border-radius: 12px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        box-shadow: 0 0 40px ${reward.color}99;
        pointer-events: none;
        transform: scaleY(-1);
        backdrop-filter: blur(10px);
      `;
      
      rewardBox.innerHTML = `
        <div style="
          font-size: 28px;
          font-weight: bold;
          color: ${reward.color};
          text-transform: uppercase;
          letter-spacing: 2px;
          margin-bottom: 3px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          +${reward.amount} FLIP
        </div>
        <div style="
          font-size: 13px;
          color: #ffffff;
          text-transform: uppercase;
          letter-spacing: 1px;
          opacity: 0.9;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          Token Reward
        </div>
      `;
      
      const cssObject = new CSS3DObject(rewardBox);
      // Position ABOVE the tube (matching result box orientation pattern)
      const tubeTopY = 200 + (TUBE_HEIGHT / 2);
      cssObject.position.set(tube.tube.position.x, tubeTopY + 100, 0);
      cssObject.scale.set(0.5, 0.5, 0.5);
      scene.add(cssObject);
      
      tube.rewardBox = cssObject;
      
      // Animate appearance and float up
      rewardBox.style.opacity = '0';
      rewardBox.style.transform = 'scaleY(-1) scale(0.5) translateY(30px)';
      rewardBox.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
      
      // Pop in with bounce
      setTimeout(() => {
        rewardBox.style.opacity = '1';
        rewardBox.style.transform = 'scaleY(-1) scale(1) translateY(0px)';
      }, 50);
      
      // Float up and fade out after 1.5s (stay for 2 seconds total)
      setTimeout(() => {
        rewardBox.style.transition = 'all 0.5s ease-in';
        rewardBox.style.opacity = '0';
        rewardBox.style.transform = 'scaleY(-1) scale(1.1) translateY(-40px)';
      }, 1500);
      
      // Remove from scene after animation completes
      setTimeout(() => {
        scene.remove(cssObject);
      }, 2100);
    }

    // ===== COIN FLIP ANIMATION BASED ON POWER =====
    function flipCoinWithPower(tubeIndex, powerLevel, playerChoice) {
      const tube = tubes[tubeIndex];
      const coin = coins[tubeIndex];
      const powerPercent = powerLevel / 100;
      
      // Show FLIP reward immediately when flip starts
      showFlipReward(tubeIndex);
      
      // Get material multipliers
      const material = tube.selectedMaterial || coinMaterials[2]; // Default to glass
      const speedMult = material.speedMultiplier;
      const durationMult = material.durationMultiplier;
      
      // Duration scales with power (2s - 8s) AND material
      const baseDuration = 2000 + (powerPercent * 6000);
      const flipDuration = baseDuration * durationMult;
      
      // Flip speed scales with power (0.08 - 0.3 rad/frame) AND material
      // Minimum 0.08 to ensure coin always visibly flips
      const basePowerSpeed = Math.max(0.08, 0.05 + (powerPercent * 0.25));
      const baseFlipSpeed = basePowerSpeed * speedMult;
      
      console.log(`ðŸª™ Material: ${material.name} - Speed: ${speedMult}x, Duration: ${durationMult}x`);
      
      // Random result (50/50 heads or tails)
      const result = Math.random() < 0.5 ? 'heads' : 'tails';
      
      // Check if player won
      const didWin = playerChoice === result;
      
      console.log(`ðŸª™ Flipping coin ${tubeIndex + 1} for ${flipDuration.toFixed(0)}ms at speed ${baseFlipSpeed.toFixed(3)} - Result: ${result}, Choice: ${playerChoice}, Won: ${didWin}`);
      
      const startTime = Date.now();
      
      // Calculate target rotation - Standing on edge facing camera
      // For heads: rotation.x should be at Ï€/2 (standing on edge, heads facing camera)
      // For tails: rotation.x should be at 3Ï€/2 (standing on edge, tails facing camera)
      const targetRotationX = result === 'heads' ? Math.PI / 2 : (3 * Math.PI / 2);
      
      tube.isFlipping = true;
      
      const animateFlip = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / flipDuration, 1);
        
        if (progress < 0.7) {
          // Fast spinning phase (first 70%)
          coin.rotation.x += baseFlipSpeed;
        } else {
          // Deceleration phase (last 30%) - slow down gradually
          const decelProgress = (progress - 0.7) / 0.3; // 0 to 1 over last 30%
          
          // Gradually reduce flip speed to zero
          const currentSpeed = baseFlipSpeed * (1 - decelProgress);
          coin.rotation.x += currentSpeed;
          
          // In final moments, lock to target rotation
          if (decelProgress > 0.8) {
            const lockProgress = (decelProgress - 0.8) / 0.2;
            const currentCycles = Math.floor(coin.rotation.x / (Math.PI * 2));
            const targetX = currentCycles * (Math.PI * 2) + targetRotationX;
            coin.rotation.x = coin.rotation.x + (targetX - coin.rotation.x) * lockProgress;
          }
        }
        
        if (progress < 1) {
          requestAnimationFrame(animateFlip);
        } else {
          // Final landing - ensure exact position
          const finalCycles = Math.floor(coin.rotation.x / (Math.PI * 2));
          coin.rotation.x = finalCycles * (Math.PI * 2) + targetRotationX;
          coin.rotation.y = Math.PI / 2;
          coin.rotation.z = 0;
          
          tube.isFlipping = false;
          console.log(`âœ… Coin ${tubeIndex + 1} landed on ${result} facing camera`);
          
          // Show result after landing
          showResult(tubeIndex, didWin, result);
        }
      };
      
      animateFlip();
    }

    // ===== UPDATE LIVES DISPLAY =====
    function updateLivesDisplay(tubeIndex) {
      const player = players[tubeIndex];
      const tube = tubes[tubeIndex];
      
      if (!tube.cardElement) return;
      
      // Find all life elements in the card
      const lifeElements = tube.cardElement.querySelectorAll('.life');
      
      // Update each life element based on current lives
      lifeElements.forEach((lifeElement, idx) => {
        const heartDiv = lifeElement.querySelector('div');
        if (idx < player.lives) {
          // This life should be active
          lifeElement.classList.add('active');
          if (heartDiv) heartDiv.style.color = '#ff4444'; // Red heart
        } else {
          // This life should be inactive (lost)
          lifeElement.classList.remove('active');
          if (heartDiv) heartDiv.style.color = '#666'; // Gray heart
        }
      });
      
      // Handle eliminated player (0 lives)
      if (player.lives <= 0) {
        // Replace choice area with eliminated indicator
        const choiceContainer = tube.cardElement.querySelector('.choice-buttons, .choice-badge');
        if (choiceContainer) {
          choiceContainer.outerHTML = `
            <div style="
              display: flex;
              align-items: center;
              justify-content: center;
              width: 100%;
              height: 60px;
              background: linear-gradient(135deg, #ff1493, #ff69b4);
              border: 3px solid #ff1493;
              border-radius: 12px;
              box-shadow: 0 0 20px rgba(255, 20, 147, 0.8);
              animation: pulse 2s infinite;
            ">
              <div style="
                font-size: 36px;
                font-weight: bold;
                color: white;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                font-family: 'Orbitron', sans-serif;
              ">
                âŒ
              </div>
            </div>
          `;
        }
        
        // Disable power button
        const powerButton = tube.cardElement.querySelector('.action-btn');
        if (powerButton) {
          powerButton.disabled = true;
          powerButton.style.opacity = '0.3';
          powerButton.style.cursor = 'not-allowed';
          powerButton.style.background = '#666666';
          powerButton.style.color = '#999999';
          powerButton.style.borderColor = '#666666';
          powerButton.textContent = 'ELIMINATED';
        }
        
        console.log(`âŒ Player ${tubeIndex + 1} ELIMINATED - showing neon pink X`);
      }
      
      console.log(`ðŸ’Š Updated lives display for player ${tubeIndex + 1}: ${player.lives} lives remaining`);
    }

    // ===== SHOW WIN/LOSE RESULT =====
    function showResult(tubeIndex, didWin, result) {
      const tube = tubes[tubeIndex];
      const coin = coins[tubeIndex];
      const player = players[tubeIndex];
      
      // Add green glow if won
      if (didWin) {
        // Create green point light
        const winLight = new THREE.PointLight(0x00ff00, 8, 200);
        winLight.position.set(0, 0, 0);
        coin.add(winLight);
        tube.winLight = winLight;
        
        // Make coin glow green
        coin.children.forEach(child => {
          if (child.isLight && child !== winLight) {
            child.color.setHex(0x00ff00);
            child.intensity = 6;
          }
        });
        
        console.log(`ðŸŽ‰ Player ${tubeIndex + 1} WON! Lives remain: ${player.lives}`);
      } else {
        // Red glow for loss
        const loseLight = new THREE.PointLight(0xff0000, 6, 200);
        loseLight.position.set(0, 0, 0);
        coin.add(loseLight);
        tube.loseLight = loseLight;
        
        // Decrease lives when player loses
        if (player.lives > 0) {
          player.lives--;
          console.log(`ðŸ’” Player ${tubeIndex + 1} LOST - Lives remaining: ${player.lives}`);
          
          // Update lives display in card
          updateLivesDisplay(tubeIndex);
        }
      }
      
      // Create result text box (CSS3D)
      const resultBox = document.createElement('div');
      resultBox.style.cssText = `
        width: 300px;
        padding: 20px;
        background: ${didWin ? 'linear-gradient(135deg, #004d00, #003300)' : 'linear-gradient(135deg, #1a0000, #0d0000)'};
        border: 3px solid ${didWin ? '#00ff00' : '#ff0000'};
        border-radius: 16px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        box-shadow: 0 0 30px ${didWin ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 0, 0, 0.6)'};
        pointer-events: none;
      `;
      
      resultBox.innerHTML = `
        <div style="
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
          margin-bottom: 10px;
        ">
          <img src="/images/potion.png" style="width: 40px; height: 40px; object-fit: contain; ${didWin ? '' : 'filter: grayscale(100%) brightness(0.5);'}" />
          <div style="
            font-size: 30px;
            font-weight: bold;
            color: ${didWin ? '#00ff00' : '#ff0000'};
            text-transform: uppercase;
            letter-spacing: 2px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          ">
            ${didWin ? 'ROUND WON!' : 'YOU LOST'}
          </div>
        </div>
        <div style="
          font-size: 20px;
          color: #ffffff;
          text-transform: uppercase;
          letter-spacing: 2px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          Result: ${result.toUpperCase()}
        </div>
      `;
      
      const cssObject = new CSS3DObject(resultBox);
      // Position below coin, matching the tube's X position
      cssObject.position.set(tube.tube.position.x, coin.position.y - 100, 0);
      cssObject.scale.set(0.5, 0.5, 0.5);
      scene.add(cssObject);
      
      tube.resultBox = cssObject;
      
      // Animate result box appearing
      resultBox.style.opacity = '0';
      resultBox.style.transition = 'all 0.5s ease-out';
      
      setTimeout(() => {
        resultBox.style.opacity = '1';
        
        // Check if all players have flipped after this coin lands
        setTimeout(() => {
          checkAllPlayersFlipped();
        }, 500); // Small delay to ensure the flip animation is complete
      }, 50);
    }

    // ===== GAME ENDING LOGIC =====
    
    // Check if all players have completed their flips
    function checkAllPlayersFlipped() {
      // Only check players who still have lives
      const playersWithLives = players.filter(player => player.lives > 0);
      const tubesWithLives = playersWithLives.map(player => {
        const playerIndex = players.findIndex(p => p.id === player.id);
        return tubes[playerIndex];
      });
      
      // Check if ALL living players have completed their flips (shattered glass means they flipped)
      const allFlipped = tubesWithLives.every(tube => tube.isShattered);
      
      console.log(`ðŸ” Checking all players flipped: ${allFlipped ? 'YES' : 'NO'} (${tubesWithLives.filter(t => t.isShattered).length}/${tubesWithLives.length} players done)`);
      
      if (allFlipped && !allPlayersFlipped) {
        allPlayersFlipped = true;
        console.log('ðŸŽ¯ ALL living players have completed their flips! Starting 5-second countdown to next round...');
        
        // Set timer to check game end after 5 seconds
        if (roundEndTimer) clearTimeout(roundEndTimer);
        roundEndTimer = setTimeout(() => {
          checkGameEnd();
        }, 5000);
      }
    }
    
    // Check if game should end
    function checkGameEnd() {
      if (gameOver) return;
      
      const remainingPlayers = players.filter(player => player.lives > 0);
      console.log(`ðŸ” Checking game end... Remaining players: ${remainingPlayers.length}`);
      
      if (remainingPlayers.length <= 1) {
        if (remainingPlayers.length === 1) {
          // We have a winner!
          const winner = remainingPlayers[0];
          const winnerIndex = players.findIndex(p => p.id === winner.id);
          declareWinner(winnerIndex);
        } else {
          // No players left - this should never happen with proper game mechanics
          // If it does, find the last player who was eliminated (highest lives when they lost)
          console.log('âš ï¸ No players remaining - finding last eliminated player as winner');
          const lastEliminated = players.reduce((last, player, index) => {
            const tube = tubes[index];
            // Find the player who was eliminated most recently (has loseLight)
            if (tube && tube.loseLight) {
              return { player, index };
            }
            return last;
          }, null);
          
          if (lastEliminated) {
            console.log(`ðŸ† Declaring last eliminated player as winner: ${lastEliminated.player.name}`);
            declareWinner(lastEliminated.index);
          } else {
            // Fallback: declare first player as winner (shouldn't happen)
            console.log('âš ï¸ Fallback: declaring first player as winner');
            declareWinner(0);
          }
        }
        return;
      }
      
      // Check for special replay condition: all remaining players STARTED with 1 life and all lost this round
      if (roundStartLives.length > 0) {
        // Find players who started this round with 1 life and are still alive
        const oneLifeStarters = players.filter((player, index) => 
          player.lives > 0 && roundStartLives[index] === 1
        );
        
        // Check if all remaining players started with 1 life and all lost this round
        if (oneLifeStarters.length === remainingPlayers.length && oneLifeStarters.length >= 2) {
          const allOneLifeLost = oneLifeStarters.every(player => {
            const playerIndex = players.findIndex(p => p.id === player.id);
            const tube = tubes[playerIndex];
            // Check if they lost this round by seeing if they have loseLight
            return tube && tube.loseLight;
          });
          
          if (allOneLifeLost) {
            console.log('ðŸ”„ SPECIAL REPLAY: All remaining players started with 1 life and all lost this round! Replaying this round...');
            specialReplayRound();
            return;
          }
        }
      }
      
      // Additional safety check: if we have 2+ players with 1 life and they all lost, 
      // we need to ensure there's always a winner by implementing a "sudden death" mechanism
      const oneLifePlayers = remainingPlayers.filter(player => player.lives === 1);
      if (oneLifePlayers.length >= 2) {
        const allOneLifeLost = oneLifePlayers.every(player => {
          const playerIndex = players.findIndex(p => p.id === player.id);
          const tube = tubes[playerIndex];
          return tube && tube.loseLight;
        });
        
        if (allOneLifeLost) {
          console.log('ðŸ”„ SUDDEN DEATH: All 1-life players lost - implementing sudden death round...');
          suddenDeathRound();
          return;
        }
      }
      
      // Normal progression to next round
      console.log('âž¡ï¸ Proceeding to next round...');
      nextRound();
    }
    
    // Declare winner and end game
    function declareWinner(winnerIndex) {
      gameOver = true;
      stopTimer();
      
      if (roundEndTimer) {
        clearTimeout(roundEndTimer);
        roundEndTimer = null;
      }
      
      console.log('ðŸ† GAME OVER!');
      
      // Ensure there's always a valid winner
      let finalWinnerIndex = winnerIndex;
      let finalWinnerName = null;
      
      if (winnerIndex >= 0 && players[winnerIndex]) {
        const winner = players[winnerIndex];
        finalWinnerName = winner.name;
        console.log(`ðŸŽ‰ WINNER: ${winner.name} (Player ${winnerIndex + 1})`);
      } else {
        // Fallback: find any player as winner (shouldn't happen with new logic)
        console.log('âš ï¸ Invalid winner index, finding fallback winner');
        const fallbackPlayer = players.find(p => p.lives >= 0);
        if (fallbackPlayer) {
          finalWinnerIndex = players.findIndex(p => p.id === fallbackPlayer.id);
          finalWinnerName = fallbackPlayer.name;
          console.log(`ðŸŽ‰ FALLBACK WINNER: ${fallbackPlayer.name} (Player ${finalWinnerIndex + 1})`);
        } else {
          // Last resort: create a default winner
          finalWinnerName = 'Champion';
          finalWinnerIndex = 0;
          console.log('ðŸŽ‰ DEFAULT WINNER: Champion');
        }
      }
      
      showGameOverScreen(finalWinnerIndex, finalWinnerName);
    }
    
    // Sudden death round - when all 1-life players lose, they get one more chance
    function suddenDeathRound() {
      console.log('âš¡ Sudden death round initiated!');
      
      // Reset round state for sudden death
      tubes.forEach((tube, i) => {
        // Reset player choice for sudden death
        players[i].choice = null;
        
        // Reset choice buttons in card - replace badge with buttons
        if (tube.cardElement) {
          const choiceBadge = tube.cardElement.querySelector('.choice-badge');
          if (choiceBadge) {
            choiceBadge.outerHTML = `
              <div class="choice-buttons">
                <button class="choice-btn heads">HEADS</button>
                <button class="choice-btn tails">TAILS</button>
              </div>
            `;
            
            // Re-attach click handlers to new buttons
            const choiceButtons = tube.cardElement.querySelectorAll('.choice-btn');
            choiceButtons.forEach(btn => {
              btn.style.pointerEvents = 'auto';
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Don't allow choices if player has no lives
                if (players[i].lives <= 0) {
                  console.log(`âŒ Player ${i + 1} has no lives - cannot make choice`);
                  return;
                }
                
                const choice = btn.textContent.toLowerCase();
                players[i].choice = choice;
                console.log(`Player ${i + 1} selected: ${choice}`);
                
                // Update coin rotation immediately
                updateCoinRotationsFromPlayerChoices();
                
                // Update button states
                choiceButtons.forEach(b => b.style.opacity = '0.3');
                btn.style.opacity = '1';
                btn.style.borderColor = '#00ff00';
              });
            });
          }
        }
        
        // Clear result indicators
        if (tube.resultBox) {
          scene.remove(tube.resultBox);
          tube.resultBox = null;
        }
        
        // Clear win/lose lights
        if (tube.winLight) {
          coin.remove(tube.winLight);
          tube.winLight = null;
        }
        if (tube.loseLight) {
          coin.remove(tube.loseLight);
          tube.loseLight = null;
        }
        
        // Reset coin to neutral state
        const coin = coins[i];
        if (coin) {
          coin.children.forEach(child => {
            if (child.isLight) {
              child.color.setHex(0xffffff);
              child.intensity = 2;
            }
          });
        }
        
        // Reset glass state
        tube.isShattered = false;
        tube.isFlipping = false;
        tube.power = 0;
        tube.isFilling = false;
        
        // Reset glass appearance
        if (tube.glassMaterial) {
          tube.glassMaterial.opacity = 0.3;
          tube.glassMaterial.transparent = true;
        }
      });
      
      // Reset round state
      allPlayersFlipped = false;
      
      // Show sudden death message
      showFloatingMessage('âš¡ SUDDEN DEATH ROUND!', '#ff4444', 3000);
      
      console.log('âš¡ Sudden death round ready - players must choose again!');
    }

    // Special replay round when all remaining players have 1 life and all lost
    function specialReplayRound() {
      console.log('ðŸ”„ Special replay round initiated!');
      
      // Reset round state but keep current round number
      tubes.forEach((tube, i) => {
        // Reset player choice for replay
        players[i].choice = null;
        
        // Reset choice buttons in card - replace badge with buttons
        if (tube.cardElement) {
          const choiceBadge = tube.cardElement.querySelector('.choice-badge');
          if (choiceBadge) {
            choiceBadge.outerHTML = `
              <div class="choice-buttons">
                <button class="choice-btn heads">HEADS</button>
                <button class="choice-btn tails">TAILS</button>
              </div>
            `;
            
            // Re-attach click handlers to new buttons
            const choiceButtons = tube.cardElement.querySelectorAll('.choice-btn');
            choiceButtons.forEach(btn => {
              btn.style.pointerEvents = 'auto';
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Don't allow choices if player has no lives
                if (players[i].lives <= 0) {
                  console.log(`âŒ Player ${i + 1} has no lives - cannot make choice`);
                  return;
                }
                
                const choice = btn.textContent.toLowerCase();
                players[i].choice = choice;
                
                // Update coin rotation immediately
                updateCoinRotationsFromPlayerChoices();
                
                // Send choice to server
                if (isServerSideMode && socket && gameIdParam && walletParam) {
                  socket.emit('physics_set_choice', {
                    gameId: gameIdParam,
                    address: walletParam,
                    choice: choice
                  });
                  console.log(`ðŸŽ¯ Sent choice to server (replay): ${choice}`);
                }
                
                // Replace buttons with choice badge
                const choiceButtonContainer = tube.cardElement.querySelector('.choice-buttons');
                if (choiceButtonContainer) {
                  choiceButtonContainer.outerHTML = `
                    <div class="choice-badge ${choice}">
                      ${choice.toUpperCase()}
                    </div>
                  `;
                }
              });
            });
          }
        }
        
        // Reset tube state for replay
        tube.isFlipping = false;
        tube.isShattered = false;
        tube.power = 0;
        
        // Remove result boxes and lights
        if (tube.resultBox) {
          scene.remove(tube.resultBox);
          tube.resultBox = null;
        }
        if (tube.winLight) {
          tube.coin.remove(tube.winLight);
          tube.winLight = null;
        }
        if (tube.loseLight) {
          tube.coin.remove(tube.loseLight);
          tube.loseLight = null;
        }
        
        // Reset coin position
        tube.coin.rotation.x = Math.PI / 2;
        tube.coin.rotation.y = Math.PI / 2;
        tube.coin.rotation.z = 0;
        
        // Reset glass
        if (tube.glassBody) {
          physicsWorld.removeBody(tube.glassBody);
        }
        tube.glassBody = new CANNON.Body({ mass: 0 });
        tube.glassBody.addShape(new CANNON.Cylinder(TUBE_RADIUS, TUBE_RADIUS, TUBE_HEIGHT, 8));
        tube.glassBody.position.set(tube.tube.position.x, 200, 0);
        physicsWorld.addBody(tube.glassBody);
        
        // Reset pearls to bottom
        tube.liquidParticles.forEach((particleBody, idx) => {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * (TUBE_RADIUS - 25);
          particleBody.position.set(
            tube.tube.position.x + Math.cos(angle) * radius,
            200 - (TUBE_HEIGHT / 2) + 30 + Math.random() * 60,
            Math.sin(angle) * radius
          );
          particleBody.velocity.set(0, 0, 0);
          particleBody.angularVelocity.set(0, 0, 0);
        });
      });
      
      // Reset round state
      allPlayersFlipped = false;
      
      // Show special replay message
      showSpecialReplayMessage();
      
      // Reset timer and start new round
      resetTimer();
      startTimer();
    }
    
    // Show special replay message
    function showSpecialReplayMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff6b00, #ff8c00);
        border: 3px solid #ffaa00;
        border-radius: 20px;
        padding: 30px 50px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
        font-size: 24px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 0 40px rgba(255, 170, 0, 0.8);
        z-index: 10000;
        animation: pulse 2s infinite;
      `;
      
      messageDiv.innerHTML = `
        <div style="margin-bottom: 10px;">ðŸ”„</div>
        <div>SPECIAL REPLAY!</div>
        <div style="font-size: 16px; margin-top: 10px; opacity: 0.9;">
          All remaining players have 1 life and lost!
        </div>
      `;
      
      // Add pulse animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0% { transform: translate(-50%, -50%) scale(1); }
          50% { transform: translate(-50%, -50%) scale(1.05); }
          100% { transform: translate(-50%, -50%) scale(1); }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(messageDiv);
      
      // Remove message after 3 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
        if (style.parentNode) {
          style.parentNode.removeChild(style);
        }
      }, 3000);
    }
    
    // Show choice required message
    function showChoiceRequiredMessage(playerIndex) {
      const player = players[playerIndex];
      const tube = tubes[playerIndex];
      
      // Create message div positioned near the player's card
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = `
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff1493, #ff69b4);
        border: 3px solid #ff1493;
        border-radius: 15px;
        padding: 20px 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
        z-index: 10000;
        animation: bounceIn 0.5s ease-out;
      `;
      
      messageDiv.innerHTML = `
        <div style="margin-bottom: 8px;">âš ï¸</div>
        <div>${player.name.toUpperCase()}</div>
        <div style="font-size: 14px; margin-top: 5px; opacity: 0.9;">
          Choose HEADS or TAILS first!
        </div>
      `;
      
      // Add bounce animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes bounceIn {
          0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.1); }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(messageDiv);
      
      // Remove message after 2 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.style.animation = 'bounceOut 0.3s ease-in forwards';
          setTimeout(() => {
            if (messageDiv.parentNode) {
              messageDiv.parentNode.removeChild(messageDiv);
            }
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
          }, 300);
        }
      }, 2000);
      
      // Add bounceOut animation
      if (!document.querySelector('#bounceOutStyle')) {
        const bounceOutStyle = document.createElement('style');
        bounceOutStyle.id = 'bounceOutStyle';
        bounceOutStyle.textContent = `
          @keyframes bounceOut {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
          }
        `;
        document.head.appendChild(bounceOutStyle);
      }
    }
    
    // Show XP award notification
    function showXPAwardNotification(amount, totalXP) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #00ff00;
        border-radius: 15px;
        padding: 20px 25px;
        color: #00ff00;
        font-family: 'Orbitron', sans-serif;
        font-weight: bold;
        font-size: 18px;
        z-index: 10001;
        box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
      `;
      
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <div style="font-size: 24px;">ðŸ’°</div>
          <div>
            <div style="font-size: 20px; margin-bottom: 5px;">+${amount} FLIP</div>
            <div style="font-size: 14px; opacity: 0.8;">Total: ${totalXP}</div>
          </div>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Slide in
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 100);
      
      // Slide out and remove after 3 seconds
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    // Show game phase indicator
    function showGamePhaseIndicator(phase, message) {
      // Remove existing phase indicator
      const existing = document.getElementById('game-phase-indicator');
      if (existing) {
        existing.remove();
      }
      
      const indicator = document.createElement('div');
      indicator.id = 'game-phase-indicator';
      indicator.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid ${phase === 'waiting' ? '#ffaa00' : phase === 'starting' ? '#00ff00' : phase === 'in_progress' ? '#0088ff' : '#ff0000'};
        border-radius: 15px;
        padding: 15px 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: #ffffff;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 0 30px ${phase === 'waiting' ? 'rgba(255, 170, 0, 0.5)' : phase === 'starting' ? 'rgba(0, 255, 0, 0.5)' : phase === 'in_progress' ? 'rgba(0, 136, 255, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
        z-index: 9998;
        animation: phaseIndicatorPulse 0.5s ease-out;
      `;
      
      const phaseIcon = phase === 'waiting' ? 'â³' : phase === 'starting' ? 'ðŸŽ®' : phase === 'in_progress' ? 'âš”ï¸' : 'ðŸ';
      indicator.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 24px;">${phaseIcon}</span>
          <span>${message}</span>
        </div>
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes phaseIndicatorPulse {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(indicator);
    }

    // Show game start notification
    function showGameStartNotification() {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #00ff00, #39ff14);
        border: 3px solid #00ff00;
        border-radius: 20px;
        padding: 40px 60px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: #000;
        font-size: 32px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 3px;
        box-shadow: 0 0 60px rgba(0, 255, 0, 0.8);
        z-index: 10001;
        animation: gameStartPulse 0.5s ease-out;
      `;
      
      notification.innerHTML = `
        <div style="margin-bottom: 10px;">ðŸŽ®</div>
        <div>GAME STARTED!</div>
        <div style="font-size: 18px; margin-top: 10px;">Round 1 Beginning</div>
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes gameStartPulse {
            0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Remove after 3 seconds
      setTimeout(() => {
        notification.style.animation = 'gameStartPulse 0.5s ease-out reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 500);
      }, 3000);
    }

    // Show game over screen
    function showGameOverScreen(winnerIndex, winnerName) {
      console.log('ðŸ GAME OVER - Showing end screen');
      
      // Stop any ongoing game mechanics
      gameOver = true;
      stopTimer();
      
      // Show game ended phase indicator
      showGamePhaseIndicator('ended', 'Game Over - Claim your rewards!');
      
      // Determine if current player won
      const didCurrentPlayerWin = (playerSlot === winnerIndex);
      const currentPlayerLives = players[playerSlot]?.lives || 0;
      
      // Create collection session via server
      if (isServerSideMode && socket && gameIdParam && walletParam) {
        const gameResult = didCurrentPlayerWin ? 'won' : 'lost';
        
        // Request FLIP collection session creation
        socket.emit('create_flip_collection', {
          gameId: gameIdParam,
          address: walletParam,
          gameResult: gameResult,
          finalLives: currentPlayerLives,
          totalFlip: currentPlayerXP
        });
        
        console.log(`ðŸŽ Requesting collection session: ${gameResult}, ${currentPlayerXP} FLIP`);
      }
      
      // Show immediate game over overlay
      const gameOverDiv = document.createElement('div');
      gameOverDiv.id = 'game-over-overlay';
      gameOverDiv.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        font-family: 'Orbitron', sans-serif;
      `;
      
      const contentDiv = document.createElement('div');
      contentDiv.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 4px solid ${didCurrentPlayerWin ? '#FFD700' : '#ff0000'};
        border-radius: 25px;
        padding: 50px;
        text-align: center;
        box-shadow: 0 0 50px ${didCurrentPlayerWin ? 'rgba(255, 215, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
        max-width: 600px;
        width: 90%;
      `;
      
      // Show different content based on win/lose
      if (didCurrentPlayerWin) {
        contentDiv.innerHTML = `
            <div style="font-size: 80px; margin-bottom: 20px;">ðŸ†</div>
            <div style="font-size: 48px; font-weight: bold; color: #FFD700; margin-bottom: 20px;">
                VICTORY!
            </div>
            <div style="font-size: 24px; color: #ffffff; margin-bottom: 30px;">
                You earned ${currentPlayerXP} FLIP tokens!
            </div>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 30px;">
                <button id="claim-flip-btn" style="
                    background: linear-gradient(135deg, #00ff00, #39ff14);
                    border: none;
                    border-radius: 15px;
                    padding: 15px 30px;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 18px;
                    font-weight: bold;
                    color: #000;
                    cursor: pointer;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                ">
                    ðŸ’Ž Claim ${currentPlayerXP} FLIP
                </button>
                <button id="claim-nft-btn" style="
                    background: linear-gradient(135deg, #ff0088, #ff1493);
                    border: none;
                    border-radius: 15px;
                    padding: 15px 30px;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 18px;
                    font-weight: bold;
                    color: #fff;
                    cursor: pointer;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                ">
                    ðŸŽ¨ Claim NFT Prize
                </button>
            </div>
        `;
      } else {
        contentDiv.innerHTML = `
            <div style="font-size: 60px; margin-bottom: 20px;">ðŸ’”</div>
            <div style="font-size: 36px; font-weight: bold; color: #ff0000; margin-bottom: 20px;">
                DEFEATED
            </div>
            <div style="font-size: 24px; color: #ffffff; margin-bottom: 20px;">
                Winner: ${winnerName || 'Unknown'}
            </div>
            <div style="font-size: 20px; color: #00ff00; margin-bottom: 30px;">
                You earned ${currentPlayerXP} FLIP tokens!
            </div>
            <button id="claim-flip-btn" style="
                background: linear-gradient(135deg, #00ff00, #39ff14);
                border: none;
                border-radius: 15px;
                padding: 15px 30px;
                font-family: 'Orbitron', sans-serif;
                font-size: 18px;
                font-weight: bold;
                color: #000;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 2px;
            ">
                ðŸ’Ž Claim ${currentPlayerXP} FLIP
            </button>
        `;
      }
      
      // Add return to lobby button
      contentDiv.innerHTML += `
        <button id="return-lobby-btn" style="
            background: linear-gradient(135deg, #666, #888);
            border: none;
            border-radius: 15px;
            padding: 12px 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 20px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        ">
            Return to Lobby
        </button>
      `;
      
      gameOverDiv.appendChild(contentDiv);
      document.body.appendChild(gameOverDiv);
      
      // Add button handlers
      setTimeout(() => {
        const claimFlipBtn = document.getElementById('claim-flip-btn');
        const claimNftBtn = document.getElementById('claim-nft-btn');
        const returnLobbyBtn = document.getElementById('return-lobby-btn');
        
        if (claimFlipBtn) {
            claimFlipBtn.addEventListener('click', () => {
                if (socket && currentCollectionId) {
                    socket.emit('collect_flip_tokens', {
                        collectionId: currentCollectionId,
                        address: walletParam,
                        amount: currentPlayerXP
                    });
                    claimFlipBtn.disabled = true;
                    claimFlipBtn.textContent = 'Claiming...';
                }
            });
        }
        
        if (claimNftBtn && didCurrentPlayerWin) {
            claimNftBtn.addEventListener('click', () => {
                if (socket && gameIdParam && walletParam) {
                    socket.emit('claim_nft_prize', {
                        gameId: gameIdParam,
                        address: walletParam
                    });
                    claimNftBtn.disabled = true;
                    claimNftBtn.textContent = 'Claiming...';
                }
            });
        }
        
        if (returnLobbyBtn) {
            returnLobbyBtn.addEventListener('click', () => {
                window.location.href = `/battle-royale/${gameIdParam}`;
            });
        }
      }, 100);
    }

    // ===== RESET ROUND (Clear results and prepare for next round) =====
    function resetRound() {
      // Reset round state
      allPlayersFlipped = false;
      
      tubes.forEach((tube, i) => {
        // Reset player choice for next round
        players[i].choice = null;
        
        // Reset choice buttons in card - replace badge with buttons
        if (tube.cardElement) {
          const choiceBadge = tube.cardElement.querySelector('.choice-badge');
          if (choiceBadge) {
            choiceBadge.outerHTML = `
              <div class="choice-buttons">
                <button class="choice-btn heads">HEADS</button>
                <button class="choice-btn tails">TAILS</button>
              </div>
            `;
            
            // Re-attach click handlers to new buttons
            const choiceButtons = tube.cardElement.querySelectorAll('.choice-btn');
            choiceButtons.forEach(btn => {
              btn.style.pointerEvents = 'auto';
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Don't allow choices if player has no lives
                if (players[i].lives <= 0) {
                  console.log(`âŒ Player ${i + 1} has no lives - cannot make choice`);
                  return;
                }
                
                const choice = btn.textContent.toLowerCase();
                players[i].choice = choice;
                console.log(`Player ${i + 1} selected: ${choice}`);
                
                // Update coin rotation immediately
                updateCoinRotationsFromPlayerChoices();
                
                // Send choice to server
                if (isServerSideMode && socket && gameIdParam && walletParam) {
                  socket.emit('physics_set_choice', {
                    gameId: gameIdParam,
                    address: walletParam,
                    choice: choice
                  });
                  console.log(`ðŸŽ¯ Sent choice to server (next round): ${choice}`);
                }
                
                // Replace buttons with choice badge
                const choiceButtonContainer = tube.cardElement.querySelector('.choice-buttons');
                if (choiceButtonContainer) {
                  choiceButtonContainer.outerHTML = `
                    <div class="choice-badge ${choice}">
                      ${choice.toUpperCase()}
                    </div>
                  `;
                }
              });
            });
          }
        }
        
        // Remove result box
        if (tube.resultBox) {
          scene.remove(tube.resultBox);
          tube.resultBox = null;
        }
        
        // Remove win/lose lights
        if (tube.winLight) {
          coins[i].remove(tube.winLight);
          tube.winLight = null;
        }
        if (tube.loseLight) {
          coins[i].remove(tube.loseLight);
          tube.loseLight = null;
        }
        
        // Reset coin light to white and rotation
        coins[i].children.forEach(child => {
          if (child.isLight) {
            child.color.setHex(0xffffff);
            child.intensity = 2;
          }
        });
        
        // Reset coin position to center
        coins[i].position.set(tube.tube.position.x, 200, 0);
        coins[i].rotation.x = Math.PI / 2; // Standing on edge
        coins[i].rotation.y = Math.PI / 2;
        coins[i].rotation.z = 0;
        coins[i].visible = true; // Ensure coin is visible
        
        // Make tube visible again
        tube.tube.visible = true;
        tube.backing.visible = true;
        tube.topRim.visible = true;
        tube.bottomRim.visible = true;
        tube.liquid.visible = true; // Show the liquid surface again
        
        // Hide shadow backdrop
        tube.coinShadow.visible = false;
        
        // Remove glass shards
        tube.glassShards.forEach(shard => {
          scene.remove(shard.mesh);
        });
        tube.glassShards = [];
        
        // Re-add physics container
        physicsWorld.addBody(tube.glassBody);
        
        // Reset pearls to bottom (dark pearls at bottom of tube)
        tube.liquidParticles.forEach((particleBody, idx) => {
          // Reset to bottom positions
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * (TUBE_RADIUS - 25);
          particleBody.position.set(
            tube.tube.position.x + Math.cos(angle) * radius,
            200 - (TUBE_HEIGHT / 2) + 30 + Math.random() * 60, // At bottom
            Math.sin(angle) * radius
          );
          particleBody.velocity.set(0, 0, 0);
          particleBody.angularVelocity.set(0, 0, 0);
          
          // Reset pearl color to neutral dark grey (ready to transition to any color)
          tube.liquidParticleMeshes[idx].material.color.setHex(0x1a1a1a);
          tube.liquidParticleMeshes[idx].material.emissive.setHex(0x0a0a0a);
          tube.liquidParticleMeshes[idx].material.emissiveIntensity = 0.2;
          tube.liquidParticleMeshes[idx].visible = true;
        });
        
        // Reset liquid mesh to dark blue-grey state
        tube.liquid.visible = true;
        tube.liquid.scale.y = 1.0;
        tube.liquid.position.y = tube.liquidBaseY;
        tube.liquid.material.color.setHex(0x1a1a2e);
        tube.liquid.material.emissive.setHex(0x0a0a1a);
        tube.liquid.material.emissiveIntensity = 0.3;
        
        // Reset liquid light to dim
        tube.liquidLight.color.setHex(0x1a1a2e);
        tube.liquidLight.intensity = 0.3;
        
        // Reset states
        tube.isShattered = false;
        tube.isFlipping = false;
        tube.isFilling = false;
        tube.power = 0;
        tube.foamIntensity = 0;
        tube.hasUsedPower = false;
        
        // Reset power bar UI and re-enable button
        if (tube.cardElement) {
          const powerBar = tube.cardElement.querySelector('.power-bar');
          const powerText = tube.cardElement.querySelector('.power-text');
          if (powerBar) {
            powerBar.style.width = '0%';
            powerBar.style.background = 'linear-gradient(90deg, #00ff00, #39ff14)';
          }
          if (powerText) powerText.textContent = 'POWER: 0%';
        }
        
        // Re-enable power button for next round
        if (tube.powerButton) {
          tube.powerButton.disabled = false;
          tube.powerButton.style.opacity = '1';
          tube.powerButton.style.cursor = 'pointer';
          tube.powerButton.style.background = 'white';
          tube.powerButton.style.color = '#ff1493';
          tube.powerButton.style.borderColor = '#ff1493';
        }
      });
      
      console.log('ðŸ”„ Round reset! Ready for next flip!');
    }
    
    // Expose reset function globally for testing
    window.resetRound = resetRound;

    // Plasma effects removed - pearls now glow on their own!

    console.log('âœ… Game loaded! Hold CHARGE POWER button to fill tubes!');
    console.log('ðŸ’¡ Call resetRound() to start a new round');
    console.log('â±ï¸ Call startTimer() to begin the countdown');
    
    // Update player cards with real data after loading
    function updatePlayerCards() {
      console.log('ðŸ”„ Updating player cards with real data...');
      tubes.forEach((tube, index) => {
        const player = players[index];
        console.log(`ðŸ” Tube ${index + 1}:`, { hasCardElement: !!tube.cardElement, player: player?.name });
        if (!tube.cardElement || !player) return;
        
        // TEMPORARILY REMOVED: Button blocking logic for debugging
        // Show buttons for ALL players to debug visibility issues
        const showButtons = !player.isEmpty;
        
        console.log(`ðŸŽ¯ Player ${index + 1} button logic (DEBUGGING MODE):`, {
          playerAddress: player.address,
          isEmpty: player.isEmpty,
          showButtons: showButtons
        });
        
        // Update player name and address
        const playerNameElement = tube.cardElement.querySelector('.player-name');
        const playerAddressElement = tube.cardElement.querySelector('.player-address');
        const playerAvatarElement = tube.cardElement.querySelector('.player-avatar');
        
        console.log(`ðŸ“ Updating player ${index + 1}:`, { name: player.name, address: player.address, isEmpty: player.isEmpty });
        
        if (playerNameElement) playerNameElement.textContent = player.name;
        if (playerAddressElement) {
          // Shorten wallet address for display
          const shortAddress = player.address ? `${player.address.slice(0, 6)}...${player.address.slice(-4)}` : '';
          playerAddressElement.textContent = shortAddress;
        }
        if (playerAvatarElement) {
          playerAvatarElement.src = player.isEmpty ? '/images/potion.png' : (player.avatar || '/images/default-avatar.png');
          playerAvatarElement.alt = player.name;
        }
        
        // Update lives display
        const lifeElements = tube.cardElement.querySelectorAll('.life');
        lifeElements.forEach((lifeElement, idx) => {
          const heartDiv = lifeElement.querySelector('div');
          if (idx < player.lives) {
            lifeElement.classList.add('active');
            if (heartDiv) heartDiv.style.color = '#ff4444'; // Red heart
          } else {
            lifeElement.classList.remove('active');
            if (heartDiv) heartDiv.style.color = '#666'; // Gray heart
          }
        });
        
        // Update empty slot overlay
        const existingOverlay = tube.cardElement.querySelector('.empty-slot-overlay');
        console.log(`ðŸŽ¯ Player ${index + 1} empty slot logic:`, { 
          isEmpty: player.isEmpty, 
          hasExistingOverlay: !!existingOverlay,
          playerName: player.name,
          playerAddress: player.address 
        });
        
        // Always remove existing overlay first to ensure clean state
        if (existingOverlay) {
          console.log(`ðŸ§¹ Removing existing overlay from player slot ${index + 1}`);
          existingOverlay.remove();
        }
        
        // Add overlay only for truly empty slots
        if (player.isEmpty) {
          console.log(`âž• Adding pink X overlay to empty slot ${index + 1}`);
          const overlay = document.createElement('div');
          overlay.className = 'empty-slot-overlay';
          overlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 20, 147, 0.8);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
          `;
          overlay.textContent = 'âœ•';
          tube.cardElement.appendChild(overlay);
        }
        
        // Update buttons visibility
        const actionButtons = tube.cardElement.querySelectorAll('.action-btn');
        const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
        
        if (showButtons) {
          actionButtons.forEach(btn => btn.style.display = 'block');
          if (choiceButtons) choiceButtons.style.display = 'flex';
        } else {
          actionButtons.forEach(btn => btn.style.display = 'none');
          if (choiceButtons) choiceButtons.style.display = 'none';
        }
      });
      
      // Update coin rotations based on player choices
      updateCoinRotationsFromPlayerChoices();
    }

    // Fetch participants and map to tubes left-to-right
    async function loadParticipants() {
      try {
        if (!gameIdParam) return;
        const res = await fetch(`/api/battle-royale/${encodeURIComponent(gameIdParam)}`);
        if (!res.ok) throw new Error('Failed to load participants');
        const data = await res.json();
        const parts = (data?.game?.participants || []).slice().sort((a,b) => (a.slot_number||0)-(b.slot_number||0));
        console.log('ðŸ” Raw participants data:', parts);
        
        players = [1,2,3,4].map((slot, idx) => {
          const p = parts[idx];
          if (!p) {
            console.log(`ðŸ“­ Slot ${idx+1}: Empty`);
            return { id: idx+1, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true };
          }
          
          const playerData = {
            id: idx+1,
            name: p.username || p.name || `Player ${idx+1}`,
            lives: 3,
            address: p.player_address || '',
            choice: null,
            avatar: p.avatar || '/images/default-avatar.png',
            isEmpty: false
          };
          
          console.log(`ðŸ‘¤ Slot ${idx+1}:`, {
            raw: p,
            processed: playerData
          });
          
          return playerData;
        });
        // Update initial lives tracking
        roundStartLives = players.map(player => player.lives);
        console.log('ðŸ“Š Participants mapped:', players);
        
        // Update player cards with real data
        updatePlayerCards();
        
        // Show waiting phase indicator
        showGamePhaseIndicator('waiting', 'Waiting for players to join...');
        
        // Start timer when players are set
        startTimer();
        
        // Show game start notification
        if (!gameOver) {
          showGameStartNotification();
        }
      } catch (err) {
        console.warn('Participants load failed:', err);
        // Fallback: start timer anyway
        startTimer();
      }
    }
    await loadParticipants();

    // ===== SERVER JOIN (PLAYER) =====
    (async () => {
      try {
        if (!gameIdParam) return;
        if (roleParam === 'spectator') {
          console.log('ðŸ‘€ Spectator mode - skipping join');
          return;
        }
        if (!walletParam) {
          console.warn('âš ï¸ No wallet address provided; cannot join game');
          return;
        }
        const res = await fetch(`/api/battle-royale/${encodeURIComponent(gameIdParam)}/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...(tokenParam ? { Authorization: `Bearer ${tokenParam}` } : {}) },
          body: JSON.stringify({ player_address: walletParam })
        });
        const data = await res.json().catch(() => ({}));
        if (res.ok) {
          console.log('âœ… Joined game on server:', data);
        } else {
          console.warn('âš ï¸ Join failed:', data?.error || res.statusText);
        }
      } catch (err) {
        console.error('âŒ Join error:', err);
      }
    })();
    
    // ===== POST-INITIALIZATION SETUP =====
    setTimeout(() => {
      // Update player card buttons after all initialization is complete
      if (typeof updatePlayerCardButtons === 'function') {
        updatePlayerCardButtons();
      }
      
      // Update coin rotations based on initial player choices
      if (typeof updateCoinRotationsFromPlayerChoices === 'function') {
        updateCoinRotationsFromPlayerChoices();
      }
    }, 1000); // 1 second delay
    
    // Expose timer functions globally
    window.startTimer = startTimer;
    window.resetTimer = resetTimer;
    window.nextRound = nextRound;

    // Animation loop with physics
    let frameCount = 0;
    const timeStep = 1 / 60; // 60 FPS
    
    function animate() {
      frameCount++;

      // Step physics simulation
      physicsWorld.step(timeStep);

      tubes.forEach((tube, i) => {
        const offset = i * 0.4;
        
        // ðŸŽ¯ REFACTORED: POWER CHARGING SYSTEM - REAL-TIME SYNC
        if (tube.isFilling && !tube.isShattered) {
          // Increase power (0-100 over ~3 seconds)
          tube.power = Math.min(tube.power + 0.6, 100);
          const powerPercent = tube.power / 100;
          
          // Update foam intensity
          tube.foamIntensity = powerPercent;
          
          // Calculate power level (1-5) based on power percentage
          const powerLevel = Math.min(5, Math.max(1, Math.ceil(tube.power / 20)));
          
          // ðŸŽ¯ FASTER BROADCAST - Every 5 frames = 12 updates/second (was every frame)
          if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === i) {
            if (frameCount % 5 === 0) { // Changed from every frame to every 5 frames
              socket.emit('physics_power_charging', {
                gameId: gameIdParam,
                address: walletParam,
                power: tube.power,
                powerLevel: powerLevel,
                playerSlot: i,
                isFilling: tube.isFilling
              });
              // Removed console.log to reduce spam - only log on start/stop
            }
          }
          
          // Update UI elements
          if (tube.cardElement) {
            const powerBar = tube.cardElement.querySelector('.power-bar');
            const powerText = tube.cardElement.querySelector('.power-text');
            if (powerBar) powerBar.style.width = `${tube.power}%`;
            if (powerText) powerText.textContent = `POWER: ${tube.power.toFixed(0)}%`;
            
            // Change bar color as it charges (pink theme)
            if (tube.power > 75) {
              powerBar.style.background = 'linear-gradient(90deg, #ff1493, #ff69b4)';
            } else if (tube.power > 50) {
              powerBar.style.background = 'linear-gradient(90deg, #ff69b4, #ffb6c1)';
            }
          }
          
          // ðŸŽ¯ UNIFIED PEARL COLOR UPDATE - Same for local and remote
          updatePearlColors(tube, powerPercent, i);
        }
        
        // ðŸŽ¯ UNIFIED PEARL PHYSICS - Runs for BOTH local charging AND remote viewing
        if ((tube.isFilling || tube.foamIntensity > 0) && !tube.isShattered) {
          updatePearlPhysics(tube, tube.foamIntensity, i, frameCount);
        }
        
        // Sync particle visual meshes with physics bodies
        tube.liquidParticles.forEach((particleBody, idx) => {
          tube.liquidParticleMeshes[idx].position.copy(particleBody.position);
          tube.liquidParticleMeshes[idx].quaternion.copy(particleBody.quaternion);
        });
        
        // Pulsing light during charging
        if (tube.foamIntensity > 0) {
          const lightPulse = Math.sin(frameCount * 0.15 + offset) * 0.5;
          tube.liquidLight.intensity = tube.liquidLight.intensity + lightPulse * tube.foamIntensity;
        }
      });

      // Animate coins - VIBRATE during charge, stay centered
      coins.forEach((coin, i) => {
        const tube = tubes[i];
        
        // Ensure coin is always visible
        coin.visible = true;
        
        if (tube.isFlipping) {
          // Flipping animation handled by flipCoinWithPower function
          // Ensure coin stays centered during flip
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX;
          coin.position.y = 200;
          coin.position.z = 0;
        } else if (tube.isFilling && !tube.isShattered) {
          // VIBRATION increases with power
          const vibIntensity = (tube.power / 100) * 8; // 0 to 8 pixels
          const vibSpeed = (tube.power / 100) * 20; // Speed increases
          
          // Vibrate position
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX + Math.sin(frameCount * vibSpeed) * vibIntensity;
          coin.position.y = 200 + Math.cos(frameCount * vibSpeed * 1.3) * vibIntensity;
          coin.position.z = Math.sin(frameCount * vibSpeed * 0.7) * vibIntensity * 0.5;
          
          // Slight rotation vibration
          coin.rotation.z = Math.sin(frameCount * vibSpeed * 0.5) * (vibIntensity / 50);
        } else if (!tube.isShattered && !tube.isFilling) {
          // Reset to center when idle (like reference)
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX;
          coin.position.y = 200;
          coin.position.z = 0;
          coin.rotation.z = 0; // Only reset Z rotation, keep X and Y as set
        }
      });
      
      // Animate glass shards
      tubes.forEach((tube, i) => {
        if (tube.glassShards.length > 0) {
          tube.glassShards.forEach(shard => {
            shard.lifetime += 0.016;
            
            // Apply velocity
            shard.mesh.position.x += shard.velocity.x;
            shard.mesh.position.y += shard.velocity.y;
            shard.mesh.position.z += shard.velocity.z;
            
            // Apply gravity to shards
            shard.velocity.y -= 0.3;
            
            // Rotate shards
            shard.mesh.rotation.x += shard.rotVelocity.x;
            shard.mesh.rotation.y += shard.rotVelocity.y;
            shard.mesh.rotation.z += shard.rotVelocity.z;
            
            // Fade out over 2 seconds
            shard.mesh.material.opacity = Math.max(0, 0.6 - (shard.lifetime / 2) * 0.6);
            
            // Remove after 2 seconds
            if (shard.lifetime > 2) {
              shard.mesh.visible = false;
            }
          });
        }
      });

      // ===== SELECTIVE BLOOM - TWO-PASS RENDERING =====
      
      // PASS 1: Render main scene (layer 0) - tubes, coins, background, etc.
      const originalMask = camera.layers.mask; // Save original layer mask
      camera.layers.disableAll(); // Clear all layers
      camera.layers.enable(0); // Only enable layer 0
      
      if (frameCount === 1) {
        console.log('ðŸŽ¬ Frame 1 - Layer 0 mask:', camera.layers.mask, 'Should be 1 for layer 0');
      }
      
      webglRenderer.autoClear = true;
      webglRenderer.clear(true, true, true); // Clear color, depth, stencil
      webglRenderer.render(scene, camera);
      
      if (frameCount === 1) {
        console.log('âœ… Main scene (layer 0) rendered to screen');
      }
      
      // PASS 2: Render pearls (layer 1) with bloom to separate buffer  
      camera.layers.disableAll();
      camera.layers.enable(1); // Only enable layer 1 (pearls + plasma)
      
      if (frameCount === 1) {
        console.log('ðŸŽ¬ Frame 1 - Layer 1 mask:', camera.layers.mask, 'Should be 2 for layer 1');
      }
      
      // Render to bloom composer's internal render target (NOT to screen!)
      bloomComposer.render();
      
      if (frameCount === 1) {
        console.log('âœ… Pearls (layer 1) rendered to bloom buffer');
        console.log('ðŸ” Bloom composer render target:', bloomComposer.renderTarget1 ? 'Found' : 'Missing');
        console.log('ðŸ” Bloom composer read buffer:', bloomComposer.readBuffer ? 'Found' : 'Missing');
      }
      
      // PASS 3: Composite bloomed pearls on top with additive blending
      webglRenderer.autoClear = false; // Don't clear - we want to blend on top!
      
      // Get the bloom result texture from the read buffer
      const bloomTexture = bloomComposer.readBuffer.texture;
      
      if (frameCount === 1) {
        console.log('ðŸŽ¨ Bloom texture:', bloomTexture ? 'Found' : 'Missing');
        if (bloomTexture) {
          console.log('ðŸŽ¨ Bloom texture details:', {
            width: bloomTexture.image?.width,
            height: bloomTexture.image?.height,
            format: bloomTexture.format,
            type: bloomTexture.type
          });
        }
      }
      
      // Debug: Check if any pearls are visible on layer 1
      if (frameCount === 1) {
        let visiblePearls = 0;
        tubes.forEach((tube, i) => {
          if (tube.liquidParticleMeshes) {
            const tubeVisiblePearls = tube.liquidParticleMeshes.filter(mesh => mesh.visible).length;
            visiblePearls += tubeVisiblePearls;
            console.log(`ðŸ” Tube ${i + 1} has ${tubeVisiblePearls} visible pearls on layer 1`);
          }
        });
        console.log(`ðŸ” Total visible pearls on layer 1: ${visiblePearls}`);
      }
      
      // Create a fullscreen quad to display bloom texture (create once)
      if (!window.bloomQuadMesh) {
        const quadGeometry = new THREE.PlaneGeometry(2, 2);
        const quadMaterial = new THREE.MeshBasicMaterial({
          map: bloomTexture,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          depthWrite: false,
          toneMapped: false // Preserve bloom colors!
        });
        const quadMesh = new THREE.Mesh(quadGeometry, quadMaterial);
        
        const quadScene = new THREE.Scene();
        quadScene.add(quadMesh);
        
        const quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        window.bloomQuadMesh = quadMesh;
        window.bloomQuadScene = quadScene;
        window.bloomQuadCamera = quadCamera;
        
        console.log('âœ¨ Bloom composite quad created!');
      }
      
      // Update bloom texture reference and ensure it's properly bound
      if (window.bloomQuadMesh && bloomTexture) {
        window.bloomQuadMesh.material.map = bloomTexture;
        window.bloomQuadMesh.material.needsUpdate = true;
        
        // Force texture update
        if (bloomTexture.needsUpdate !== undefined) {
          bloomTexture.needsUpdate = true;
        }
      }
      
      // Render the bloomed pearls additively on top of the main scene
      if (window.bloomQuadScene && window.bloomQuadCamera && bloomTexture) {
        webglRenderer.render(window.bloomQuadScene, window.bloomQuadCamera);
      } else {
        // Fallback: If bloom fails, render pearls directly to main layer
        console.log('âš ï¸ Bloom rendering failed, using fallback direct rendering');
        camera.layers.disableAll();
        camera.layers.enable(1); // Enable layer 1
        webglRenderer.render(scene, camera);
        camera.layers.mask = originalMask; // Restore original mask
      }
      
      if (frameCount === 1) {
        console.log('âœ… Bloomed pearls composited on top');
        console.log('ðŸŽ‰ Selective bloom rendering complete!');
      }
      
      // Restore renderer settings
      webglRenderer.autoClear = true;
      camera.layers.mask = originalMask; // Restore original layer mask
      
      // Render CSS3D UI on top
      cssRenderer.render(scene, camera);

      requestAnimationFrame(animate);
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;

      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();

      webglRenderer.setSize(newWidth, newHeight);
      cssRenderer.setSize(newWidth, newHeight);
      bloomComposer.setSize(newWidth, newHeight);

      console.log(`ðŸ“ Resized to ${newWidth}x${newHeight}`);
    });
  </script>
</body>
</html>

