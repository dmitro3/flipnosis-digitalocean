<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, orientation=landscape">
  <title>Glass Tube Game Test</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'Hyperwave';
      src: url('/src/fonts/hyperwave-one.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }
    
    body {
      font-family: 'Orbitron', sans-serif;
      background: url('/Images/Background/game room2.png') no-repeat center center;
      background-size: cover;
      background-attachment: fixed;
      background-position: center center;
      min-height: 100vh;
      width: 100%;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }

    html {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    @media (max-width: 768px) {
      html {
        background: #0a0f23;
      }
      
    }

    /* ===== RESPONSIVE MOBILE-FIRST DESIGN ===== */
    
    .mobile-ui {
      display: none;
    }
    
    @media (max-width: 768px) {
      .mobile-ui {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
        pointer-events: none;
      }
      
      body {
        overflow: hidden;
        -webkit-overflow-scrolling: touch;
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      
      body::-webkit-scrollbar {
        display: none;
      }
      
      
      
      
      @media (orientation: portrait) {
        body.lab-room,
        body.cyber-room,
        body.mech-room,
        body {
          background: #0a0f23 !important;
          background-image: none !important;
          background-attachment: scroll !important;
        }
      }
      
      @media (orientation: landscape) {
        body.lab-room {
          background: url('/images/background/thelab.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
        
        body.cyber-room {
          background: url('/images/background/cyber.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
        
        body.mech-room {
          background: url('/images/background/mech.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
        
        body:not(.lab-room):not(.cyber-room):not(.mech-room) {
          background: url('/Images/Background/game room2.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
        
        html {
          background: transparent;
        }
      }
      
      .player-card,
      #xp-counter,
      #change-coin-box,
      #leave-btn {
        display: none !important;
      }
      
      .game-info {
        position: fixed !important;
        top: 10px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 10001 !important;
        width: 160px !important;
        text-align: center !important;
        height: auto !important;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95)) !important;
        border: 2px solid #9d00ff !important;
        border-radius: 12px !important;
        padding: 8px 12px !important;
        font-family: 'Orbitron', sans-serif !important;
        color: white !important;
        box-shadow: 0 0 20px rgba(157, 0, 255, 0.6) !important;
        pointer-events: auto !important;
        text-align: center !important;
        display: block !important;
      }
      
      .game-info button {
        display: none !important;
      }
      
      .game-info .desktop-timer-layout {
        display: none !important;
      }
      
      .game-info .mobile-timer-round {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        gap: 8px !important;
        font-size: 14px !important;
        font-weight: bold !important;
        color: #00ffff !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      .game-info .mobile-timer-round .round-text {
        color: #00ffff !important;
        font-size: 14px !important;
      }
      
      .game-info .mobile-timer-round .timer-text {
        color: #00ff00 !important;
        font-size: 14px !important;
      }
      
      .floating-btn.change-coin-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10001;
      }
      
      .floating-btn.chat-btn {
        position: fixed;
        bottom: 100px;
        right: 15px;
        z-index: 10001;
        width: 25px;
        height: 25px;
        font-size: 8px;
      }
      
      .floating-earnings {
        position: fixed;
        top: 15px;
        right: 70px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        color: #00ffff;
        font-size: 12px;
        font-weight: bold;
        padding: 6px 12px;
        border-radius: 15px;
        border: 2px solid #00ffff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        text-align: center;
        min-width: 80px;
        z-index: 10001;
        pointer-events: auto;
        backdrop-filter: blur(15px);
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
      }
      
      .floating-btn {
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.2), rgba(0, 255, 255, 0.2));
        border: 3px solid #00ffff;
        border-radius: 50%;
        color: #00ffff;
        font-size: 16px;
        width: 50px;
        height: 50px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        backdrop-filter: blur(10px);
        font-family: 'Orbitron', sans-serif;
      }
      
      .floating-btn:hover {
        transform: scale(1.1);
        border-color: #9d00ff;
        box-shadow: 0 0 30px rgba(157, 0, 255, 0.5);
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.3), rgba(0, 255, 255, 0.3));
      }
      
      .floating-btn.fullscreen-btn {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 10001;
      }
      
      
      .bottom-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        border-top: 3px solid #00ffff;
        padding: 12px 15px;
        pointer-events: auto;
        z-index: 10001;
        backdrop-filter: blur(15px);
        box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
      }
      
      .control-section {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      
      .game-controls {
        display: flex;
        gap: 6px;
        flex: 1;
      }
      
      .power-section {
        flex-shrink: 0;
        width: 120px;
      }
      
      .mobile-btn {
        flex: 1;
        padding: 8px 6px;
        border: 3px solid;
        border-radius: 12px;
        font-family: 'Orbitron', sans-serif;
        font-weight: bold;
        font-size: 9px;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.3s ease;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        min-height: 32px;
        backdrop-filter: blur(10px);
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      }
      
      .mobile-btn.heads-btn {
        background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 204, 106, 0.2));
        border-color: #00ff88;
        color: #00ff88;
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      }
      
      .mobile-btn.heads-btn.selected {
        background: linear-gradient(135deg, rgba(255, 20, 147, 0.4), rgba(255, 105, 180, 0.4));
        border-color: #ff1493;
        color: #ff1493;
        box-shadow: 0 0 30px rgba(255, 20, 147, 0.6);
        transform: scale(1.05);
      }
      
      .mobile-btn.tails-btn {
        background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(157, 0, 255, 0.2));
        border-color: #00ffff;
        color: #00ffff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }
      
      .mobile-btn.tails-btn.selected {
        background: linear-gradient(135deg, rgba(255, 20, 147, 0.4), rgba(255, 105, 180, 0.4));
        border-color: #ff1493;
        color: #ff1493;
        box-shadow: 0 0 30px rgba(255, 20, 147, 0.6);
        transform: scale(1.05);
      }
      
      .mobile-btn.power-btn {
        background: linear-gradient(135deg, rgba(255, 20, 147, 0.2), rgba(255, 105, 180, 0.2));
        border-color: #ff1493;
        color: #ff1493;
        box-shadow: 0 0 20px rgba(255, 20, 147, 0.3);
      }
      
      .mobile-btn.change-btn {
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.2), rgba(0, 255, 255, 0.2));
        border-color: #9d00ff;
        color: #9d00ff;
        box-shadow: 0 0 20px rgba(157, 0, 255, 0.3);
      }
      
      .mobile-btn.action-btn {
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.2), rgba(0, 255, 255, 0.2));
        border-color: #9d00ff;
        color: #9d00ff;
        box-shadow: 0 0 20px rgba(157, 0, 255, 0.3);
      }
      
      .mobile-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        border-color: #00ffff;
      }
      
      .mobile-btn:active {
        transform: scale(0.95);
      }
      
       .player-cards {
         position: fixed;
         bottom: 80px;
         left: 0;
         right: 0;
         height: 40px;
         display: flex;
         gap: 0;
         pointer-events: auto;
         z-index: 10001;
         align-items: stretch;
         justify-content: space-between;
         padding: 0 5px;
         border-bottom: 2px solid #00ffff;
       }
      
       .player-box {
         flex: 1;
         height: 40px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        border: 1px solid #00ffff;
        border-bottom: 1px solid #00ffff;
        border-radius: 0;
        padding: 2px 4px;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        font-size: 7px;
        backdrop-filter: blur(15px);
        transition: all 0.3s ease;
        font-family: 'Orbitron', sans-serif;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: flex-start;
        margin: 0;
        min-width: 0;
      }
      
      .player-box:hover {
        border-color: #9d00ff;
        box-shadow: 0 0 30px rgba(157, 0, 255, 0.5);
        transform: translateY(-2px);
      }
      
      
      .player-card {
        width: 80px;
        height: 50px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 4px;
        text-align: center;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        font-size: 8px;
        backdrop-filter: blur(15px);
        transition: all 0.3s ease;
        font-family: 'Orbitron', sans-serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      
      .player-card:hover {
        border-color: #9d00ff;
        box-shadow: 0 0 30px rgba(157, 0, 255, 0.5);
        transform: translateY(-2px);
      }
      
      .player-box .player-avatar {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        object-fit: cover;
        border: 1px solid #00ffff;
        margin-right: 4px;
        display: block;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
        flex-shrink: 0;
      }
      
      .player-box .player-info {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        flex: 1;
        min-width: 0;
        margin-left: 4px;
      }
      
      .player-box .player-name {
        font-size: 7px;
        color: #00ffff;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-shadow: 0 0 3px rgba(0, 255, 255, 0.5);
        line-height: 1;
        flex: 1;
        text-align: left;
      }
      
      .player-box .player-wins {
        font-size: 14px;
        color: #FFD700;
        font-weight: bold;
        font-family: 'Hyperwave', sans-serif;
        text-shadow: 0 0 3px rgba(255, 215, 0, 0.5);
        line-height: 1;
        flex-shrink: 0;
        margin-left: 4px;
      }
      
      .wins-display {
        font-family: 'Hyperwave', sans-serif;
        font-weight: bold;
        color: #FFD700;
        font-size: 18px;
        text-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
      }
      
      .timer, .earnings {
        color: #00ffff;
        font-size: 10px;
        font-weight: bold;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
      }
      
      .earnings {
        color: #FFD700;
        text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
      }
      
      .power-bar {
        position: relative;
        height: 24px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.8), rgba(16, 33, 62, 0.8));
        border: 2px solid #00ffff;
        border-radius: 12px;
        overflow: hidden;
        width: 100%;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      }

      .power-bar-container {
        position: relative;
        width: 100%;
        height: 40px;
        background: rgba(10, 15, 35, 0.8);
        border: 2px solid #00ffff;
        border-radius: 8px;
        overflow: visible;
        margin: 10px 0;
      }

      .zone-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .zone {
        position: absolute;
        height: 100%;
        top: 0;
        transition: opacity 0.3s;
      }

      .zone.safe {
        background: transparent;
      }

      .zone.good {
        background: linear-gradient(180deg, 
          rgba(0, 255, 100, 0.4) 0%,
          rgba(0, 255, 100, 0.2) 100%);
        border-left: 1px solid rgba(0, 255, 100, 0.6);
        border-right: 1px solid rgba(0, 255, 100, 0.6);
      }

      .zone.perfect {
        background: radial-gradient(ellipse at center, 
          rgba(255, 215, 0, 0.8) 0%,
          rgba(255, 215, 0, 0.5) 50%,
          rgba(255, 215, 0, 0.3) 100%);
        box-shadow: 
          0 0 15px rgba(255, 215, 0, 0.6),
          inset 0 0 15px rgba(255, 215, 0, 0.4);
        border-left: 2px solid rgba(255, 215, 0, 0.9);
        border-right: 2px solid rgba(255, 215, 0, 0.9);
        animation: sweetSpotPulse 0.8s ease-in-out infinite;
        z-index: 2;
      }

      @keyframes sweetSpotPulse {
        0%, 100% { 
          opacity: 0.7;
          box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        50% { 
          opacity: 1;
          box-shadow: 0 0 25px rgba(255, 215, 0, 0.9);
        }
      }

      .power-fill {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background: linear-gradient(90deg, 
          #00ff00 0%, 
          #00ffff 50%, 
          #0088ff 100%);
        transition: width 0.05s linear;
        z-index: 3;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      }

      .power-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 16px;
        font-weight: bold;
        color: white;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        z-index: 4;
        pointer-events: none;
      }

      .sweet-spot-feedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        z-index: 10000;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        pointer-events: none;
      }

      .sweet-spot-feedback.show {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      .sweet-spot-text {
        font-size: 64px;
        font-weight: 900;
        color: #FFD700;
        text-shadow: 
          0 0 20px rgba(255, 215, 0, 1),
          0 0 40px rgba(255, 215, 0, 0.6);
        animation: textGlow 0.5s ease-in-out infinite;
        letter-spacing: 4px;
      }

      .win-chance {
        font-size: 28px;
        color: #00ff00;
        margin-top: 15px;
        text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        font-weight: bold;
      }

      @keyframes textGlow {
        0%, 100% { 
          text-shadow: 
            0 0 20px rgba(255, 215, 0, 1),
            0 0 40px rgba(255, 215, 0, 0.6);
        }
        50% { 
          text-shadow: 
            0 0 30px rgba(255, 215, 0, 1),
            0 0 60px rgba(255, 215, 0, 0.8),
            0 0 80px rgba(255, 215, 0, 0.4);
        }
      }
      
      .power-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff88, #00ff88);
        border-radius: 10px;
        transition: width 0.1s ease;
        width: 0%;
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
      }
      
      .power-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ff88;
        font-size: 9px;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(0, 255, 136, 0.8);
        font-family: 'Orbitron', sans-serif;
      }
      
    }
    
    .portrait-warning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 99999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      padding: 20px;
    }

    @media (max-width: 768px) and (orientation: portrait) {
      .portrait-warning {
        display: flex !important;
      }
    }

    .portrait-warning-content {
      background: linear-gradient(135deg, rgba(157, 0, 255, 0.3), rgba(0, 255, 255, 0.3));
      border: 3px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      max-width: 300px;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
      backdrop-filter: blur(10px);
    }

    .portrait-warning-icon {
      font-size: 60px;
      margin-bottom: 20px;
      animation: rotate-phone 2s ease-in-out infinite;
    }

    @keyframes rotate-phone {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }

    .portrait-warning h2 {
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      margin-bottom: 15px;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    }

    .portrait-warning p {
      color: white;
      font-family: 'Orbitron', sans-serif;
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 10px;
    }
    
    @media (min-width: 768px) {
      .game-info .desktop-timer-layout {
        display: block !important;
      }
      
      .game-info .mobile-timer-round {
        display: none !important;
      }
      
      .game-info button {
        display: block !important;
      }
    }


    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: auto;
    }
    
    #container canvas {
      pointer-events: auto;
    }

    .player-card {
      width: 320px;
      background: rgba(10, 15, 35, 0.95);
      border: 3px solid #00ffff;
      border-radius: 16px;
      padding: 15px 20px;
      font-family: 'Orbitron', sans-serif;
      color: white;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
      pointer-events: auto;
      position: relative;
    }

    .card-header {
      margin-bottom: 15px;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .player-avatar {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      object-fit: cover;
      border: 2px solid #00ffff;
      flex-shrink: 0;
    }

    .player-info {
      flex: 1;
      text-align: right;
    }

    .player-name {
      font-size: 22px;
      font-weight: bold;
      color: #00ffff;
      margin-bottom: 5px;
    }

    .player-address {
      font-size: 16px;
      color: #ffffff;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
    }

    .trophy-symbol {
      font-size: 24px;
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
      margin: 5px;
    }

    @keyframes puffWin {
      0% { 
        transform: scale(0.3); 
        opacity: 0; 
        box-shadow: 0 0 0 rgba(255, 215, 0, 0);
      }
      50% { 
        transform: scale(1.3); 
        opacity: 1; 
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
      }
      100% { 
        transform: scale(1); 
        opacity: 1; 
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
      }
    }

    .choice-badge {
      padding: 12px;
      margin: 15px 0;
      border-radius: 8px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .choice-badge.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      border: 2px solid #00ff00;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-badge.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      border: 2px solid #00d4ff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-buttons {
      display: flex;
      gap: 10px;
      margin: 15px 0;
    }

    .choice-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      pointer-events: auto;
    }

    .choice-btn.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-btn.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-btn:hover {
      transform: translateY(-3px);
      filter: brightness(1.2);
    }
    
    .choice-btn.heads:hover {
      box-shadow: 0 5px 20px rgba(0, 255, 0, 0.8);
    }
    
    .choice-btn.tails:hover {
      box-shadow: 0 5px 20px rgba(0, 212, 255, 0.8);
    }

    .action-btn {
      width: 100%;
      padding: 15px;
      background: white;
      border: 2px solid #ff1493;
      border-radius: 8px;
      color: #ff1493;
      font-weight: 900;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-top: 10px;
      pointer-events: auto;
    }

    .action-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 20, 147, 0.3);
      background: #ffe6f2;
    }

    .action-btn:active {
      transform: translateY(0);
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    #info {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Portrait Orientation Warning -->
  <div class="portrait-warning">
    <div class="portrait-warning-content">
      <div class="portrait-warning-icon">üì±‚ö†Ô∏è¬è</div>
      <h2>Please Rotate Your Device</h2>
      <p>This game is designed for landscape mode.</p>
      <p>Please rotate your device to continue playing!</p>
    </div>
  </div>
  
  <div id="container"></div>
  
  <!-- Responsive Mobile Layout -->
  <div id="mobile-ui" class="mobile-ui">
    <!-- Player Cards -->
    <div class="player-cards" id="mobile-player-cards">
      <!-- Player cards will be dynamically created here -->
    </div>
    
    <!-- Floating UI Elements -->
    <!-- Top-left Change Coin -->
    <button class="floating-btn change-coin-btn" id="mobile-change-coin">ü™ô</button>
    
    <!-- Top-right Earnings -->
    <div class="floating-earnings" id="mobile-earnings">1,250 FLIP</div>
    
    <!-- Top-right Fullscreen -->
    <button class="floating-btn fullscreen-btn" id="mobile-fullscreen">‚õ∂</button>
    
    <!-- Bottom-right Chat -->
    <button class="floating-btn chat-btn" id="mobile-chat">üí¨</button>
    
    <!-- Bottom Control Panel -->
    <div class="bottom-panel">
      <!-- Game Controls and Power Bar -->
      <div class="control-section">
        <div class="game-controls">
          <button class="mobile-btn heads-btn" id="mobile-heads">HEADS</button>
          <button class="mobile-btn tails-btn" id="mobile-tails">TAILS</button>
          <button class="mobile-btn power-btn" id="mobile-power">POWER</button>
        </div>
        <div class="power-section">
          <div class="power-bar-container">
            <!-- Sweet Spot Zone Overlays -->
            <div class="zone-overlay">
              <div class="zone safe" style="left: 0%; width: 42%;"></div>
              <div class="zone good" style="left: 42%; width: 6%;"></div>
              <div class="zone perfect" style="left: 48%; width: 4%;"></div>
              <div class="zone good" style="left: 52%; width: 6%;"></div>
              <div class="zone safe" style="left: 58%; width: 42%;"></div>
            </div>
            
            <!-- Actual Power Fill -->
            <div class="power-fill" id="mobile-power-fill"></div>
            
            <!-- Power Text -->
            <div class="power-text" id="mobile-power-text">POWER: <span class="power-value">0</span>%</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="info">
    üéÆ Glass Tube Game Test<br>
    Loading Three.js...
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
      }
    }
  </script>
  
  <!-- Socket.io for server-side physics -->
  <script src="/socket.io/socket.io.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import * as CANNON from 'cannon-es';

    const info = document.getElementById('info');

    const urlParams = new URLSearchParams(window.location.search);
    const gameIdParam = urlParams.get('gameId') || '';
    const roleParam = urlParams.get('role') || 'player';
    let walletParam = urlParams.get('address') || '';
    const roomParam = urlParams.get('room') || 'potion'; // Default to potion room
    const tokenParam = urlParams.get('token') || '';
    
    if (!walletParam) {
      walletParam = localStorage.getItem('walletAddress') || '';
      console.log('√∞≈∏‚Äù¬ç No wallet in URL, trying localStorage:', walletParam);
      
      if (!walletParam && window.ethereum?.selectedAddress) {
        walletParam = window.ethereum.selectedAddress;
        console.log('√∞≈∏‚Äù¬ç Got wallet from window.ethereum:', walletParam);
      }
      
      console.log('√∞≈∏‚Äù¬ç Wallet detection debug:', {
        urlParam: urlParams.get('address'),
        localStorage: localStorage.getItem('walletAddress'),
        ethereum: window.ethereum?.selectedAddress,
        final: walletParam
      });
    }

    if (gameIdParam) {
      document.title = `Glass Tube Game √¢‚Ç¨¬¢ ${gameIdParam}`;
    }
    
    if (roomParam === 'lab') {
      document.body.classList.add('lab-room');
    } else if (roomParam === 'cyber') {
      document.body.classList.add('cyber-room');
    } else if (roomParam === 'mech') {
      document.body.classList.add('mech-room');
    }
    
    function updateMobileBackground() {
      if (!isMobile()) return;
      
      const isLandscape = window.innerWidth > window.innerHeight;
      const roomParam = new URLSearchParams(window.location.search).get('room');
      
      document.body.style.background = 'none';
      document.body.style.backgroundImage = 'none';
      document.body.style.backgroundSize = '';
      document.body.style.backgroundAttachment = '';
      document.body.style.backgroundPosition = '';
      document.body.style.backgroundRepeat = '';
      
      void document.body.offsetHeight;
      
      if (isLandscape) {
        let bgImage = "url('/Images/Background/game room2.png')";
        if (roomParam === 'lab') bgImage = "url('/images/background/thelab.png')";
        else if (roomParam === 'cyber') bgImage = "url('/images/background/cyber.png')";
        else if (roomParam === 'mech') bgImage = "url('/images/background/mech.png')";
        
        document.body.style.backgroundImage = bgImage;
        document.body.style.backgroundSize = "100% 100%";
        document.body.style.backgroundPosition = "center center";
        document.body.style.backgroundRepeat = "no-repeat";
        document.body.style.backgroundAttachment = "scroll";
      } else {
        document.body.style.backgroundColor = "#0a0f23";
      }
      
      void document.body.offsetHeight;
      
      console.log('üì± Background FORCE UPDATED for', isLandscape ? 'LANDSCAPE' : 'PORTRAIT', 'Width:', window.innerWidth, 'Height:', window.innerHeight);
    }

    updateMobileBackground();

    window.addEventListener('orientationchange', function() {
      console.log('√∞≈∏‚Äù‚Äû Orientation change detected');
      setTimeout(updateMobileBackground, 50);
      setTimeout(updateMobileBackground, 200);
      setTimeout(updateMobileBackground, 500);
    });

    let resizeTimeout;
    window.addEventListener('resize', function() {
      if (isMobile()) {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateMobileBackground, 100);
      }
    });
    
    info.textContent = 'üéÆ Initializing 4-Player Glass Tube Game...';

    let socket = null;
    let gameState = null;
    let playerSlot = -1;
    let isServerSideMode = true; // Enable server-side physics
    
    function initializeSocket() {
      if (typeof io === 'undefined') {
        console.error('√¢¬ù≈í Socket.io not loaded');
        return;
      }
      
      socket = io();
      
      socket.on('connect', () => {
        console.log('√¢≈ì‚Ä¶ Connected to server');
        
        const savedState = loadGameState();
        
        if (gameIdParam && walletParam) {
          socket.emit('physics_join_room', {
            roomId: `game_${gameIdParam}`,
            address: walletParam,
            savedState: savedState // √¢‚Ä†¬ê Send saved state to server
          });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('√¢¬ù≈í Disconnected from server');
      });
      
      socket.on('reconnect', () => {
        console.log('√∞≈∏‚Äù‚Äû Reconnecting to server...');
        
        const savedState = loadGameState();
        
        if (gameIdParam && walletParam) {
          socket.emit('physics_rejoin_room', {
            roomId: `game_${gameIdParam}`,
            address: walletParam,
            lastKnownSlot: playerSlot,
            savedState: savedState, // √¢‚Ä†¬ê Send saved state to server
            disconnectTime: savedState?.timestamp || Date.now() // √¢‚Ä†¬ê Send disconnect time
          });
        }
      });

      socket.on('game_state_restored', (data) => {
        console.log('√¢≈ì‚Ä¶ Game state restored:', data);
        
        if (data.playerChoices) {
          Object.keys(data.playerChoices).forEach(slot => {
            const slotIndex = parseInt(slot);
            if (players[slotIndex]) {
              players[slotIndex].choice = data.playerChoices[slot];
              updatePlayerCardChoice(slotIndex, data.playerChoices[slot]);
            }
          });
        }
        
        if (data.coinSelections) {
          data.coinSelections.forEach((selection, index) => {
            if (selection && tubes[index]) {
              tubes[index].selectedCoin = coinOptions.find(c => c.id === selection.coinId) || coinOptions[0];
              tubes[index].selectedMaterial = coinMaterials.find(m => m.id === selection.materialId) || coinMaterials[0];
              applyCoinSelection(index, tubes[index].selectedCoin, tubes[index].selectedMaterial);
            }
          });
        }
        
        if (data.phase) {
          gameState = { ...gameState, phase: data.phase };
          if (data.phase === 'game_over') {
            gameOver = true;
            handleGameEnd(data);
          }
        }
      });
      
      socket.on('physics_state_update', (state) => {
        console.log('√∞≈∏‚Äú≈† Received physics state update:', {
          phase: state?.phase,
          currentRound: state?.currentRound,
          roundTimer: state?.roundTimer,
          players: state?.players ? Object.keys(state.players).length : 0
        });
        gameState = state;
        updateClientFromServerState(state);
        
        createMobilePlayerCards();
      });
      
      socket.on('physics_coin_flip_start', (data) => {
        console.log('ü™ô Coin flip started:', data);
        startClientCoinFlipAnimation(data);
      });
      
      socket.on('physics_coin_result', (data) => {
        console.log('√∞≈∏≈Ω¬≤ Coin flip result:', data);
        showCoinFlipResult(data);
      });
      
      socket.on('physics_power_charging', (data) => {
        console.log('√¢≈°¬° Power charging:', data);
        updatePowerChargingVisual(data);
      });
      
      socket.on('physics_power_charging_start', (data) => {
        console.log('√¢≈°¬° Received charging start:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = true;
            tube.power = 0;
            tube.chargingStartTime = Date.now();
            console.log(`√∞≈∏≈í≈† Started pearl animation for tube ${data.playerSlot + 1}`);
            
            if (tube.liquidParticleMeshes) {
              tube.liquidParticleMeshes.forEach(mesh => {
                mesh.visible = true;
              });
              console.log(`√∞≈∏≈í≈† Forced pearl visibility on charging start for tube ${data.playerSlot + 1}`);
            }
          }
        }
      });

      socket.on('physics_power_charging_stop', (data) => {
        console.log('√¢≈°¬° Received charging stop:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = false;
            tube.power = data.finalPower || tube.power;
            console.log(`√∞≈∏‚Ä∫‚Äò Stopped pearl animation for tube ${data.playerSlot + 1} at ${tube.power}%`);
          }
        }
      });
      
      socket.on('physics_coin_angle_update', (data) => {
        console.log('√∞≈∏≈Ω¬Ø Coin angle update:', data);
        updateCoinAngleVisual(data);
      });
      
      socket.on('flip_tokens_awarded', (data) => {
        console.log('√∞≈∏‚Äô¬∞ FLIP tokens awarded:', data);
        if (data.success) {
          showFloatingMessage(`+${data.amount} FLIP earned!`, '#FFD700', 3000);
        } else {
          console.error('√¢¬ù≈í Failed to award FLIP tokens:', data.error);
        }
      });

      socket.on('flip_tokens_awarded_final', (data) => {
        console.log('√∞≈∏≈Ω¬Å FLIP tokens awarded:', data);
        if (data.success) {
          showFloatingMessage(`+${data.totalFlip} FLIP tokens added to your profile!`, '#00ff00', 4000);
        } else {
          console.error('√¢¬ù≈í FLIP token award failed:', data.error);
          showFloatingMessage(`Failed to award FLIP tokens: ${data.error}`, '#ff0000', 3000);
        }
      });

      socket.on('flip_tokens_collected', (data) => {
        console.log('√∞≈∏‚Äô≈Ω FLIP tokens collected:', data);
        if (data.success) {
          showFloatingMessage(`Successfully claimed ${data.amount} FLIP!`, '#00ff00', 3000);
        }
      });

      socket.on('nft_prize_claimed', (data) => {
        console.log('√∞≈∏¬è‚Ä† NFT prize claimed:', data);
        if (data.success) {
          const nftBtn = document.getElementById('claim-nft-btn');
          if (nftBtn) {
            nftBtn.textContent = '√¢≈ì‚Ä¶ NFT Claimed!';
            nftBtn.style.background = 'linear-gradient(135deg, #888, #666)';
            nftBtn.disabled = true;
          }
          showFloatingMessage('NFT successfully transferred to your wallet!', '#FFD700', 3000);
        }
      });
      
      socket.on('physics_error', (error) => {
        console.error('√¢¬ù≈í Physics error:', error);
        
        const playerIndex = players.findIndex(p => p.address === walletParam);
        if (playerIndex !== -1 && tubes[playerIndex]) {
          tubes[playerIndex].isFilling = false;
          tubes[playerIndex].power = 0;
          tubes[playerIndex].powerLevel = 0;
          isCharging = false;
          
          if (powerChargeSound && !powerChargeSound.paused) {
            powerChargeSound.pause();
            powerChargeSound.currentTime = 0;
          }
          
          console.log(`√∞≈∏‚Äù‚Äû Reset tube ${playerIndex + 1} state after error`);
        }
        
        alert(`Game Error: ${error.message}`);
      });
      
      socket.on('player_choice_update', (data) => {
        console.log('√∞≈∏≈Ω¬Ø Player choice update:', data);
        updatePlayerChoice(data);
      });
      
      socket.on('coin_update', (data) => {
        console.log('ü™ô Coin update received:', data);
        updateCoinFromServer(data);
      });
      
      socket.on('player_flip_action', (data) => {
        console.log('√∞≈∏≈Ω¬∞ Player flip action:', data);
      });
      
      socket.on('glass_shatter', (data) => {
        console.log('√∞≈∏‚Äô¬• Glass shatter:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          shatterGlass(data.playerSlot, data.power);
        }
      });
    }
    
    function updateClientFromServerState(state) {
      if (gameOver && state && state.phase !== 'game_over') {
        console.log('√∞≈∏‚Ä∫‚Äò Ignoring state update after game over:', state.phase)
        return
      }
      if (!state) return;
      
      if (state.phase === 'round_active' && !gameOver) {
        const existingIndicator = document.getElementById('game-phase-indicator');
        if (existingIndicator) {
          existingIndicator.remove();
        }
        console.log(`üéÆ Game is now round_active - Round ${state.currentRound}`);
        
        updatePlayerCardButtons();
        } else if (state.phase === 'game_over') {
          console.log(`√∞≈∏¬è¬Å GAME OVER DETECTED!`, {
            phase: state.phase,
            winner: state.winner,
            gameOver: gameOver,
            players: players.map(p => ({ name: p.name, address: p.address }))
          });
          
          if (state.winner) {
            const winnerIndex = players.findIndex(p => p.address && p.address.toLowerCase() === state.winner.toLowerCase());
            console.log(`√∞≈∏‚Äù¬ç Winner search:`, {
              winnerAddress: state.winner,
              winnerIndex: winnerIndex,
              players: players.map(p => ({ name: p.name, address: p.address }))
            });
            
            if (winnerIndex >= 0) {
              console.log(`√∞≈∏¬è‚Ä† Server declared winner: ${players[winnerIndex].name}`);
              showGameOverScreen(winnerIndex, players[winnerIndex].name);
            } else {
              console.log(`√∞≈∏¬è‚Ä† Server declared winner but couldn't find player: ${state.winner}`);
              showGameOverScreen(-1, state.winner);
            }
          } else {
            console.log(`√∞≈∏¬è‚Ä† Server declared game over with no winner`);
            showGameOverScreen(-1, null);
          }
        }
      
      if (state.players && walletParam) {
        const normalizedAddress = walletParam.toLowerCase();
        const player = state.players[normalizedAddress];
        if (player) {
          playerSlot = player.slotNumber;
          console.log(`üéÆ Player slot: ${playerSlot}`);
          
          if (playerSlot >= 0 && playerSlot < 4) {
            tubes[playerSlot].isCurrentPlayer = true;
            players[playerSlot].isCurrentPlayer = true;
          }
          
          updatePlayerCardButtons();
        }
        
        Object.keys(state.players).forEach(address => {
          const serverPlayer = state.players[address];
          if (serverPlayer && serverPlayer.slotNumber >= 0 && serverPlayer.slotNumber < 4) {
            const localPlayer = players[serverPlayer.slotNumber];
            if (localPlayer && !localPlayer.isEmpty) {
              if (serverPlayer.choice !== localPlayer.choice) {
                console.log(`√∞≈∏‚Äù‚Äû Syncing player ${serverPlayer.slotNumber + 1} choice: ${serverPlayer.choice || 'null'} (was: ${localPlayer.choice || 'null'})`);
                localPlayer.choice = serverPlayer.choice;
                
                const tube = tubes[serverPlayer.slotNumber];
                if (tube && tube.cardElement) {
                  const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
                  const choiceBadge = tube.cardElement.querySelector('.choice-badge');
                  
                  if (choiceButtons && choiceBadge) {
                    if (serverPlayer.choice) {
                      choiceButtons.style.display = 'none';
                      choiceBadge.style.display = 'inline-block';
                      choiceBadge.textContent = serverPlayer.choice.toUpperCase();
                      choiceBadge.className = `choice-badge ${serverPlayer.choice}`;
                    } else {
                      choiceBadge.style.display = 'none';
                      if (playerSlot === serverPlayer.slotNumber) {
                        choiceButtons.style.display = 'flex';
                      } else {
                        choiceButtons.style.display = 'none';
                      }
                    }
                  }
                }
              }
              
              if (serverPlayer.wins !== undefined && localPlayer.wins !== serverPlayer.wins) {
                localPlayer.wins = serverPlayer.wins;
                updateWinsDisplay(serverPlayer.slotNumber);
              }
            }
          }
        });
      }
      
      if (state.roundTimer !== undefined) {
        updateTimerDisplay(state.roundTimer);
      }
      
      if (state.currentRound !== undefined) {
        const oldRound = currentRound;
        currentRound = state.currentRound;
        updateRoundDisplay();
        saveGameState();
        
        if (currentRound > oldRound) {
          console.log(`√∞≈∏"‚Äû Round ${currentRound} started - FULL RESET`);
          tubes.forEach((tube, i) => {
            tube.hasUsedPower = false;
            tube.power = 0;
            tube.isFilling = false;
            tube.foamIntensity = 0;
            
            tube.isShattered = false;
            // ‚úÖ Reset animation state machine
            tube.animationState = 'idle';
            tube.animationStartTime = null;
            tube.animationEndTime = null;
            tube.flipId = null;
            tube.landingId = null;
            tube.lastStableRotation = null;
            // Old properties (backwards compatibility)
            tube.isFlipping = false;
            tube.isLanding = false; // √¢≈ì‚Ä¶ FIX: Clear landing flag
            tube.flipStartTime = null; // Clear flip tracking
            tube.currentFlipId = null; // Clear flip ID
            tube.currentLandingId = null; // √¢≈ì‚Ä¶ FIX: Clear landing ID
            
            tube.tube.visible = true;
            tube.backing.visible = true;
            tube.topRim.visible = true;
            tube.bottomRim.visible = true;
            tube.liquid.visible = true;
            tube.coinShadow.visible = false;
            
            if (tube.glassShards && tube.glassShards.length > 0) {
              tube.glassShards.forEach(shard => {
                scene.remove(shard.mesh);
              });
              tube.glassShards = [];
            }
            
            if (!physicsWorld.bodies.includes(tube.glassBody)) {
              physicsWorld.addBody(tube.glassBody);
            }
            
            updatePearlColors(tube, 0, i);
            
            tube.liquidParticles.forEach((particleBody, idx) => {
              const angle = Math.random() * Math.PI * 2;
              const radius = Math.random() * (TUBE_RADIUS - 25);
              const pearlX = tube.tube.position.x + Math.cos(angle) * radius;
              const pearlZ = Math.sin(angle) * radius;
              const pearlY = 200 - (TUBE_HEIGHT / 2) + 30 + Math.random() * 60;
              
              particleBody.position.set(pearlX, pearlY, pearlZ);
              particleBody.velocity.set(0, 0, 0);
              particleBody.angularVelocity.set(0, 0, 0);
              
              if (tube.liquidParticleMeshes[idx]) {
                tube.liquidParticleMeshes[idx].visible = true;
              }
            });
            
            tube.liquidLight.color.setHex(0x1a1a2e); // Dark blue-grey
            tube.liquidLight.intensity = 0.3;
            
            const coin = coins[i];
            if (coin) {
              coin.position.set(tube.tube.position.x, 200, 0);
              // Original orientation: coins facing the player (standing on edge)
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
              coin.quaternion.setFromEuler(coin.rotation); // Sync quaternion
              
              if (tube.winLight) {
                coin.remove(tube.winLight);
                tube.winLight = null;
              }
              if (tube.loseLight) {
                coin.remove(tube.loseLight);
                tube.loseLight = null;
              }
            }
            
            if (tube.resultBox) {
              scene.remove(tube.resultBox);
              tube.resultBox = null;
            }
            
            if (tube.cardElement) {
              const powerButton = tube.cardElement.querySelectorAll('.action-btn')[0]; // Fixed: was [1], now [0]
              if (powerButton) {
                powerButton.style.background = 'linear-gradient(135deg, #9d00ff, #c44aff)';
                powerButton.style.color = '#ffffff';
                powerButton.style.borderColor = '#9d00ff';
                powerButton.disabled = false;
                powerButton.style.opacity = '1';
                powerButton.style.cursor = 'pointer';
              }
              
              const powerFill = tube.cardElement.querySelector('.power-fill');
              const powerValue = tube.cardElement.querySelector('.power-value');
              if (powerFill) {
                powerFill.style.width = '0%';
              }
              if (powerValue) {
                powerValue.textContent = '0';
              }
            }
          });
          
          players.forEach((player, i) => {
            if (!player.isEmpty) {
              player.choice = null;
              
              const tube = tubes[i];
              if (tube && tube.cardElement) {
                const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
                const choiceBadge = tube.cardElement.querySelector('.choice-badge');
                
                if (choiceButtons && choiceBadge) {
                  choiceBadge.style.display = 'none';
                  if (playerSlot === i) {
                    choiceButtons.style.display = 'flex';
                    
                    const choiceBtnElements = tube.cardElement.querySelectorAll('.choice-btn');
                    choiceBtnElements.forEach(btn => {
                      btn.style.opacity = '1';
                      btn.style.transform = 'scale(1)';
                      btn.style.boxShadow = '';
                    });
                  } else {
                    choiceButtons.style.display = 'none';
                  }
                }
              }
            }
          });
          
          const mobileHeadsBtn = document.getElementById('mobile-heads');
          const mobileTailsBtn = document.getElementById('mobile-tails');
          if (mobileHeadsBtn && mobileTailsBtn) {
            mobileHeadsBtn.classList.remove('selected');
            mobileTailsBtn.classList.remove('selected');
          }
          
          const mobilePowerFill = document.getElementById('mobile-power-fill');
          const mobilePowerValue = document.querySelector('#mobile-power-text .power-value');
          if (mobilePowerFill && mobilePowerValue) {
            mobilePowerFill.style.width = '0%';
            mobilePowerValue.textContent = '0';
          }
          
          console.log(`√¢≈ì‚Ä¶ Round ${currentRound} reset complete - players can charge and choose again`);
          
          updatePlayerCardButtons();
        }
      }
      
      if (state.coinStates) {
        updateCoinStatesFromServer(state.coinStates);
      }
      
      updateCoinRotationsFromPlayerChoices();
    }
    
    function updateCoinRotationsFromPlayerChoices() {
      tubes.forEach((tube, i) => {
        const player = players[i];
        const coin = coins[i];
        
        // √¢≈ì‚Ä¶ FIX: Also skip if coin is landing!
        if (coin && !tube.isFlipping && !tube.isShattered) {
          if (player && !player.isEmpty) {
            // Only update rotation if player has made a choice and coin is not flipping
            if (player.choice === 'heads') {
              // Show heads face (standing on edge, heads facing camera)
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            } else if (player.choice === 'tails') {
              // Show tails face (standing on edge, tails facing camera)
              coin.rotation.x = 3 * Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            } else {
              // If no choice made, default to standing on edge (heads position)
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            }
          } else {
            // For empty players, ensure coin is in default upright position (not sideways)
            coin.rotation.x = Math.PI / 2;
            coin.rotation.y = Math.PI / 2;
            coin.rotation.z = 0;
          }
        }
      });
    }
    
    function updateCoinStatesFromServer(coinStates) {
      if (coinStates) {
        coinStates.forEach((coinState, index) => {
          if (coinState && coinState.position) {
            const coin = coins[index];
            const tube = tubes[index];
            if (coin && tube) {
              // CRITICAL: Don't update anything from server during local animations
              // The client animation handles everything during flipping
              if (tube.animationState === 'idle') {
                const tubeX = tube.tube.position.x;
                coin.position.set(tubeX, coinState.position.y, coinState.position.z);
                
                if (coinState.rotation && !coinState.isFlipping) {
                  // CRITICAL: Use rotation, not quaternion, to avoid conflicts with animation
                  // Quaternions override Euler rotations, which breaks our animation
                  const euler = new THREE.Euler();
                  euler.setFromQuaternion(new THREE.Quaternion(
                    coinState.rotation.x,
                    coinState.rotation.y,
                    coinState.rotation.z,
                    coinState.rotation.w
                  ));
                  coin.rotation.copy(euler);
                  coin.quaternion.set(0, 0, 0, 1); // Reset quaternion so rotation takes precedence
                } else {
                  updateCoinRotationsFromPlayerChoices();
                }
              }
              
              // Update animation state based on server - but only if we're idle
              // Don't let server override our active animations!
              if (coinState.isFlipping && tube.animationState === 'idle') {
                // Server says flip started - let client handle it via physics_coin_flip_start event
                // Don't set state here as that event handler will do it properly
              } else if (!coinState.isFlipping && tube.animationState === 'flipping') {
                // Server says not flipping but we're animating - don't interfere!
                // Only reset if animation has been running for more than expected duration (10s)
                if (Date.now() - tube.animationStartTime > 10000) {
                  console.warn(`‚ö†Ô∏è Animation running too long, resetting state`);
                  tube.animationState = 'idle';
                  tube.animationEndTime = Date.now();
                }
              }
            }
          }
        });
      }
    }
    
    function startClientCoinFlipAnimation(data) {
      console.log('√∞≈∏≈Ω¬Å Received flip reward data:', data.flipReward);
      console.log('√∞≈∏≈Ω¬Å Full data object:', data);
      
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        
        if (tube && coin) {
          // √¢≈ì‚Ä¶ FIX: Check if already flipping and skip if so
          if (tube.animationState !== 'idle') {
            console.log(`√¢≈° √Ø¬∏ Coin ${data.playerSlot + 1} already flipping, ignoring duplicate flip request`);
            return;
          }
          
          // √¢≈ì‚Ä¶ FIX: Set state BEFORE starting animation
          // Generate unique flip ID
          const flipId = `flip_${data.playerSlot}_${Date.now()}`;
          
          // Set animation state with timestamps
          tube.animationState = 'flipping';
          tube.animationStartTime = Date.now();
          tube.animationEndTime = Date.now() + (data.duration || 8000);
          tube.flipId = flipId;
          
          // Store current rotation as starting point
          tube.lastStableRotation = {
            x: coin.rotation.x,
            y: coin.rotation.y,
            z: coin.rotation.z
          };
          
          // Ensure rotation order is set correctly
          coin.rotation.order = 'XYZ';
          
          console.log(`üé¨ Starting flip animation for coin ${data.playerSlot + 1} with ID: ${flipId}`);
          
          animateCoinFlip(data.playerSlot, data.power, data.duration);
          showFlipReward(data.playerSlot, data.flipReward);
        }
      }
    }
    
    function showCoinFlipResult(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        const player = players[data.playerSlot];
        
        if (tube && coin && player) {
          // √¢≈ì‚Ä¶ FIX: Ensure we're actually in a flipping state before showing result
          if (!tube.isFlipping && !tube.flipStartTime) {
            console.log(`√¢≈° √Ø¬∏ Received result for coin ${data.playerSlot + 1} but it's not flipping - ignoring stale result`);
            return;
          }
          
          // ‚úÖ CRITICAL FIX: Update animation state to landing
          // This prevents updateCoinRotationsFromPlayerChoices() from interfering
          tube.animationState = 'landing';
          
          // ‚úÖ Clear flip state
          tube.flipId = null;
          
          // Start landing immediately - no delay, no vulnerability window!
          // Note: smoothLandCoin will let the coin decelerate naturally and land where physics stops it
          const targetRotationX = data.result === 'heads' ? Math.PI / 2 : (3 * Math.PI / 2);
          smoothLandCoin(coin, targetRotationX, data.accuracy || 'normal', tube, data.playerSlot);
          
          console.log(`√¢≈ì‚Ä¶ Coin ${data.playerSlot + 1} landing to ${data.result} (server-side)`);
          
          if (data.wins !== undefined) {
            player.wins = data.wins;
            console.log(`√∞≈∏"≈† Updated player ${data.playerSlot + 1} wins from server: ${player.wins}`);
            updateWinsDisplay(data.playerSlot);
          }
          
          // √¢≈ì‚Ä¶ FIX: Show result AFTER landing completes
          setTimeout(() => {
            showResult(data.playerSlot, data.won, data.result);
          }, 1300); // Wait for 1.2s landing + 100ms buffer
        }
      }
    }
    
    // √¢≈ì‚Ä¶ NEW FUNCTION: Smooth landing that takes over from current rotation
    function smoothLandCoin(coin, targetRotation, accuracy, tube, playerSlot) {
      const startRotation = coin.rotation.x;
      const startY = coin.rotation.y;
      const startZ = coin.rotation.z;
      
      // ‚úÖ FIX: Set landing state to prevent other functions from overriding rotation
      tube.animationState = 'landing';
      tube.landingId = `landing_${playerSlot}_${Date.now()}`;
      
      // ‚úÖ NEW: Let coin decelerate naturally instead of forcing to target
      // The coin will naturally slow down and land where physics stops it
      const landingDuration = 1200; // Smooth 1.2 second deceleration
      const startTime = Date.now();
      
      // Track rotation velocity for natural deceleration
      let lastRotation = startRotation;
      const initialSpeed = 0.15; // Base rotation speed when landing starts
      let currentSpeed = initialSpeed;
      
      console.log(`üéØ Landing coin ${playerSlot + 1} naturally: starting from ${startRotation.toFixed(2)}`);
      
      const savedLandingId = tube.landingId; // Save for comparison
      
      const animateLanding = () => {
        // ‚úÖ FIX: Stop if landing was interrupted
        if (tube.landingId !== savedLandingId || tube.animationState !== 'landing') {
          console.log(`üõë Landing animation stopped for coin ${playerSlot + 1} - interrupted`);
          tube.animationState = 'idle';
          return;
        }
        
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / landingDuration, 1);
        
        // Natural deceleration - exponential decay
        currentSpeed = initialSpeed * Math.pow(0.92, progress * 15);
        
        // Apply decelerating rotation
        if (progress < 1) {
          coin.rotation.x += currentSpeed;
          
          // Gradually stabilize Y and Z rotations
          const easeOutQuart = 1 - Math.pow(1 - progress, 4);
          coin.rotation.y = startY + (Math.PI / 2 - startY) * easeOutQuart;
          coin.rotation.z = startZ * (1 - easeOutQuart);
          
          // Sync quaternion
          coin.quaternion.setFromEuler(coin.rotation);
          
          requestAnimationFrame(animateLanding);
        } else {
          // Final position - lock coin to final rotation based on result
          const finalCycles = Math.floor(coin.rotation.x / (Math.PI * 2));
          coin.rotation.x = finalCycles * (Math.PI * 2) + targetRotation;
          coin.rotation.y = Math.PI / 2;
          coin.rotation.z = 0;
          coin.quaternion.setFromEuler(coin.rotation);
          
          tube.animationState = 'idle';
          tube.landingId = null;
          console.log(`‚úÖ Coin ${playerSlot + 1} landed on target rotation ${coin.rotation.x.toFixed(2)} facing camera (server-side)`);
        }
      };
      
      animateLanding();
    }
    
    function updatePowerChargingVisual(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        if (!tube) return;
        
        tube.power = data.power;
        tube.powerLevel = data.powerLevel || Math.min(5, Math.max(1, Math.ceil(data.power / 20)));
        tube.isFilling = data.isFilling;
        
        const powerPercent = tube.power / 100;
        tube.foamIntensity = powerPercent;
        
        console.log(`√¢≈°¬° Updated power visual for player ${data.playerSlot + 1}: ${data.power}% (level ${tube.powerLevel}, foamIntensity: ${tube.foamIntensity}, isFilling: ${tube.isFilling})`);
        
        updatePearlColors(tube, powerPercent, data.playerSlot);
        
        if (tube.liquidParticleMeshes && tube.liquidParticleMeshes.length > 0) {
          const visibleCount = tube.liquidParticleMeshes.filter(mesh => mesh.visible).length;
          console.log(`√∞≈∏‚Äù¬ç Tube ${data.playerSlot + 1} has ${tube.liquidParticleMeshes.length} pearls, ${visibleCount} visible`);
        }
        
        if (tube.isFilling && tube.liquidParticleMeshes) {
          tube.liquidParticleMeshes.forEach(mesh => {
            mesh.visible = true;
          });
          console.log(`√∞≈∏≈í≈† Forced pearl visibility for tube ${data.playerSlot + 1}`);
        }
      }
    }
    
    function updatePearlColors(tube, powerPercent, tubeIndex) {
      const darkPearl = new THREE.Color(0x1a1a1a); // Dark grey (neutral start)
      
      const neonColors = [
        new THREE.Color(0x00ff00), // Tube 1: NEON GREEN
        new THREE.Color(0x00ddff), // Tube 2: NEON BLUE
        new THREE.Color(0xff0088), // Tube 3: NEON PINK
        new THREE.Color(0xffff00)  // Tube 4: NEON YELLOW
      ];
      
      const neonColor = neonColors[tubeIndex] || neonColors[0];
      const currentColor = darkPearl.clone().lerp(neonColor, powerPercent);
      
      tube.liquidParticleMeshes.forEach(particleMesh => {
        particleMesh.material.color.copy(currentColor);
        particleMesh.material.emissive.copy(currentColor);
        particleMesh.material.emissiveIntensity = 0.2 + (powerPercent * 25.0); // 0.2 to 25.2 - Perfect with bloom!
      });
      
      tube.liquidLight.color.copy(currentColor);
      tube.liquidLight.intensity = 0.3 + (powerPercent * 15.0); // 0.3 to 15.3 - MEGA INTENSE!
    }

    function updatePearlPhysics(tube, powerPercent, tubeIndex, frameCount) {
      const spinForce = powerPercent * 1200; // Orbital force
      const buoyancyForce = powerPercent * 800; // Upward float force
      
      tube.liquidParticles.forEach((particleBody, idx) => {
        particleBody.force.y += buoyancyForce;
        
        const dx = particleBody.position.x - tube.tube.position.x;
        const dz = particleBody.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 1) {
          const angle = Math.atan2(dz, dx);
          const tangentAngle = angle + Math.PI / 2; // 90 degrees to create orbit
          
          const orbitForceX = Math.cos(tangentAngle) * spinForce * (1 + idx * 0.05);
          const orbitForceZ = Math.sin(tangentAngle) * spinForce * (1 + idx * 0.05);
          
          particleBody.force.x += orbitForceX;
          particleBody.force.z += orbitForceZ;
        }
        
        const chaos = Math.sin(frameCount * 0.2 + idx) * 200 * powerPercent;
        particleBody.force.x += chaos;
        particleBody.force.z += Math.cos(frameCount * 0.2 + idx * 1.3) * 200 * powerPercent;
      });
    }
    
    
    function updateCoinFromServer(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        const player = players[data.playerSlot];
        
        if (tube && coin && player && data.coinData) {
          console.log(`ü™ô Updating coin for player ${data.playerSlot + 1}: ${data.coinData.name}`);
          
          tube.selectedCoin = data.coinData;
          tube.selectedMaterial = coinMaterials.find(m => m.id === data.coinData.material) || coinMaterials[0];
          
          const textureLoader = new THREE.TextureLoader();
          textureLoader.load(data.coinData.headsImage, (headsTex) => {
            headsTex.minFilter = THREE.LinearFilter;
            headsTex.magFilter = THREE.LinearFilter;
            headsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
            headsTex.generateMipmaps = false;
            
            textureLoader.load(data.coinData.tailsImage, (tailsTex) => {
              tailsTex.minFilter = THREE.LinearFilter;
              tailsTex.magFilter = THREE.LinearFilter;
              tailsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
              tailsTex.generateMipmaps = false;
              
              coin.material[1].uniforms.map.value = headsTex;
              coin.material[1].needsUpdate = true;
              coin.material[2].uniforms.map.value = tailsTex;
              coin.material[2].needsUpdate = true;
              
              const edgeColor = new THREE.Color(tube.selectedMaterial.edgeColor);
              coin.material[0].color.copy(edgeColor);
              coin.material[0].emissive.copy(edgeColor);
              coin.material[0].emissiveIntensity = 0.3;
              coin.material[0].needsUpdate = true;
              
              console.log(`√¢≈ì‚Ä¶ Applied ${data.coinData.name} with ${tube.selectedMaterial.name} material to ${player.name}'s coin`);
            });
          });
        }
      }
    }
    
    function updateCoinAngleVisual(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const coin = coins[data.playerSlot];
        const tube = tubes[data.playerSlot];
        if (coin && tube && tube.animationState === 'idle') {
          const angleRad = (data.angle * Math.PI) / 180;
          coin.rotation.z = angleRad;
        }
      }
    }
    
    function updatePlayerChoice(data) {
      console.log('√∞≈∏≈Ω¬Ø Updating player choice:', data);
      
      let playerIndex = -1;
      
      if (data.playerSlot !== undefined && data.playerSlot >= 0 && data.playerSlot < 4) {
        playerIndex = data.playerSlot;
      } else if (data.address) {
        const normalizedAddress = data.address.toLowerCase();
        playerIndex = players.findIndex(p => p.address && p.address.toLowerCase() === normalizedAddress);
      }
      
      if (playerIndex >= 0 && playerIndex < 4) {
        const player = players[playerIndex];
        if (player && !player.isEmpty) {
          player.choice = data.choice;
          console.log(`√¢≈ì‚Ä¶ Updated player ${playerIndex + 1} choice to: ${data.choice}`);
          
          const tube = tubes[playerIndex];
          if (tube && tube.cardElement) {
            const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
            const choiceBadge = tube.cardElement.querySelector('.choice-badge');
            
            if (choiceButtons && choiceBadge) {
              choiceButtons.style.display = 'none';
              choiceBadge.style.display = 'inline-block';
              choiceBadge.textContent = data.choice.toUpperCase();
              choiceBadge.className = `choice-badge ${data.choice}`;
            }
          }
          
          updateCoinRotationsFromPlayerChoices();
        }
      }
    }
    
    initializeSocket();

    
    function updatePlayerCardButtons() {
      tubes.forEach((tube, i) => {
        if (tube.cardElement) {
          const player = players[i];
          if (!player || player.isEmpty) return;
          
          const isCurrentPlayer = isServerSideMode ? (playerSlot === i) : true;
          
          const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
          const choiceBadge = tube.cardElement.querySelector('.choice-badge');
          
          if (isCurrentPlayer) {
            if (player.choice) {
              if (choiceButtons) choiceButtons.style.display = 'none';
              if (choiceBadge) {
                choiceBadge.style.display = 'inline-block';
                choiceBadge.textContent = player.choice.toUpperCase();
                choiceBadge.className = `choice-badge ${player.choice}`;
              }
            } else {
              if (choiceBadge) choiceBadge.style.display = 'none';
              if (choiceButtons) choiceButtons.style.display = 'flex';
            }
          } else if (player.choice) {
            if (choiceButtons) choiceButtons.style.display = 'none';
            if (choiceBadge) choiceBadge.style.display = 'block';
          } else {
            if (choiceButtons) choiceButtons.style.display = 'none';
            if (choiceBadge) choiceBadge.style.display = 'none';
          }
          
          const actionButtons = tube.cardElement.querySelectorAll('.action-btn');
          
          if (isCurrentPlayer) {
            actionButtons.forEach(btn => {
              btn.style.display = 'block';
              btn.style.pointerEvents = 'auto';
            });
            console.log(`√∞≈∏≈Ω¬Ø Power button for slot ${i}: display=block, pointerEvents=auto`);
          } else {
            actionButtons.forEach(btn => btn.style.display = 'none');
          }
          
          console.log(`√∞≈∏≈Ω¬Ø Updated buttons for slot ${i}: isCurrentPlayer=${isCurrentPlayer}, hasChoice=${!!player.choice}`);
        }
      });
    }

    
    function updateRoundDisplay() {
      const roundElement = document.getElementById('round-number');
      if (roundElement) {
        roundElement.textContent = currentRound;
      }
      
      const mobileRoundElement = document.getElementById('round-number-mobile');
      if (mobileRoundElement) {
        mobileRoundElement.textContent = currentRound;
      }
    }
    
    function animateCoinFlip(playerSlot, power, duration) {
      const tube = tubes[playerSlot];
      const coin = coins[playerSlot];
      
      if (!tube || !coin) return;
      
      // √¢≈ì‚Ä¶ FIX: Already set in startClientCoinFlipAnimation, but double-check
      // State already set in startClientCoinFlipAnimation
      if (tube.animationState !== 'flipping') {
        console.log(`‚ö†Ô∏è animateCoinFlip called but state is ${tube.animationState}`);
        return;
      }
      
      const powerPercent = power / 100;
      const material = tube.selectedMaterial || coinMaterials[2];
      const speedMult = material.speedMultiplier;
      const durationMult = material.durationMultiplier;
      
      const flipDuration = duration || (2000 + (powerPercent * 6000)) * durationMult;
      const basePowerSpeed = Math.max(0.08, 0.05 + (powerPercent * 0.25));
      const flipSpeed = basePowerSpeed * speedMult;
      
      const wobbleAmount = 0.02 + (powerPercent * 0.05); // More power = more wobble
      const tumbleAmount = 0.01 + (powerPercent * 0.03);
      
      console.log(`√∞≈∏≈Ω¬¨ Starting visual coin flip for slot ${playerSlot}: duration=${flipDuration}ms, speed=${flipSpeed}`);
      
      const startTime = Date.now();
      const flipId = tube.flipId; // Use the flip ID from tube state
      
      if (!flipId) {
        console.error(`‚ùå ERROR: No flipId in tube state for slot ${playerSlot}! Animation cannot start.`);
        console.error('Tube state:', { animationState: tube.animationState, flipId: tube.flipId });
        return;
      }
      
      console.log(`üé¨ animateCoinFlip: Starting animation loop for slot ${playerSlot} with flipId: ${flipId}`);
      console.log(`üé¨ Coin initial rotation: x=${coin.rotation.x.toFixed(3)}, y=${coin.rotation.y.toFixed(3)}, z=${coin.rotation.z.toFixed(3)}`);
      console.log(`üé¨ Flip speed: ${flipSpeed.toFixed(4)}, Duration: ${flipDuration}ms`);
      
      let wobblePhase = 0;
      let tumblePhase = 0;
      
      const animateFlip = () => {
        // Stop animation if this flip was superseded or interrupted
        if (tube.flipId !== flipId || tube.animationState !== 'flipping') {
          console.log(`üõë Animation stopped for slot ${playerSlot}:`, {
            flipIdMatch: tube.flipId === flipId,
            currentState: tube.animationState,
            expectedFlipId: flipId,
            actualFlipId: tube.flipId
          });
          return;
        }
        
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / flipDuration, 1);
        
        const easeOut = 1 - Math.pow(1 - progress, 3);
        
        // CRITICAL: Update rotation and sync quaternion
        // THREE.js needs both to stay in sync when modifying rotation directly
        coin.updateMatrix();
        
        if (progress < 0.7) {
          const currentSpeed = flipSpeed * (1 - (progress / 0.7) * 0.3);
          coin.rotation.x += currentSpeed;
          coin.quaternion.setFromEuler(coin.rotation); // Sync quaternion with rotation
          // Debug first few frames
          if (progress < 0.01) {
            console.log(`üîÑ Frame ${Math.floor(progress * 1000)}: rotation.x=${coin.rotation.x.toFixed(3)}, speed=${currentSpeed.toFixed(4)}`);
          }
        } else {
          const decelProgress = (progress - 0.7) / 0.3;
          const currentSpeed = flipSpeed * 0.7 * (1 - decelProgress);
          coin.rotation.x += currentSpeed;
          coin.quaternion.setFromEuler(coin.rotation); // Sync quaternion with rotation
        }
        
        wobblePhase += 0.15 * (1 - progress * 0.5);
        const wobbleIntensity = wobbleAmount * (1 - easeOut);
        coin.rotation.y = (Math.PI / 2) + Math.sin(wobblePhase) * wobbleIntensity;
        
        tumblePhase += 0.1 * (1 - progress * 0.5);
        const tumbleIntensity = tumbleAmount * (1 - easeOut);
        coin.rotation.z = Math.sin(tumblePhase * 0.7) * tumbleIntensity;
        
        // Sync quaternion with all rotation changes
        coin.quaternion.setFromEuler(coin.rotation);
        
        if (progress < 1) {
          requestAnimationFrame(animateFlip);
        } else {
          console.log(`√∞≈∏≈Ω¬¨ Visual flip animation complete for slot ${playerSlot}, awaiting result...`);
        }
      };
      
      animateFlip();
    }

    function calculateReleaseAccuracy(power) {
      const distanceFromCenter = Math.abs(power - 50);
      
      let accuracy, zone, winChance;
      
      if (distanceFromCenter <= 2) {
        accuracy = 'perfect';
        zone = 'SWEET SPOT!';
        winChance = 0.55;
      } else if (distanceFromCenter <= 8) {
        accuracy = 'good';
        zone = 'Nice Timing!';
        winChance = 0.525;
      } else {
        accuracy = 'normal';
        zone = null;
        winChance = 0.50;
      }
      
      console.log(`√∞≈∏≈Ω¬Ø Release accuracy: ${accuracy} at ${power}% power (${(winChance * 100).toFixed(1)}% win chance)`);
      
      return { accuracy, zone, winChance };
    }

    function showSweetSpotFeedback(zone, winChance) {
      const feedback = document.createElement('div');
      feedback.className = 'sweet-spot-feedback';
      
      const bonusPercent = ((winChance - 0.5) * 100).toFixed(1);
      
      feedback.innerHTML = `
        <div class="sweet-spot-text">${zone}</div>
        <div class="win-chance">+${bonusPercent}% Win Chance!</div>
      `;
      
      document.body.appendChild(feedback);
      
      setTimeout(() => feedback.classList.add('show'), 10);
      
      setTimeout(() => {
        feedback.classList.remove('show');
        setTimeout(() => feedback.remove(), 300);
      }, 2000);
    }

    // √¢≈ì‚Ä¶ REMOVED OLD animateCoinLanding - replaced with smoothLandCoin to prevent animation conflicts

    function showPerfectTimingEffect(coin) {
      const ringGeometry = new THREE.RingGeometry(35, 45, 32);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFD700,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.8
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      
      ring.position.copy(coin.position);
      ring.rotation.copy(coin.rotation);
      scene.add(ring);
      
      let ringProgress = 0;
      const ringDuration = 1000;
      const startTime = Date.now();
      
      const animateRing = () => {
        const elapsed = Date.now() - startTime;
        ringProgress = elapsed / ringDuration;
        
        if (ringProgress < 1) {
          const scale = 1 + ringProgress * 0.5;
          ring.scale.set(scale, scale, 1);
          ring.material.opacity = 0.8 * (1 - ringProgress);
          requestAnimationFrame(animateRing);
        } else {
          scene.remove(ring);
          ring.geometry.dispose();
          ring.material.dispose();
        }
      };
      
      animateRing();
    }

    let isMuted = false;
    const glassBreakSound = new Audio('../Sound/glassclipped.mp3');
    glassBreakSound.volume = 0.7; // Adjust volume as needed
    
    const powerChargeSound = new Audio('../Sound/powerclipped.mp3');
    powerChargeSound.volume = 0.6; // Adjust volume as needed
    powerChargeSound.loop = true; // Loop while charging
    
    function playSound(audio) {
      if (!isMuted && audio) {
        audio.currentTime = 0; // Reset to start
        audio.play().catch(err => console.log('Audio play prevented:', err));
      }
    }
    
    function stopSound(audio) {
      if (audio) {
        audio.pause();
        audio.currentTime = 0;
      }
    }
    
    function toggleMute() {
      isMuted = !isMuted;
      console.log(`√∞≈∏‚Äù≈† Sound ${isMuted ? 'MUTED' : 'UNMUTED'}`);
      
      glassBreakSound.muted = isMuted;
      powerChargeSound.muted = isMuted;
      
      return isMuted;
    }

    const COLORS = {
      cyan: 0x00ffff,
      neonGreen: 0x00ff00, // NEON GREEN
      brightGreen: 0x39ff14, // Bright neon green
      pink: 0xff1493,
      gold: 0xFFD700,
      glass: 0x88ccff
    };

    let players = [
      { id: 1, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 2, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 3, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 4, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true }
    ];

    const coinOptions = [
      { id: 'plain', name: 'Classic', headsImage: '/coins/plainh.png', tailsImage: '/coins/plaint.png', cost: 0, category: 'free' },
      { id: 'skull', name: 'Skull', headsImage: '/coins/skullh.png', tailsImage: '/coins/skullt.png', cost: 200, category: 'premium' },
      { id: 'trump', name: 'Trump', headsImage: '/coins/trumpheads.webp', tailsImage: '/coins/trumptails.webp', cost: 300, category: 'premium' },
      { id: 'mario', name: 'Mario', headsImage: '/coins/mario.png', tailsImage: '/coins/luigi.png', cost: 300, category: 'premium' },
      { id: 'stinger', name: 'Stinger', headsImage: '/coins/stingerh.png', tailsImage: '/coins/stingert.png', cost: 300, category: 'premium' },
      { id: 'dragon', name: '√©¬æ‚Ñ¢', headsImage: '/coins/dragonh.png', tailsImage: '/coins/dragont.png', cost: 300, category: 'premium' },
      { id: 'jestress', name: 'Jestress', headsImage: '/coins/jestressh.png', tailsImage: '/coins/jestresst.png', cost: 500, category: 'epic' },
      { id: 'manga', name: 'Heroine', headsImage: '/coins/mangah.png', tailsImage: '/coins/mangat.png', cost: 500, category: 'epic' },
      { id: 'pharaoh', name: 'Pharaoh', headsImage: '/coins/pharaohh.png', tailsImage: '/coins/pharaoht.png', cost: 1000, category: 'legendary' },
      { id: 'calavera', name: 'Calavera', headsImage: '/coins/calaverah.png', tailsImage: '/coins/calaverat.png', cost: 1000, category: 'legendary' }
    ];

    const coinMaterials = [
      {
        id: 'graphite',
        name: 'Graphite',
        description: 'Ultra-Light & Swift',
        edgeColor: '#1a1a1a',
        speedMultiplier: 2.0,
        durationMultiplier: 0.5,
        characteristics: 'Ultra-fast flips, chaotic motion'
      },
      {
        id: 'penny',
        name: 'Penny',
        description: 'Lightweight & Fast',
        edgeColor: '#CD7F32',
        speedMultiplier: 1.5,
        durationMultiplier: 0.7,
        characteristics: 'Fast flips, unpredictable'
      },
      {
        id: 'glass',
        name: 'Glass',
        description: 'Crystal Clear & Elegant',
        edgeColor: '#87CEEB',
        speedMultiplier: 1.3,
        durationMultiplier: 0.8,
        characteristics: 'Smooth, elegant flips'
      },
      {
        id: 'silver-dollar',
        name: 'Silver Dollar',
        description: 'Heavy & Controlled',
        edgeColor: '#C0C0C0',
        speedMultiplier: 0.7,
        durationMultiplier: 1.3,
        characteristics: 'Slow, controlled, predictable'
      },
      {
        id: 'titanium',
        name: 'Titanium',
        description: 'Ultra-Heavy & Precise',
        edgeColor: '#2D1B69',
        speedMultiplier: 0.5,
        durationMultiplier: 1.6,
        characteristics: 'Very slow, precise flips'
      }
    ];

    let currentRound = 1;
    let roundCounterElement = null;
    let timerElement = null;
    let gameOver = false;
    let roundStartWins = []; // Track wins at start of each round

    function saveGameState() {
      if (!gameIdParam || !walletParam) return;
      
      const gameState = {
        gameId: gameIdParam,
        playerSlot: playerSlot,
        currentRound: currentRound,
        playerWins: players[playerSlot]?.wins || 0,
        playerChoice: players[playerSlot]?.choice || null,
        selectedCoin: tubes[playerSlot]?.selectedCoin?.id || 'plain',
        selectedMaterial: tubes[playerSlot]?.selectedMaterial?.id || 'graphite',
        timestamp: Date.now(),
        expiresAt: Date.now() + (30 * 60 * 1000) // 30 minutes
      };
      
      const storageKey = `game_${gameIdParam}_${walletParam}`;
      localStorage.setItem(storageKey, JSON.stringify(gameState));
      console.log('√∞≈∏‚Äô¬æ Game state saved to localStorage:', gameState);
    }

    function loadGameState() {
      if (!gameIdParam || !walletParam) return null;
      
      const storageKey = `game_${gameIdParam}_${walletParam}`;
      const savedData = localStorage.getItem(storageKey);
      
      if (!savedData) {
        console.log('√∞≈∏‚Äú‚Äö No saved game state found');
        return null;
      }
      
      try {
        const gameState = JSON.parse(savedData);
        
        if (Date.now() > gameState.expiresAt) {
          console.log('√¢¬è¬∞ Saved game state expired, clearing...');
          localStorage.removeItem(storageKey);
          return null;
        }
        
        console.log('√¢≈ì‚Ä¶ Loaded game state from localStorage:', gameState);
        return gameState;
      } catch (err) {
        console.error('√¢¬ù≈í Failed to parse saved game state:', err);
        localStorage.removeItem(storageKey);
        return null;
      }
    }

    THREE.ColorManagement.enabled = true;
    
    const scene = new THREE.Scene();
    scene.background = null; // Transparent to show CSS background image
    
    const bgTextureLoader = new THREE.TextureLoader();
    const bgCandidates = roomParam === 'lab' 
      ? ['/images/background/thelab.png']
      : roomParam === 'cyber'
      ? ['/images/background/cyber.png']
      : roomParam === 'mech'
      ? ['/images/background/mech.png']
      : ['/images/background/game room2.png'];
    function loadBackground(paths, onSuccess, onFail) {
      if (!paths.length) { onFail && onFail(new Error('No background paths worked')); return; }
      const path = paths[0];
      bgTextureLoader.load(path, onSuccess, undefined, () => loadBackground(paths.slice(1), onSuccess, onFail));
    }
    loadBackground(bgCandidates, (bgTexture) => {
      bgTexture.colorSpace = THREE.SRGBColorSpace;
      bgTexture.minFilter = THREE.LinearFilter;
      bgTexture.magFilter = THREE.LinearFilter;
      
      const distanceFromCamera = 1400 - (-500); // 1900 units
      const vFOV = camera.fov * Math.PI / 180; // Convert to radians
      const planeHeight = 2 * Math.tan(vFOV / 2) * distanceFromCamera;
      const planeWidth = planeHeight * camera.aspect; // Match screen aspect ratio
      
      const bgGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: bgTexture,
        side: THREE.FrontSide,
        depthWrite: false, // Don't write to depth buffer
        depthTest: false, // Always render behind
        toneMapped: false, // CRITICAL: Don't apply tone mapping to background!
        fog: false, // Not affected by fog
        color: 0xcccccc // Slightly darkened (80% brightness) - adjust this if needed
      });
      const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
      bgPlane.position.set(0, 150, -500); // Behind the tubes
      bgPlane.renderOrder = -1; // Render first (behind everything)
      bgPlane.layers.set(0); // Layer 0 - main scene
      scene.add(bgPlane);
      scene.background = null; // Remove fallback color now that we have the texture
      console.log(`√∞≈∏‚Äì¬º√Ø¬∏¬è Background image loaded! Size: ${planeWidth.toFixed(0)}x${planeHeight.toFixed(0)} at distance ${distanceFromCamera}`);
    }, undefined, (error) => {
      console.error('√¢¬ù≈í Failed to load background image:', error);
    });

    const width = window.innerWidth;
    const height = window.innerHeight;
    const camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000); // Narrower FOV
    camera.position.set(0, 150, 1400); // Higher camera position
    camera.lookAt(0, 150, 0); // Look at raised tubes
    camera.layers.enable(0); // Default layer - tubes, coins, etc.
    camera.layers.enable(1); // Bloom layer - pearls and plasma
    console.log('√∞≈∏‚Äú¬∑ Camera positioned for shorter tubes with dual-layer support');

    const webglRenderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: true // Enable transparency for video background
    });
    webglRenderer.setSize(width, height);
    webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    webglRenderer.setClearColor(0x000000, 0); // Transparent clear color
    webglRenderer.autoClear = true;
    webglRenderer.toneMapping = THREE.ACESFilmicToneMapping; // Filmic tone mapping for vibrant colors
    webglRenderer.toneMappingExposure = 1.0; // Neutral exposure - don't brighten anything
    webglRenderer.outputColorSpace = THREE.SRGBColorSpace; // Proper color space
    console.log('√∞≈∏≈Ω¬® WebGL Renderer initialized with transparency');
    document.getElementById('container').appendChild(webglRenderer.domElement);

    
    const bloomRenderTarget = new THREE.WebGLRenderTarget(width, height, {
      type: THREE.HalfFloatType,
      format: THREE.RGBAFormat,
      colorSpace: THREE.SRGBColorSpace,
      stencilBuffer: false,
      depthBuffer: true
    });
    
    const bloomComposer = new EffectComposer(webglRenderer, bloomRenderTarget);
    
    const bloomRenderPass = new RenderPass(scene, camera);
    bloomRenderPass.clear = true;
    bloomRenderPass.clearColor = new THREE.Color(0, 0, 0);
    bloomRenderPass.clearAlpha = 0; // Clear to transparent black
    bloomComposer.addPass(bloomRenderPass);
    
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(width, height),
      1.0,  // Strength - increased for better visibility
      0.3,  // Radius - slightly increased for better glow
      0.1   // Threshold - VERY LOW to catch all pearl emission
    );
    bloomPass.renderToScreen = false; // DON'T render to screen - keep in buffer!
    bloomComposer.addPass(bloomPass);
    
    bloomComposer.renderToScreen = false; // Keep result in render target!
    
    console.log('√¢≈ì¬® Selective bloom composer created for layer 1 (pearls)!');
    
    

    const cssRenderer = new CSS3DRenderer();
    cssRenderer.setSize(width, height);
    cssRenderer.domElement.style.position = 'absolute';
    cssRenderer.domElement.style.top = '0';
    cssRenderer.domElement.style.pointerEvents = 'auto';
    document.getElementById('container').appendChild(cssRenderer.domElement);

    const leaveBtn = document.createElement('button');
    leaveBtn.textContent = 'Leave Game';
    leaveBtn.style.cssText = `
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10001;
      padding: 10px 14px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 1px;
      color: #fff;
      background: linear-gradient(135deg, #ff4444, #cc0000);
      border: 2px solid #ff4444;
      border-radius: 10px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
      display: none;
    `;
    leaveBtn.addEventListener('mouseenter', () => {
      leaveBtn.style.transform = 'translateY(-2px)';
      leaveBtn.style.boxShadow = '0 8px 18px rgba(255, 68, 68, 0.6)';
    });
    leaveBtn.addEventListener('mouseleave', () => {
      leaveBtn.style.transform = 'translateY(0)';
      leaveBtn.style.boxShadow = '0 0 15px rgba(255, 68, 68, 0.5)';
    });
    leaveBtn.onclick = () => {
      const confirmLeave = confirm('Leave game? You may forfeit if the match is active.');
      if (!confirmLeave) return;
      const lobbyUrl = gameIdParam ? `/battle-royale/${gameIdParam}` : '/';
      window.location.href = lobbyUrl;
    };
    document.body.appendChild(leaveBtn);

    let currentPlayerXP = 0;
    const xpCounter = document.createElement('div');
    xpCounter.id = 'xp-counter';
    xpCounter.style.cssText = `
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10001;
      padding: 12px 18px;
      background: #0a0f2e;
      border: 2px solid #00ff88;
      border-radius: 12px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 14px;
      color: #00ff88;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      backdrop-filter: blur(10px);
      pointer-events: auto;
    `;
      xpCounter.innerHTML = `
        <div style="font-size: 12px; color: #ffffff; opacity: 0.8; margin-bottom: 4px;">Total Earnings</div>
        <div style="font-size: 18px; margin-bottom: 2px;">${currentPlayerXP} FLIP</div>
        <div style="font-size: 10px; color: #ffffff; opacity: 0.8;">This Game</div>
      `;
    document.body.appendChild(xpCounter);

    const changeCoinBox = document.createElement('div');
    changeCoinBox.id = 'change-coin-box';
    changeCoinBox.style.cssText = `
      position: fixed;
      top: 20px;
      right: 240px;
      width: 160px;
      height: 50px;
      padding: 0;
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      border: 4px solid #ff8f00;
      border-radius: 12px;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 0 20px rgba(255, 235, 59, 0.6);
      backdrop-filter: blur(10px);
      pointer-events: auto;
      z-index: 1000;
    `;
    changeCoinBox.innerHTML = `
      <button id="global-change-coin-btn" style="
        width: 100%;
        height: 100%;
        padding: 0;
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        border: 4px solid #ff8f00;
        border-radius: 8px;
        color: #6a1b9a;
        font-family: 'Orbitron', sans-serif;
        font-weight: 900;
        font-size: 16px;
        cursor: pointer;
        box-shadow: 0 0 15px rgba(255, 235, 59, 0.6);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 25px rgba(255, 235, 59, 0.8)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 15px rgba(255, 235, 59, 0.6)'">CHANGE COIN</button>
    `;
    document.body.appendChild(changeCoinBox);

    setTimeout(() => {
      const globalChangeCoinBtn = document.getElementById('global-change-coin-btn');
      if (globalChangeCoinBtn) {
        globalChangeCoinBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('√∞≈∏≈Ω¬® Global change coin button clicked');
          
          let currentPlayerSlot = playerSlot;
          
          if (currentPlayerSlot === undefined || currentPlayerSlot < 0) {
            currentPlayerSlot = players.findIndex(p => p.address === walletParam);
            console.log(`√∞≈∏‚Äù¬ç Fallback search found player slot: ${currentPlayerSlot}`);
          }
          
          if (currentPlayerSlot !== undefined && currentPlayerSlot >= 0) {
            console.log(`√∞≈∏≈Ω¬® Opening coin selector for player slot ${currentPlayerSlot}`);
            showCoinSelector(currentPlayerSlot);
          } else {
            console.log('√¢¬ù≈í Player slot not found for coin selection. PlayerSlot:', playerSlot, 'WalletParam:', walletParam);
            console.log('Available players:', players.map((p, i) => ({ slot: i, address: p.address, name: p.name })));
          }
        });
      }
    }, 100);

    function updateXPCounter(amount) {
      currentPlayerXP += amount;
      const xpDisplay = xpCounter.querySelectorAll('div')[1]; // Second div contains the FLIP amount
      xpDisplay.textContent = `${currentPlayerXP} FLIP`;
      
      if (isMobile()) {
        updateMobileDisplays();
      }
      
      xpCounter.style.boxShadow = '0 0 30px rgba(0, 255, 136, 0.6)';
      setTimeout(() => {
        xpCounter.style.boxShadow = '0 0 20px rgba(0, 255, 136, 0.3)';
      }, 500);
    }

    function showFloatingMessage(message, color, duration = 3000) {
      const floatingMsg = document.createElement('div');
      floatingMsg.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: ${color};
        padding: 15px 25px;
        border-radius: 12px;
        border: 2px solid ${color};
        font-family: 'Orbitron', sans-serif;
        font-size: 18px;
        font-weight: bold;
        z-index: 10000;
        text-align: center;
        box-shadow: 0 0 40px ${color}99;
        pointer-events: none;
        animation: floatIn 0.5s ease-out;
      `;
      
      floatingMsg.textContent = message;
      document.body.appendChild(floatingMsg);
      
      if (!document.getElementById('floating-animations')) {
        const style = document.createElement('style');
        style.id = 'floating-animations';
        style.textContent = `
          @keyframes floatIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          }
        `;
        document.head.appendChild(style);
      }
      
      setTimeout(() => {
        floatingMsg.style.animation = 'floatIn 0.5s ease-out reverse';
        setTimeout(() => {
          if (floatingMsg.parentNode) {
            floatingMsg.parentNode.removeChild(floatingMsg);
          }
        }, 500);
      }, duration);
    }

    let currentCollectionId = null;
    let collectionExpiryTimer = null;

    function showCollectionUI(collectionId, totalFlip, gameResult, expiresAt) {
      currentCollectionId = collectionId;
      
      const overlay = document.createElement('div');
      overlay.id = 'collection-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.5s ease-out;
      `;

      const collectionBox = document.createElement('div');
      collectionBox.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 3px solid ${gameResult === 'won' ? '#FFD700' : '#00ff00'};
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 0 50px ${gameResult === 'won' ? '#FFD700' : '#00ff00'}99;
        animation: scaleIn 0.5s ease-out;
      `;

      const title = gameResult === 'won' ? '√∞≈∏¬è‚Ä† VICTORY!' : '√∞≈∏‚Äô¬∞ Game Complete';
      const titleColor = gameResult === 'won' ? '#FFD700' : '#00ff00';
      
      collectionBox.innerHTML = `
        <h2 style="color: ${titleColor}; margin: 0 0 20px 0; font-size: 28px;">${title}</h2>
        <div style="font-size: 24px; margin: 20px 0; color: #FFD700;">
          üíé ${totalFlip} FLIP Tokens Earned
        </div>
        <div style="font-size: 14px; color: #888; margin: 20px 0;">
          √¢¬è¬∞ Collect within 24 hours or they expire!
        </div>
        <div style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
          <button id="collect-flip-btn" style="
            background: linear-gradient(45deg, #00ff00, #00cc00);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
          ">üíé Claim FLIP</button>
          ${gameResult === 'won' ? `
          <button id="claim-nft-btn" style="
            background: linear-gradient(45deg, #ff0088, #cc0066);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
          ">√∞≈∏¬è‚Ä† Claim NFT</button>
          ` : ''}
        </div>
        <div style="font-size: 12px; color: #666; margin-top: 15px;">
          Collection expires: ${new Date(expiresAt).toLocaleString()}
        </div>
      `;

      overlay.appendChild(collectionBox);
      document.body.appendChild(overlay);

      const collectBtn = document.getElementById('collect-flip-btn');
      const claimNftBtn = document.getElementById('claim-nft-btn');
      
      collectBtn.addEventListener('mouseenter', () => {
        collectBtn.style.transform = 'scale(1.05)';
        collectBtn.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.6)';
      });
      collectBtn.addEventListener('mouseleave', () => {
        collectBtn.style.transform = 'scale(1)';
        collectBtn.style.boxShadow = 'none';
      });

      if (claimNftBtn) {
        claimNftBtn.addEventListener('mouseenter', () => {
          claimNftBtn.style.transform = 'scale(1.05)';
          claimNftBtn.style.boxShadow = '0 0 20px rgba(255, 0, 136, 0.6)';
        });
        claimNftBtn.addEventListener('mouseleave', () => {
          claimNftBtn.style.transform = 'scale(1)';
          claimNftBtn.style.boxShadow = 'none';
        });
      }

      collectBtn.addEventListener('click', () => {
        if (isServerSideMode && socket && gameIdParam && walletParam) {
          socket.emit('collect_flip_tokens', {
            collectionId: collectionId,
            address: walletParam
          });
        }
      });

      if (claimNftBtn) {
        claimNftBtn.addEventListener('click', () => {
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('claim_nft', {
              collectionId: collectionId,
              address: walletParam
            });
          }
        });
      }

      const expiryTime = new Date(expiresAt).getTime() - Date.now();
      if (expiryTime > 0) {
        collectionExpiryTimer = setTimeout(() => {
          showFloatingMessage('√¢¬è¬∞ Collection expired!', '#ff4444', 3000);
          hideCollectionUI();
        }, expiryTime);
      }

      if (!document.getElementById('collection-animations')) {
        const style = document.createElement('style');
        style.id = 'collection-animations';
        style.textContent = `
          @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
          }
          @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
          }
        `;
        document.head.appendChild(style);
      }
    }

    function hideCollectionUI() {
      const overlay = document.getElementById('collection-overlay');
      if (overlay) {
        overlay.style.animation = 'fadeIn 0.5s ease-out reverse';
        setTimeout(() => {
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        }, 500);
      }
      
      currentCollectionId = null;
      if (collectionExpiryTimer) {
        clearTimeout(collectionExpiryTimer);
        collectionExpiryTimer = null;
      }
    }

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Minimal ambient
    scene.add(ambientLight);

    const topLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced
    topLight.position.set(0, 600, 400);
    scene.add(topLight);

    const leftAccent = new THREE.PointLight(COLORS.cyan, 1, 1500); // Reduced
    leftAccent.position.set(-800, 200, 400);
    scene.add(leftAccent);

    const rightAccent = new THREE.PointLight(COLORS.pink, 1, 1500); // Reduced
    rightAccent.position.set(800, 200, 400);
    scene.add(rightAccent);

    const frontLight = new THREE.DirectionalLight(0xffffff, 1.0); // Good brightness for tubes
    frontLight.position.set(0, 200, 1200); // From camera position
    frontLight.target.position.set(0, 200, 0); // Pointing at tubes
    scene.add(frontLight);
    scene.add(frontLight.target);

    const NUM_TUBES = 4;
    const TUBE_RADIUS = 80;
    const TUBE_HEIGHT = 350; // Shorter tubes
    const SPACING = 350;

    const totalWidth = SPACING * (NUM_TUBES - 1);
    const startX = -totalWidth / 2;

    const textureLoader = new THREE.TextureLoader();
    const brassColorMap = textureLoader.load('/Images/textures/Brass/textures/rusty_metal_04_diff_4k.jpg');
    const brassDisplacementMap = textureLoader.load('/Images/textures/Brass/textures/rusty_metal_04_disp_4k.png');
    
    brassColorMap.wrapS = THREE.RepeatWrapping;
    brassColorMap.wrapT = THREE.RepeatWrapping;
    brassColorMap.repeat.set(2, 2);
    
    brassDisplacementMap.wrapS = THREE.RepeatWrapping;
    brassDisplacementMap.wrapT = THREE.RepeatWrapping;
    brassDisplacementMap.repeat.set(2, 2);

    console.log('√∞≈∏≈Ω¬® Brass metallic textures loaded');

    const tubeAlphaCanvas = document.createElement('canvas');
    tubeAlphaCanvas.width = 512;
    tubeAlphaCanvas.height = 512;
    const tubeAlphaCtx = tubeAlphaCanvas.getContext('2d');
    
    tubeAlphaCtx.fillStyle = 'white';
    tubeAlphaCtx.fillRect(0, 0, 512, 512);
    
    tubeAlphaCtx.globalCompositeOperation = 'destination-out';
    tubeAlphaCtx.fillStyle = 'black';
    
    const rectWidth = 200;
    const rectHeight = 440; // Full height of tube
    const rectX = 256 - rectWidth / 2;
    const rectY = 36; // Start near top
    const cornerRadius = 30; // Larger rounded corners
    
    tubeAlphaCtx.beginPath();
    tubeAlphaCtx.moveTo(rectX + cornerRadius, rectY);
    tubeAlphaCtx.lineTo(rectX + rectWidth - cornerRadius, rectY);
    tubeAlphaCtx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + cornerRadius);
    tubeAlphaCtx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerRadius);
    tubeAlphaCtx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - cornerRadius, rectY + rectHeight);
    tubeAlphaCtx.lineTo(rectX + cornerRadius, rectY + rectHeight);
    tubeAlphaCtx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - cornerRadius);
    tubeAlphaCtx.lineTo(rectX, rectY + cornerRadius);
    tubeAlphaCtx.quadraticCurveTo(rectX, rectY, rectX + cornerRadius, rectY);
    tubeAlphaCtx.closePath();
    tubeAlphaCtx.fill();
    
    const tubeAlphaTexture = new THREE.CanvasTexture(tubeAlphaCanvas);
    tubeAlphaTexture.wrapS = THREE.RepeatWrapping;
    tubeAlphaTexture.wrapT = THREE.ClampToEdgeWrapping;

    const physicsWorld = new CANNON.World({
      gravity: new CANNON.Vec3(0, -980, 0) // Gravity in cm/s^2
    });
    physicsWorld.defaultContactMaterial.friction = 0.1;
    physicsWorld.defaultContactMaterial.restitution = 0.3;

    console.log('√¢≈°‚Ñ¢√Ø¬∏¬è Physics world created with gravity');

    function getTubeStyle(roomType) {
      if (roomType === 'lab') {
        return {
          glassColor: 0x4a90e2, // Steel blue
          glassOpacity: 0.2,
          glassEmissive: 0x1a3a5c,
          glassEmissiveIntensity: 0.1,
          capColor: 0x8B4513, // Cork brown
          capMetalness: 0.1, // Low metalness for cork
          capRoughness: 0.8, // High roughness for cork texture
          rimColor: 0x00ff88, // Neon green (scientific)
          backingColor: 0x34495e, // Dark steel backing
          backingMetalness: 0.8,
          backingRoughness: 0.4,
          tubeShape: 'lab', // Different shape for lab tubes
          tubeRadius: TUBE_RADIUS * 0.8, // Slightly narrower
          tubeHeight: TUBE_HEIGHT * 1.1 // Slightly taller
        };
      } else if (roomType === 'cyber') {
        return {
          glassColor: 0x00ffff, // Cyan glass
          glassOpacity: 0.25,
          glassEmissive: 0x004444,
          glassEmissiveIntensity: 0.2,
          capColor: 0xff6600, // Bright neon orange
          capMetalness: 0.3,
          capRoughness: 0.2,
          rimColor: 0xff6600, // Bright neon orange
          backingColor: 0x001122, // Dark cyber backing
          backingMetalness: 0.9,
          backingRoughness: 0.1,
          tubeShape: 'cyber', // Different shape for cyber tubes
          tubeRadius: TUBE_RADIUS * 0.9, // Slightly narrower than potion
          tubeHeight: TUBE_HEIGHT * 1.05 // Slightly taller
        };
      } else if (roomType === 'mech') {
        return {
          glassColor: 0x666666, // Dark steel glass
          glassOpacity: 0.3,
          glassEmissive: 0x220000,
          glassEmissiveIntensity: 0.1,
          capColor: 0xff0000, // Bright red
          capMetalness: 0.8,
          capRoughness: 0.3,
          rimColor: 0xff0000, // Bright red
          backingColor: 0x222222, // Dark industrial backing
          backingMetalness: 0.9,
          backingRoughness: 0.2,
          tubeShape: 'mech', // Different shape for mech tubes
          tubeRadius: TUBE_RADIUS * 0.95, // Slightly narrower
          tubeHeight: TUBE_HEIGHT * 1.02 // Slightly taller
        };
      } else {
        return {
          glassColor: 0xd0d0d0, // Bright silver
          glassOpacity: 0.15,
          glassEmissive: 0x505050,
          glassEmissiveIntensity: 0.15,
          capColor: 0xcd7f32, // Brass
          capMetalness: 0.98,
          capRoughness: 0.1,
          rimColor: 0xff8800, // Orange
          backingColor: 0xe0e0e0, // Chrome
          backingMetalness: 0.98,
          backingRoughness: 0.1,
          tubeShape: 'potion',
          tubeRadius: TUBE_RADIUS,
          tubeHeight: TUBE_HEIGHT
        };
      }
    }

    const tubeStyle = getTubeStyle(roomParam);
    console.log(`√∞≈∏≈Ω¬® Using ${roomParam} room tube style:`, tubeStyle);

    const tubes = [];
    const coins = [];

    for (let i = 0; i < NUM_TUBES; i++) {
      const x = startX + (i * SPACING);
      const player = players[i];

      let tubeGeometry;
      if (tubeStyle.tubeShape === 'lab') {
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius * 0.9, // Top slightly narrower
          tubeStyle.tubeRadius, // Bottom wider
          tubeStyle.tubeHeight, 
          128, // Double the segments for more circular look
          1, true
        );
      } else if (tubeStyle.tubeShape === 'cyber') {
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius * 0.85, // Top narrower
          tubeStyle.tubeRadius * 1.05, // Bottom wider
          tubeStyle.tubeHeight, 
          128, // High segments for smooth look
          1, true
        );
      } else if (tubeStyle.tubeShape === 'mech') {
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius, 
          tubeStyle.tubeRadius, 
          tubeStyle.tubeHeight, 
          128, // High segments for industrial precision
          1, true
        );
      } else {
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius, 
          tubeStyle.tubeRadius, 
          tubeStyle.tubeHeight, 
          128, // More segments for circular appearance
          1, true
        );
      }
      
      const glassMaterial = new THREE.MeshStandardMaterial({
        color: tubeStyle.glassColor,
        transparent: true,
        opacity: tubeStyle.glassOpacity,
        alphaMap: tubeAlphaTexture, // Apply shared rectangular cutout
        roughness: 0.2,
        metalness: 1.0, // Full metallic
        emissive: tubeStyle.glassEmissive,
        emissiveIntensity: tubeStyle.glassEmissiveIntensity,
        side: THREE.DoubleSide
      });
      const tube = new THREE.Mesh(tubeGeometry, glassMaterial);
      tube.position.set(x, 200, 0); // Move tubes higher up
      tube.rotation.y = Math.PI; // Rotate 180√Ç¬∞ so cutout faces camera
      scene.add(tube);

      const backingGeometry = new THREE.CylinderGeometry(
        tubeStyle.tubeRadius + 5, 
        tubeStyle.tubeRadius + 5, 
        tubeStyle.tubeHeight + 20, 
        32, 1, false
      );
      const backingMaterial = new THREE.MeshStandardMaterial({
        color: tubeStyle.backingColor,
        roughness: tubeStyle.backingRoughness,
        metalness: tubeStyle.backingMetalness,
        emissive: 0x404040,
        emissiveIntensity: 0.1,
        side: THREE.BackSide // Only visible from inside
      });
      const backing = new THREE.Mesh(backingGeometry, backingMaterial);
      backing.position.set(x, 200, -10); // Position slightly behind the tube
      scene.add(backing);

      const capMaterial = new THREE.MeshStandardMaterial({
        map: brassColorMap,
        displacementMap: brassDisplacementMap,
        displacementScale: 0.2,
        color: tubeStyle.capColor,
        metalness: tubeStyle.capMetalness,
        roughness: tubeStyle.capRoughness,
      });

      const capGeometry = new THREE.CylinderGeometry(
        tubeStyle.tubeRadius + 10, 
        tubeStyle.tubeRadius + 10, 
        15, 64
      );
      
      const capCanvas = document.createElement('canvas');
      capCanvas.width = 256;
      capCanvas.height = 256;
      const capCtx = capCanvas.getContext('2d');
      
      capCtx.fillStyle = 'white';
      capCtx.fillRect(0, 0, 256, 256);
      
      capCtx.globalCompositeOperation = 'destination-out';
      capCtx.fillStyle = 'black';
      capCtx.beginPath();
      capCtx.arc(128, 128, 60, 0, Math.PI * 2); // Circle cutout
      capCtx.fill();
      
      const capAlphaTexture = new THREE.CanvasTexture(capCanvas);
      
      const topCapMaterial = capMaterial.clone();
      topCapMaterial.alphaMap = capAlphaTexture;
      topCapMaterial.transparent = true;
      
      const topCap = new THREE.Mesh(capGeometry, topCapMaterial);
      topCap.position.set(x, 200 + (tubeStyle.tubeHeight / 2) + 7.5, 0);
      scene.add(topCap);

      const bottomCap = new THREE.Mesh(capGeometry, capMaterial.clone());
      bottomCap.position.set(x, 200 - (tubeStyle.tubeHeight / 2) - 7.5, 0);
      scene.add(bottomCap);

      const rimGeometry = new THREE.TorusGeometry(tubeStyle.tubeRadius + 5, 8, 32, 64);
      const rimMaterial = new THREE.MeshStandardMaterial({
        color: tubeStyle.rimColor,
        metalness: 0.95,
        roughness: 0.1,
      });
      
      const topRim = new THREE.Mesh(rimGeometry, rimMaterial);
      topRim.position.set(x, 200 + tubeStyle.tubeHeight / 2, 0);
      topRim.rotation.x = Math.PI / 2;
      scene.add(topRim);

      const bottomRim = topRim.clone();
      bottomRim.position.y = 200 - tubeStyle.tubeHeight / 2;
      scene.add(bottomRim);

      
      const glassBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        position: new CANNON.Vec3(x, 200, 0)
      });
      
      const bottomCapShape = new CANNON.Box(new CANNON.Vec3(tubeStyle.tubeRadius + 5, 20, tubeStyle.tubeRadius + 5));
      const bottomCapOffset = new CANNON.Vec3(0, -(tubeStyle.tubeHeight / 2) - 15, 0);
      glassBody.addShape(bottomCapShape, bottomCapOffset);
      
      const topCapShape = new CANNON.Box(new CANNON.Vec3(tubeStyle.tubeRadius + 5, 30, tubeStyle.tubeRadius + 5));
      const topCapOffset = new CANNON.Vec3(0, (tubeStyle.tubeHeight / 2) + 20, 0);
      glassBody.addShape(topCapShape, topCapOffset);
      
      const numWalls = 16;
      const wallThickness = 3;
      for (let w = 0; w < numWalls; w++) {
        const angle = (w / numWalls) * Math.PI * 2;
        const wallX = Math.cos(angle) * (tubeStyle.tubeRadius - 6);
        const wallZ = Math.sin(angle) * (tubeStyle.tubeRadius - 6);
        
        const wallShape = new CANNON.Box(new CANNON.Vec3(wallThickness, (tubeStyle.tubeHeight - 10) / 2, wallThickness));
        const wallOffset = new CANNON.Vec3(wallX, 0, wallZ);
        glassBody.addShape(wallShape, wallOffset);
      }
      
      physicsWorld.addBody(glassBody);
      console.log(`√¢≈°‚Ñ¢√Ø¬∏¬è Sealed physics container created for tube ${i + 1}`);

      const liquidParticles = [];
      const liquidParticleMeshes = [];
      const particleRadius = 7; // Pearl-sized
      const maxLayers = 80; // Double the pearls for more dramatic effect
      const pRadius = particleRadius;
      
      for (let p = 0; p < maxLayers; p++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * (tubeStyle.tubeRadius - 25);
        const pearlX = x + Math.cos(angle) * radius;
        const pearlZ = Math.sin(angle) * radius;
        const pearlY = 200 - (tubeStyle.tubeHeight / 2) + 30 + Math.random() * 60; // Start at bottom
        
        const particleShape = new CANNON.Sphere(particleRadius);
        const particleBody = new CANNON.Body({
          mass: 0.3, // Lighter so they float easier
          position: new CANNON.Vec3(pearlX, pearlY, pearlZ),
          material: new CANNON.Material({ friction: 0.1, restitution: 0.8 }) // VERY BOUNCY!
        });
        particleBody.addShape(particleShape);
        particleBody.linearDamping = 0.6; // Less damping = more movement
        particleBody.angularDamping = 0.6;
        particleBody.collisionFilterGroup = 1;
        particleBody.collisionFilterMask = -1;
        
        physicsWorld.addBody(particleBody);
        
        const particleGeometry = new THREE.SphereGeometry(particleRadius, 32, 32); // Higher segments for perfect sphere
        const particleMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x1a1a1a, // Neutral dark grey
          metalness: 0.0, // No metalness for pure emissive glow
          roughness: 0.3,
          transparent: true,
          opacity: 0.7, // More transparent to see video
          emissive: 0x0a0a0a, // Very faint neutral glow
          emissiveIntensity: 0.2,
          toneMapped: false, // Bypass tone mapping for maximum brightness!
          clearcoat: 1.0,
          clearcoatRoughness: 0.05
        });
        const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
        particleMesh.visible = true;
        particleMesh.layers.set(1); // LAYER 1 - For selective bloom!
        scene.add(particleMesh);
        
        liquidParticles.push(particleBody);
        liquidParticleMeshes.push(particleMesh);
      }

      const liquidHeight = TUBE_HEIGHT - 20;
      const liquidGeometry = new THREE.CylinderGeometry(TUBE_RADIUS - 6, TUBE_RADIUS - 6, liquidHeight, 32, 32);
      const liquidMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x1a1a2e, // Dark blue-grey
        metalness: 0.05,
        roughness: 0.3,
        transparent: true,
        opacity: 0.25, // Much more transparent to see video through
        transmission: 0.6, // Higher transmission for see-through effect
        thickness: 1.5,
        clearcoat: 0.6,
        clearcoatRoughness: 0.05,
        emissive: 0x0a0a1a, // Very faint blue glow
        emissiveIntensity: 0.2,
        ior: 1.33,
        reflectivity: 0.3,
        envMapIntensity: 1.2,
        side: THREE.DoubleSide
      });
      const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
      const liquidY = 200 - (TUBE_HEIGHT / 2) + (liquidHeight / 2);
      liquid.position.set(x, liquidY, 0);
      liquid.scale.y = 1.0; // Pre-filled to 100%
      liquid.visible = true; // Visible from start
      scene.add(liquid);

      const liquidLight = new THREE.PointLight(0x1a1a2e, 0.3, 400); // Dim blue-grey
      liquidLight.position.set(0, 0, 0);
      liquid.add(liquidLight);

      const spotlight = new THREE.SpotLight(0xffffff, 0.7, 700, Math.PI / 6, 0.5, 2);
      spotlight.position.set(x, 200 + TUBE_HEIGHT / 2 + 300, 150);
      spotlight.target.position.set(x, 200, 0);
      scene.add(spotlight);
      scene.add(spotlight.target);

      const platformGeometry = new THREE.CylinderGeometry(TUBE_RADIUS + 20, TUBE_RADIUS + 20, 15, 32);
      const platformMaterial = new THREE.MeshStandardMaterial({
        map: brassColorMap,
        displacementMap: brassDisplacementMap,
        displacementScale: 0.2,
        metalness: 0.98,
        roughness: 0.1,
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.set(x, 200 - (TUBE_HEIGHT / 2) - 30, 0);
      scene.add(platform);

      const coinRadius = 65; // 30% larger (was 50)
      const coinThickness = 16; // Scaled proportionally
      const coinGeometry = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);
      const textureLoader = new THREE.TextureLoader();
      
      const headsTexture = textureLoader.load('/coins/plainh.png'); // Temporary placeholder
      const tailsTexture = textureLoader.load('/coins/plaint.png'); // Temporary placeholder
      
      headsTexture.minFilter = THREE.LinearFilter;
      headsTexture.magFilter = THREE.LinearFilter;
      headsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
      headsTexture.generateMipmaps = false;
      
      tailsTexture.minFilter = THREE.LinearFilter;
      tailsTexture.magFilter = THREE.LinearFilter;
      tailsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
      tailsTexture.generateMipmaps = false;
      
      const rawTextureShader = {
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D map;
          varying vec2 vUv;
          void main() {
            gl_FragColor = texture2D(map, vUv);
          }
        `
      };
      
      const coinMaterials = [
        new THREE.MeshStandardMaterial({ 
          color: 0xFFD700,
          emissive: 0xFFD700,
          emissiveIntensity: 0.3,
          metalness: 0.8,
          roughness: 0.2,
          side: THREE.DoubleSide,
          transparent: false
        }), // Side - glowing gold
        new THREE.ShaderMaterial({
          uniforms: { 
            map: { value: headsTexture }
          },
          vertexShader: rawTextureShader.vertexShader,
          fragmentShader: rawTextureShader.fragmentShader,
          side: THREE.DoubleSide,
          depthWrite: true,
          depthTest: true,
          transparent: false
        }), // Top (heads) - RAW texture pixels
        new THREE.ShaderMaterial({
          uniforms: { 
            map: { value: tailsTexture }
          },
          vertexShader: rawTextureShader.vertexShader,
          fragmentShader: rawTextureShader.fragmentShader,
          side: THREE.DoubleSide,
          depthWrite: true,
          depthTest: true,
          transparent: false
        })  // Bottom (tails) - RAW texture pixels
      ];
      
      const coin = new THREE.Mesh(coinGeometry, coinMaterials);
      coin.rotation.x = Math.PI / 2; // Standing on edge (90 degrees)
      coin.rotation.y = Math.PI / 2; // Rotated 90 degrees left for proper facing
      coin.rotation.z = 0; // No tilt
      coin.position.set(x, 200, 0); // Centered in tube
      coin.visible = true; // Explicitly set visible
      coin.frustumCulled = false; // Never cull from view - always render
      coin.renderOrder = 1; // Render after background but before UI
      coin.layers.set(0); // Main rendering layer
      coin.matrixAutoUpdate = true; // Ensure matrix updates
      
      coin.material.forEach(mat => {
        if (mat.needsUpdate !== undefined) mat.needsUpdate = true;
      });
      
      scene.add(coin);

      const shadowGeometry = new THREE.CircleGeometry(coinRadius * 1.5, 64);
      
      const shadowMaterial = new THREE.ShaderMaterial({
        transparent: true,
        side: THREE.DoubleSide,
        uniforms: {
          centerColor: { value: new THREE.Color(0x0a0a2e) }, // Dark navy
          edgeColor: { value: new THREE.Color(0x000000) }, // Black at edges
          opacity: { value: 0.85 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 centerColor;
          uniform vec3 edgeColor;
          uniform float opacity;
          varying vec2 vUv;
          void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(vUv, center);
            float gradient = smoothstep(0.0, 0.5, dist);
            vec3 color = mix(centerColor, edgeColor, gradient);
            float alpha = opacity * (1.0 - smoothstep(0.3, 0.5, dist));
            gl_FragColor = vec4(color, alpha);
          }
        `
      });
      
      const coinShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
      coinShadow.position.set(x, 200, -8); // Behind coin, slightly further back
      coinShadow.visible = false; // Hidden initially
      scene.add(coinShadow);

      coins.push(coin);

      const cardElement = document.createElement('div');
      cardElement.className = 'player-card';
      
      let showButtons = false;
      if (!isServerSideMode) {
        showButtons = !player.isEmpty;
      }
      
      console.log(`√∞≈∏≈Ω¬Ø Initial Player ${i + 1} button logic (DEBUGGING MODE):`, {
        playerAddress: player.address,
        isEmpty: player.isEmpty,
        showButtons: showButtons
      });
      
      const emptySlotOverlay = player.isEmpty ? `
        <div class="empty-slot-overlay" style="
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 50, 0.9);
          border-radius: 16px;
          z-index: 10;
        "></div>
      ` : '';
      
      cardElement.innerHTML = `
        ${emptySlotOverlay}
        <div class="card-header">
          <img src="${player.avatar || '/images/default-avatar.png'}" class="player-avatar" alt="${player.name}" style="width: 80px; height: 100px;" />
          <div class="player-info">
            <div class="player-name">${player.name}</div>
            ${player.wins > 0 ? '<div class="wins-display" style="margin-top: 8px; justify-content: center; align-items: center;">WIN</div>' : ''}
          </div>
        </div>
        ${player.choice ? `
          <div class="choice-badge ${player.choice}" style="display: ${player.choice ? 'block' : 'none'};">
            ${player.choice.toUpperCase()}
          </div>
        ` : ''}
        <div class="choice-buttons" style="display: ${showButtons && !player.choice ? 'block' : 'none'};">
          <button class="choice-btn heads">HEADS</button>
          <button class="choice-btn tails">TAILS</button>
        </div>
        <div style="margin: 15px 0;">
          <div class="power-bar-container">
            <!-- Sweet Spot Zone Overlays -->
            <div class="zone-overlay">
              <div class="zone safe" style="left: 0%; width: 42%;"></div>
              <div class="zone good" style="left: 42%; width: 6%;"></div>
              <div class="zone perfect" style="left: 48%; width: 4%;"></div>
              <div class="zone good" style="left: 52%; width: 6%;"></div>
              <div class="zone safe" style="left: 58%; width: 42%;"></div>
            </div>
            
            <!-- Actual Power Fill -->
            <div class="power-fill"></div>
            
            <!-- Power Text -->
            <div class="power-text">POWER: <span class="power-value">0</span>%</div>
          </div>
        </div>
        <button class="action-btn" style="display: ${showButtons ? 'block' : 'none'};">CHARGE POWER</button>
      `;

      cardElement.style.pointerEvents = 'auto';
      
      const choiceButtons = cardElement.querySelectorAll('.choice-btn');
      choiceButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          const choice = button.classList.contains('heads') ? 'heads' : 'tails';
          
          choiceButtons.forEach(btn => {
            btn.style.opacity = '0.5';
            btn.style.transform = 'scale(0.95)';
          });
          button.style.opacity = '1';
          button.style.transform = 'scale(1.1)';
          button.style.boxShadow = '0 0 25px rgba(255, 255, 255, 0.8)';
          
          players[i].choice = choice;
          console.log(`√∞≈∏≈Ω¬Ø Local choice set for player ${i + 1}: ${choice}`);
          updateCoinRotationsFromPlayerChoices();
          saveGameState(); // √¢‚Ä†¬ê ADD THIS
          
          const choiceBadge = cardElement.querySelector('.choice-badge');
          const choiceButtonsContainer = cardElement.querySelector('.choice-buttons');
          if (choiceButtonsContainer && choiceBadge) {
            choiceButtonsContainer.style.display = 'none';
            choiceBadge.style.display = 'inline-block';
            choiceBadge.textContent = choice.toUpperCase();
            choiceBadge.className = `choice-badge ${choice}`;
          }
          
          updateCoinRotationsFromPlayerChoices();
          
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('physics_set_choice', {
              gameId: gameIdParam,
              address: walletParam,
              choice: choice
            });
            console.log(`√∞≈∏≈Ω¬Ø Sent choice to server: ${choice}`);
          }
          
          updatePlayerCardButtons();
        });
      });


      const flipButtons = cardElement.querySelectorAll('.action-btn');
      const powerButton = flipButtons[0]; // The first action button (CHARGE POWER)
      
      if (powerButton) {
        powerButton.style.pointerEvents = 'auto';
        
        let isCharging = false;
        
        powerButton.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          console.log(`√∞≈∏‚Äì¬±√Ø¬∏¬è Power button mousedown for player ${i + 1}`);
          
          
          if (!players[i].choice) {
            showChoiceRequiredMessage(i);
            console.log(`√¢¬ù≈í Player ${i + 1} must choose heads or tails first!`);
            return;
          }
          
          if (tubes[i].hasUsedPower) {
            console.log(`√¢¬ù≈í Player ${i + 1} already used power this round`);
            return;
          }
          
          console.log(`√¢≈°¬° Charging power for tube ${i + 1}`);
          isCharging = true;
          tubes[i].isFilling = true;
          tubes[i].power = 0;
          tubes[i].chargingStartTime = Date.now(); // Track start time for sync
          
          playSound(powerChargeSound);
          
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_start', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: i,
              power: 0,  // √¢≈°¬° ADD THIS
              isFilling: true  // √¢≈°¬° ADD THIS
            });
            console.log(`√∞≈∏‚Äú¬¢ Broadcast: Player ${i + 1} started charging`);
          }
        });
        
        powerButton.addEventListener('mouseup', (e) => {
          e.stopPropagation();
          const finalPower = tubes[i].power;
          console.log(`√¢≈°¬° Power released at ${finalPower.toFixed(0)}%`);
          isCharging = false;
          tubes[i].isFilling = false;
          
          stopSound(powerChargeSound);
          
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_stop', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: i,
              finalPower: finalPower
            });
            console.log(`√∞≈∏‚Äú¬¢ Broadcast: Player ${i + 1} stopped charging at ${finalPower}%`);
          }
          
          if (finalPower >= 5) {
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              const playerChoice = players[i].choice;
              
              const releaseData = calculateReleaseAccuracy(finalPower);
              
              socket.emit('physics_flip_coin', {
                gameId: gameIdParam,
                address: walletParam,
                power: finalPower,
                accuracy: releaseData.accuracy,
                angle: 0 // Default angle for now
              });
              
              if (releaseData.zone) {
                showSweetSpotFeedback(releaseData.zone, releaseData.winChance);
              }
              
              console.log(`ü™ô Sent flip request to server: power=${finalPower}, choice=${playerChoice}`);
            } else {
              shatterGlass(i, finalPower);
              const playerChoice = players[i].choice;
              flipCoinWithPower(i, finalPower, playerChoice);
            }
            
            powerButton.disabled = true;
            powerButton.style.opacity = '0.5';
            powerButton.style.cursor = 'not-allowed';
            powerButton.style.background = '#cccccc';
            powerButton.style.color = '#666666';
            powerButton.style.borderColor = '#999999';
            tubes[i].hasUsedPower = true;
          }
        });
        
        powerButton.addEventListener('mouseleave', (e) => {
          if (isCharging) {
            const finalPower = tubes[i].power;
            console.log(`√¢≈°¬° Power released at ${finalPower.toFixed(0)}%`);
            
            stopSound(powerChargeSound);
            
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              socket.emit('physics_power_charging_stop', {
                gameId: gameIdParam,
                address: walletParam,
                playerSlot: i,
                finalPower: finalPower
              });
              console.log(`√∞≈∏‚Äú¬¢ Broadcast: Player ${i + 1} stopped charging (mouseleave) at ${finalPower}%`);
            }
            
            if (finalPower >= 5) {
              if (isServerSideMode && socket && gameIdParam && walletParam) {
                const playerChoice = players[i].choice;
                
                const releaseData = calculateReleaseAccuracy(finalPower);
                
                socket.emit('physics_flip_coin', {
                  gameId: gameIdParam,
                  address: walletParam,
                  power: finalPower,
                  accuracy: releaseData.accuracy,
                  angle: 0 // Default angle for now
                });
                
                if (releaseData.zone) {
                  showSweetSpotFeedback(releaseData.zone, releaseData.winChance);
                }
                
                console.log(`ü™ô Sent flip request to server (mouseleave): power=${finalPower}, choice=${playerChoice}`);
              } else {
                shatterGlass(i, finalPower);
                const playerChoice = players[i].choice;
                flipCoinWithPower(i, finalPower, playerChoice);
              }
              
              powerButton.disabled = true;
              powerButton.style.opacity = '0.5';
              powerButton.style.cursor = 'not-allowed';
              powerButton.style.background = '#cccccc';
              powerButton.style.color = '#666666';
              powerButton.style.borderColor = '#999999';
              tubes[i].hasUsedPower = true;
            }
          }
          isCharging = false;
          tubes[i].isFilling = false;
        });
        
      }

      const cssObject = new CSS3DObject(cardElement);
      cssObject.position.set(x, 200 - (TUBE_HEIGHT / 2) - 140, 0);
      cssObject.scale.set(0.6, 0.45, 0.6); // Wider, less tall
      scene.add(cssObject);

      const defaultCoin = coinOptions[0]; // Classic coin
      const defaultMaterial = coinMaterials[0]; // Graphite material
      
      textureLoader.load(defaultCoin.headsImage, (headsTex) => {
        headsTex.minFilter = THREE.LinearFilter;
        headsTex.magFilter = THREE.LinearFilter;
        headsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
        headsTex.generateMipmaps = false;
        
        textureLoader.load(defaultCoin.tailsImage, (tailsTex) => {
          tailsTex.minFilter = THREE.LinearFilter;
          tailsTex.magFilter = THREE.LinearFilter;
          tailsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
          tailsTex.generateMipmaps = false;
          
          coin.material[1].uniforms.map.value = headsTex;
          coin.material[1].needsUpdate = true;
          coin.material[2].uniforms.map.value = tailsTex;
          coin.material[2].needsUpdate = true;
          coin.visible = true;
          
          console.log(`√¢≈ì‚Ä¶ Applied default ${defaultCoin.name} textures to ${player.name}'s coin`);
        });
      });
      
      const edgeColor = new THREE.Color(defaultMaterial.edgeColor);
      coin.material[0].color.copy(edgeColor);
      coin.material[0].emissive.copy(edgeColor);
      coin.material[0].emissiveIntensity = 0.3;
      coin.material[0].needsUpdate = true;
      
      console.log(`√¢≈ì‚Ä¶ Applied default ${defaultCoin.name} with ${defaultMaterial.name} material to ${player.name}'s coin`);

      tubes.push({ 
        tube, backing, topRim, bottomRim, liquid, liquidLight, spotlight, platform, coin,
        coinShadow, // Dark backdrop for coin visibility
        liquidParticles, // Physics bodies (pearls)
        liquidParticleMeshes, // Visual meshes
        glassBody, // Container collision
        cardElement, // Store card element for power bar updates
        powerButton, // Store power button for enable/disable
        particleRadius: pRadius, // Store particle size
        liquidBaseY: liquidY,
        liquidBaseHeight: liquidHeight,
        isFilling: false,
        power: 0, // Power level (0-100)
        isShattered: false, // Glass shattered state
        // ‚úÖ NEW: Animation state machine (replaces multiple boolean flags)
        animationState: 'idle', // 'idle' | 'flipping' | 'landing' | 'shattered'
        animationStartTime: null, // When current animation started
        animationEndTime: null, // When current animation should end
        flipId: null, // Unique ID for flip animation
        landingId: null, // Unique ID for landing animation
        lastStableRotation: null, // Last known stable rotation before animation
        // Old properties kept for backwards compatibility (will be removed later)
        isFlipping: false, // DEPRECATED: Use animationState instead
        isLanding: false, // DEPRECATED: Use animationState instead
        flipStartTime: null, // DEPRECATED
        currentFlipId: null, // DEPRECATED: Use flipId instead
        currentLandingId: null, // DEPRECATED: Use landingId instead
        glassShards: [], // Will hold glass shards when shattered
        winLight: null, // Win glow light
        loseLight: null, // Lose glow light
        resultBox: null, // Result text CSS3D object
        foamIntensity: 0, // Bubbling/frothing intensity (0-1)
        hasUsedPower: false, // Track if player has used their turn
        selectedCoin: defaultCoin, // Default to Classic coin
        selectedMaterial: defaultMaterial // Default to Graphite material
      });
    }

    console.log('√∞≈∏"¬• PRE-LOADING ALL ASSETS during initialization...');
    
    // √¢≈ì‚Ä¶ FIX: Create a loading indicator
    const loadingIndicator = document.createElement('div');
    loadingIndicator.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #00ffff;
      padding: 30px 50px;
      border-radius: 15px;
      border: 2px solid #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      z-index: 99999;
      text-align: center;
    `;
    loadingIndicator.innerHTML = `
      <div style="font-size: 24px; margin-bottom: 10px;">‚ö° LOADING GAME</div>
      <div style="font-size: 14px; opacity: 0.8;">Preloading materials...</div>
    `;
    document.body.appendChild(loadingIndicator);
    
    // √¢≈ì‚Ä¶ FIX: Batch preload all materials and force shader compilation
    const preloadMaterials = [];
    
    // 1. Pearl materials (all color variants)
    const pearlColors = [0x00ff00, 0x00ddff, 0xff0088, 0xffff00];
    pearlColors.forEach(color => {
      const material = new THREE.MeshPhysicalMaterial({
        color: color,
        metalness: 0.0,
        roughness: 0.3,
        transparent: true,
        opacity: 0.7,
        emissive: color,
        emissiveIntensity: 0.2,
        toneMapped: false,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05
      });
      preloadMaterials.push(material);
    });
    
    // 2. Glass shard material (silver metallic)
    const glassShardMaterial = new THREE.MeshStandardMaterial({
      color: 0xe0e0e0,
      metalness: 0.95,
      roughness: 0.1,
      emissive: 0xc0c0c0,
      emissiveIntensity: 0.4,
      side: THREE.DoubleSide
    });
    preloadMaterials.push(glassShardMaterial);
    
    // 3. Result box materials
    const resultMaterials = [
      new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 }),
      new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 })
    ];
    preloadMaterials.push(...resultMaterials);
    
    // √¢≈ì‚Ä¶ FIX: Create dummy meshes off-screen to force shader compilation
    const dummyGeometry = new THREE.BoxGeometry(1, 1, 1);
    const dummyMeshes = [];
    
    preloadMaterials.forEach((material, i) => {
      const mesh = new THREE.Mesh(dummyGeometry, material);
      mesh.position.set(-10000 - i * 10, -10000, -10000);
      scene.add(mesh);
      dummyMeshes.push(mesh);
    });
    
    // √¢≈ì‚Ä¶ FIX: Force multiple renders to compile all shader combinations
    for (let i = 0; i < 3; i++) {
      webglRenderer.render(scene, camera);
    }
    
    console.log(`√¢≈ì‚Ä¶ Pre-compiled ${preloadMaterials.length} materials`);
    
    // √¢≈ì‚Ä¶ FIX: Warm up pearl colors for each tube
    tubes.forEach((tube, i) => {
      tube.power = 1;
      tube.foamIntensity = 0.01;
      updatePearlColors(tube, 0.01, i);
    });
    
    // Force one more render with pearls visible
    webglRenderer.render(scene, camera);
    
    // Clean up after compilation
    setTimeout(() => {
      // Remove dummy meshes
      dummyMeshes.forEach(mesh => {
        scene.remove(mesh);
      });
      dummyGeometry.dispose();
      
      // Reset tube states
      tubes.forEach((tube, i) => {
        tube.power = 0;
        tube.foamIntensity = 0;
        updatePearlColors(tube, 0, i);
      });
      
      // Remove loading indicator
      loadingIndicator.remove();
      
      console.log('√¢≈ì‚Ä¶ ALL ASSETS PRELOADED - Game ready!');
    }, 100);

    console.log('üéÆ Game started - coin textures already applied during tube creation');

    const gameInfoDiv = document.createElement('div');
    gameInfoDiv.className = 'game-info';
    gameInfoDiv.style.cssText = `
      width: 200px;
      background: rgba(10, 15, 35, 0.95);
      border: 3px solid #9d00ff;
      border-radius: 16px;
      padding: 15px;
      font-family: 'Orbitron', sans-serif;
      color: white;
      box-shadow: 0 0 30px rgba(157, 0, 255, 0.6);
      pointer-events: auto;
      text-align: center;
    `;
    
    gameInfoDiv.innerHTML = `
      <!-- Desktop: Original stacked layout -->
      <div class="desktop-timer-layout">
        <!-- Round Counter -->
        <div style="
          font-size: 18px;
          font-weight: bold;
          color: #00ffff;
          text-transform: uppercase;
          letter-spacing: 2px;
          margin-bottom: 10px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">ROUND <span id="round-number">1</span></div>
        
        <!-- Timer Display -->
        <div style="
          font-size: 50px;
          font-weight: bold;
          color: #00ff00;
          margin: 5px 0;
          font-family: 'Orbitron', monospace;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        " id="timer-display">30</div>
        <div style="
          font-size: 12px;
          color: #888;
          text-transform: uppercase;
          letter-spacing: 2px;
          margin-bottom: 10px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">SECONDS</div>
      </div>
      
      <!-- Mobile: Single line format -->
      <div class="mobile-timer-round" style="display: none;">
        <span class="round-text">Round <span id="round-number-mobile">1</span>:</span>
        <span class="timer-text"><span id="timer-display-mobile">30</span> Seconds</span>
      </div>
      
      <!-- Control Buttons Column -->
      <div style="
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 10px;
      ">
        <!-- Mute Button -->
        <button id="mute-btn" style="
          width: 100%;
          padding: 8px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          border: 2px solid #9d00ff;
          border-radius: 8px;
          color: white;
          font-weight: bold;
          font-size: 13px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-transform: uppercase;
          letter-spacing: 1px;
          box-shadow: 0 0 15px rgba(157, 0, 255, 0.4);
        ">üîá MUTE</button>
        
        <!-- Chat Button -->
        <button id="chat-btn" style="
          width: 100%;
          padding: 8px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          border: 2px solid #9d00ff;
          border-radius: 8px;
          color: white;
          font-weight: bold;
          font-size: 13px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-transform: uppercase;
          letter-spacing: 1px;
          box-shadow: 0 0 15px rgba(157, 0, 255, 0.4);
        ">üí¨ CHAT</button>
      </div>
    `;
    
    const gameInfoObject = new CSS3DObject(gameInfoDiv);
    gameInfoObject.position.set(0, 200 - (TUBE_HEIGHT / 2) - 160, 0);
    gameInfoObject.scale.set(0.5, 0.5, 0.5);
    scene.add(gameInfoObject);

    roundCounterElement = gameInfoDiv;
    timerElement = gameInfoDiv;
    const timerDisplay = gameInfoDiv.querySelector('#timer-display');
    const muteBtn = gameInfoDiv.querySelector('#mute-btn');
    const chatBtn = gameInfoDiv.querySelector('#chat-btn');

    [muteBtn, chatBtn].forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.transform = 'translateY(-2px)';
        btn.style.boxShadow = '0 5px 20px rgba(157, 0, 255, 0.8)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.transform = 'translateY(0)';
        btn.style.boxShadow = '0 0 15px rgba(157, 0, 255, 0.4)';
      });
    });

    muteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const muted = toggleMute();
      
      if (muted) {
        muteBtn.textContent = '√∞≈∏‚Äù‚Ä° UNMUTE';
        muteBtn.style.background = 'linear-gradient(135deg, #666666, #888888)';
        muteBtn.style.borderColor = '#666666';
      } else {
        muteBtn.textContent = '√∞≈∏‚Äù≈† MUTE';
        muteBtn.style.background = 'linear-gradient(135deg, #9d00ff, #c44aff)';
        muteBtn.style.borderColor = '#9d00ff';
      }
    });

    chatBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (!gameIdParam) {
        alert('Chat unavailable: missing gameId');
        return;
      }
      const overlay = document.createElement('div');
      
      const isMobile = window.innerWidth <= 768;
      
      if (isMobile) {
        overlay.style.cssText = `
          position: fixed;
          right: 10px;
          bottom: 10px;
          width: calc(100vw - 20px);
          max-width: 280px;
          height: 300px;
          max-height: calc(100vh - 20px);
          background: rgba(10, 15, 35, 0.98);
          border: 2px solid #9d00ff;
          border-radius: 12px;
          z-index: 10002;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        `;
      } else {
        overlay.style.cssText = `
          position: fixed;
          right: 20px;
          bottom: 20px;
          width: 320px;
          height: 420px;
          background: rgba(10, 15, 35, 0.98);
          border: 2px solid #9d00ff;
          border-radius: 12px;
          z-index: 10002;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        `;
      }
      const header = document.createElement('div');
      if (isMobile) {
        header.style.cssText = `
          padding: 8px 10px; color: #fff; font-weight: bold; font-size: 14px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          display: flex; align-items: center; justify-content: space-between;
        `;
      } else {
        header.style.cssText = `
          padding: 10px 12px; color: #fff; font-weight: bold;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          display: flex; align-items: center; justify-content: space-between;
        `;
      }
      header.innerHTML = `<span>Lobby Chat</span><button style="all: unset; cursor: pointer; font-weight: bold;">√¢≈ì‚Äì</button>`;
      const closeBtn = header.querySelector('button');
      closeBtn.onclick = () => overlay.remove();
      const list = document.createElement('div');
      if (isMobile) {
        list.style.cssText = `flex: 1; overflow-y: auto; padding: 8px; display: flex; flex-direction: column; gap: 6px;`;
      } else {
        list.style.cssText = `flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px;`;
      }
      
      const inputRow = document.createElement('div');
      if (isMobile) {
        inputRow.style.cssText = `display: flex; gap: 4px; padding: 6px; background: rgba(255,255,255,0.05);`;
      } else {
        inputRow.style.cssText = `display: flex; gap: 6px; padding: 8px; background: rgba(255,255,255,0.05);`;
      }
      
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Type message (read-only for now)';
      input.disabled = true;
      if (isMobile) {
        input.style.cssText = `flex:1; background: rgba(0,0,0,0.4); border: 1px solid #444; color: #fff; padding: 6px; border-radius: 6px; font-size: 14px;`;
      } else {
        input.style.cssText = `flex:1; background: rgba(0,0,0,0.4); border: 1px solid #444; color: #fff; padding: 8px; border-radius: 8px;`;
      }
      
      const sendBtn = document.createElement('button');
      sendBtn.textContent = 'Send';
      sendBtn.disabled = true;
      if (isMobile) {
        sendBtn.style.cssText = `padding: 6px 8px; color: #000; background: #ccc; border-radius: 6px; border: none; cursor: not-allowed; font-size: 12px;`;
      } else {
        sendBtn.style.cssText = `padding: 8px 10px; color: #000; background: #ccc; border-radius: 8px; border: none; cursor: not-allowed;`;
      }
      inputRow.appendChild(input);
      inputRow.appendChild(sendBtn);
      overlay.appendChild(header);
      overlay.appendChild(list);
      overlay.appendChild(inputRow);
      document.body.appendChild(overlay);

      try {
        const res = await fetch(`/api/chat/${encodeURIComponent(gameIdParam)}?limit=50`);
        if (res.ok) {
          const data = await res.json();
          const messages = data.messages || [];
          messages.forEach(m => {
            const row = document.createElement('div');
            row.style.cssText = `background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px; color:#fff;`;
            const name = m.username || (m.address ? m.address.slice(0,6)+'...'+m.address.slice(-4) : 'User');
            const content = m.message || '';
            row.innerHTML = `<div style="font-weight:bold; color:#9d00ff;">${name}</div><div style="font-size: 0.9rem;">${content}</div>`;
            list.appendChild(row);
          });
          list.scrollTop = list.scrollHeight;
        } else {
          const row = document.createElement('div');
          row.style.cssText = `padding:8px; color:#fff;`;
          row.textContent = 'Failed to load chat history';
          list.appendChild(row);
        }
      } catch (err) {
        const row = document.createElement('div');
        row.style.cssText = `padding:8px; color:#fff;`;
        row.textContent = 'Error loading chat history';
        list.appendChild(row);
      }
    });


    function updateTimerDisplay(serverTime) {
      if (timerElement) {
        const timerDisplay = timerElement.querySelector('#timer-display');
        if (timerDisplay) {
          timerDisplay.textContent = serverTime;
          
          if (serverTime <= 5) {
            timerDisplay.style.color = '#ff0000';
          } else if (serverTime <= 10) {
            timerDisplay.style.color = '#ffaa00';
          } else {
            timerDisplay.style.color = '#00ff00';
          }
        }
        
        const mobileTimerDisplay = timerElement.querySelector('#timer-display-mobile');
        if (mobileTimerDisplay) {
          mobileTimerDisplay.textContent = serverTime;
          
          if (serverTime <= 5) {
            mobileTimerDisplay.style.color = '#ff0000';
          } else if (serverTime <= 10) {
            mobileTimerDisplay.style.color = '#ffaa00';
          } else {
            mobileTimerDisplay.style.color = '#00ff00';
          }
        }
      }
      
      if (isMobile()) {
        updateMobileDisplays();
      }
    }



    function showCoinSelector(tubeIndex) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 20px;
      `;

      const content = document.createElement('div');
      
      if (isMobile()) {
        content.style.cssText = `
          background: rgba(0, 0, 0, 0.95);
          border: 2px solid #FFD700;
          border-radius: 12px;
          padding: 15px 20px;
          width: 95%;
          max-width: 100%;
          max-height: 90vh;
          overflow-y: auto;
        `;
      } else {
        content.style.cssText = `
          background: rgba(0, 0, 0, 0.95);
          border: 2px solid #FFD700;
          border-radius: 15px;
          padding: 40px 50px;
          width: 95%;
          max-width: 1600px;
          max-height: 85vh;
          overflow-y: auto;
        `;
      }

      let playerFlipBalance = 0; // Will be fetched from server
      let unlockedCoins = ['plain']; // Will be fetched from server
      let customCoinHeads = null;
      let customCoinTails = null;

      if (isServerSideMode && socket && walletParam) {
        console.log('√∞≈∏‚Äù¬ç Fetching profile for wallet:', walletParam);
        
        socket.off('player_profile_data');
        
        socket.on('player_profile_data', (profileData) => {
          console.log('√∞≈∏‚Äú≈† Received profile data:', profileData);
          playerFlipBalance = profileData.flip_balance || 0;
          unlockedCoins = JSON.parse(profileData.unlocked_coins || '["plain"]');
          customCoinHeads = profileData.custom_coin_heads;
          customCoinTails = profileData.custom_coin_tails;
          console.log('√∞≈∏‚Äô¬∞ Updated FLIP balance:', playerFlipBalance);
          console.log('√∞≈∏‚Äù‚Äú Updated unlocked coins:', unlockedCoins);
          updateCoinDisplay();
        });
        
        socket.emit('get_player_profile', { address: walletParam });
      } else {
        console.log('√¢≈°¬†√Ø¬∏¬è Cannot fetch profile - missing:', {
          isServerSideMode,
          hasSocket: !!socket,
          walletParam
        });
      }

      function updateCoinDisplay() {
        const coinGrid = content.querySelector('.coin-grid');
        if (!coinGrid) return;

        const flipBalanceElement = document.getElementById('flip-balance');
        if (flipBalanceElement) {
          flipBalanceElement.textContent = playerFlipBalance;
        }

        coinGrid.innerHTML = `
          ${coinOptions.map(coin => {
            const isUnlocked = unlockedCoins.includes(coin.id);
            const canAfford = playerFlipBalance >= coin.cost;
            const isLocked = !isUnlocked && coin.cost > 0;
            
            let borderColor = 'rgba(255, 215, 0, 0.25)';
            let backgroundColor = 'rgba(255, 215, 0, 0.08)';
            let opacity = '1';
            let cursor = 'pointer';
            
            if (isLocked) {
              borderColor = 'rgba(255, 0, 0, 0.5)';
              backgroundColor = 'rgba(255, 0, 0, 0.1)';
              opacity = '0.6';
              cursor = canAfford ? 'pointer' : 'not-allowed';
            }
            
            const isMobileDevice = isMobile();
            return `
              <div class="coin-option" data-coin-id="${coin.id}" data-cost="${coin.cost}" data-unlocked="${isUnlocked}" style="
                background: ${backgroundColor};
                border: 2px solid ${borderColor};
                border-radius: ${isMobileDevice ? '8px' : '12px'};
                padding: ${isMobileDevice ? '8px' : '15px'};
                text-align: center;
                cursor: ${cursor};
                transition: all 0.3s ease;
                opacity: ${opacity};
                position: relative;
              ">
                ${isLocked ? `
                  <div style="position: absolute; top: 3px; right: 3px; background: rgba(255, 0, 0, 0.8); color: white; border-radius: 50%; width: ${isMobileDevice ? '16px' : '20px'}; height: ${isMobileDevice ? '16px' : '20px'}; display: flex; align-items: center; justify-content: center; font-size: ${isMobileDevice ? '10px' : '12px'}; font-weight: bold;">üî¥</div>
                ` : ''}
                <img src="${coin.headsImage}" style="width: ${isMobileDevice ? '45px' : '65px'}; height: ${isMobileDevice ? '45px' : '65px'}; object-fit: contain; margin-bottom: ${isMobileDevice ? '4px' : '8px'}; display: block; margin-left: auto; margin-right: auto;" />
                <div style="color: #FFD700; font-weight: bold; font-family: 'Orbitron', sans-serif; font-size: ${isMobileDevice ? '0.7rem' : '0.85rem'}; margin-bottom: ${isMobileDevice ? '2px' : '4px'}; line-height: 1.2;">${coin.name}</div>
                ${coin.cost > 0 ? `
                  <div style="color: ${isUnlocked ? '#00ff00' : canAfford ? '#FFD700' : '#ff4444'}; font-size: ${isMobileDevice ? '0.6rem' : '0.75rem'}; font-weight: bold;">
                    ${isUnlocked ? 'UNLOCKED' : `${coin.cost} FLIP`}
                  </div>
                ` : `<div style="color: #00ff00; font-size: ${isMobileDevice ? '0.6rem' : '0.75rem'}; font-weight: bold;">FREE</div>`}
              </div>
            `;
          }).join('')}
          
          <!-- Custom Coin Option -->
          ${customCoinHeads && customCoinTails ? `
            <div class="coin-option" data-coin-id="custom" data-cost="0" data-unlocked="true" style="
              background: rgba(255, 215, 0, 0.08);
              border: 2px solid rgba(255, 215, 0, 0.25);
              border-radius: ${isMobile() ? '8px' : '12px'};
              padding: ${isMobile() ? '8px' : '15px'};
              text-align: center;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
            ">
              <img src="${customCoinHeads}" style="width: ${isMobile() ? '45px' : '65px'}; height: ${isMobile() ? '45px' : '65px'}; object-fit: contain; margin-bottom: ${isMobile() ? '4px' : '8px'}; display: block; margin-left: auto; margin-right: auto;" />
              <div style="color: #FFD700; font-weight: bold; font-family: 'Orbitron', sans-serif; font-size: ${isMobile() ? '0.7rem' : '0.85rem'}; margin-bottom: ${isMobile() ? '2px' : '4px'}; line-height: 1.2;">Custom</div>
              <div style="color: #00ff00; font-size: ${isMobile() ? '0.6rem' : '0.75rem'}; font-weight: bold;">YOURS</div>
            </div>
          ` : ''}
        `;
        
        attachCoinEventListeners();
      }

      content.innerHTML = `
        <h2 style="color: #FFD700; text-align: center; margin-bottom: ${isMobile() ? '20px' : '35px'}; font-family: 'Orbitron', sans-serif; font-size: ${isMobile() ? '1.3rem' : '1.8rem'};">Customize Your Coin</h2>
        
        <!-- Flip Balance Display -->
        <div style="text-align: center; margin-bottom: ${isMobile() ? '15px' : '30px'}; padding: ${isMobile() ? '10px' : '15px'}; background: rgba(255, 215, 0, 0.1); border-radius: ${isMobile() ? '8px' : '10px'}; border: 1px solid rgba(255, 215, 0, 0.3);">
          <div style="color: #FFD700; font-family: 'Orbitron', sans-serif; font-size: ${isMobile() ? '0.9rem' : '1.2rem'}; font-weight: bold;">
            Your FLIP Balance: <span id="flip-balance">Loading...</span>
          </div>
        </div>
        
        <!-- Coin Design Section -->
        <h3 style="color: #FFD700; margin-bottom: ${isMobile() ? '12px' : '20px'}; font-family: 'Orbitron', sans-serif; font-size: ${isMobile() ? '1rem' : '1.2rem'};">Coin Design</h3>
        <div class="coin-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(${isMobile() ? '80px' : '110px'}, 1fr)); gap: ${isMobile() ? '10px' : '15px'}; margin-bottom: ${isMobile() ? '20px' : '40px'};">
          <!-- Coins will be populated here -->
        </div>
        
        <!-- Material Selection Section -->
        <div style="height: 1px; background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent); margin: ${isMobile() ? '15px' : '30px'} 0;"></div>
        <h3 style="color: #FFD700; margin-bottom: ${isMobile() ? '12px' : '20px'}; font-family: 'Orbitron', sans-serif; font-size: ${isMobile() ? '1rem' : '1.2rem'};">Coin Material</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(${isMobile() ? '120px' : '180px'}, 1fr)); gap: ${isMobile() ? '10px' : '15px'}; margin-bottom: ${isMobile() ? '20px' : '30px'};">
          ${coinMaterials.map(material => {
            const isMobileDevice = isMobile();
            return `
            <div class="material-option" data-material-id="${material.id}" style="
              background: rgba(255, 255, 255, 0.05);
              border: 2px solid rgba(255, 255, 255, 0.15);
              border-radius: ${isMobileDevice ? '8px' : '12px'};
              padding: ${isMobileDevice ? '12px' : '18px'};
              cursor: pointer;
              transition: all 0.3s ease;
              text-align: center;
            ">
              <div style="
                width: ${isMobileDevice ? '35px' : '55px'};
                height: ${isMobileDevice ? '35px' : '55px'};
                border-radius: 50%;
                margin: 0 auto ${isMobileDevice ? '8px' : '12px'};
                border: 3px solid ${material.edgeColor};
                background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3), rgba(0,0,0,0.2));
                box-shadow: 0 0 15px ${material.edgeColor}60;
              "></div>
              <div style="color: #fff; font-weight: bold; font-size: ${isMobileDevice ? '0.8rem' : '1rem'}; margin-bottom: ${isMobileDevice ? '4px' : '6px'}; line-height: 1.2;">${material.name}</div>
              <div style="color: ${material.edgeColor}; font-size: ${isMobileDevice ? '0.65rem' : '0.8rem'}; margin-bottom: ${isMobileDevice ? '4px' : '8px'}; line-height: 1.2;">${material.description}</div>
              <div style="color: #fff; font-size: ${isMobileDevice ? '0.6rem' : '0.7rem'}; opacity: 0.7; line-height: 1.3;">${material.characteristics}</div>
            </div>
          `;
          }).join('')}
        </div>
        
        <button class="close-btn" style="
          width: 100%;
          max-width: ${isMobile() ? '300px' : '400px'};
          margin: ${isMobile() ? '15px' : '20px'} auto 0;
          padding: 16px;
          background: linear-gradient(135deg, #ff1493, #ff69b4);
          border: none;
          border-radius: 12px;
          color: white;
          font-weight: bold;
          cursor: pointer;
          font-family: 'Orbitron', sans-serif;
          font-size: 1rem;
          letter-spacing: 1px;
          display: block;
          box-shadow: 0 4px 15px rgba(255, 20, 147, 0.4);
          transition: all 0.3s ease;
        ">APPLY CHANGES</button>
      `;

      modal.appendChild(content);
      document.body.appendChild(modal);
      
      let selectedCoin = tubes[tubeIndex].selectedCoin || coinOptions[0];
      let selectedMaterial = tubes[tubeIndex].selectedMaterial || coinMaterials[0];
      
      if (!selectedMaterial || !selectedMaterial.id || selectedMaterial.id !== 'graphite') {
        selectedMaterial = coinMaterials[0];
        tubes[tubeIndex].selectedMaterial = selectedMaterial;
        console.log(`√∞≈∏‚Äù¬ß Forced material reset to: ${selectedMaterial.name}`);
      }
      
      updateCoinDisplay();
      
      function attachCoinEventListeners() {
        content.querySelectorAll('.coin-option').forEach(option => {
          const handleCoinSelection = (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const coinId = option.dataset.coinId;
            const cost = parseInt(option.dataset.cost);
            const isUnlocked = option.dataset.unlocked === 'true';
            
            console.log(`ü™ô Coin selection attempt: ${coinId}, unlocked: ${isUnlocked}, cost: ${cost}`);
            
            if (coinId === 'custom') {
              selectedCoin = {
                id: 'custom',
                name: 'Custom',
                headsImage: customCoinHeads,
                tailsImage: customCoinTails,
                cost: 0,
                category: 'custom'
              };
              console.log(`√¢≈ì‚Ä¶ Custom coin selected`);
            } else {
              const coin = coinOptions.find(c => c.id === coinId);
              if (!coin) {
                console.log(`√¢¬ù≈í Coin not found: ${coinId}`);
                return;
              }
              
              if (!isUnlocked && cost > 0) {
                if (playerFlipBalance >= cost) {
                  console.log(`√∞≈∏‚Äù‚Äú Unlocking ${coin.name} for ${cost} FLIP`);
                  
                  const coinElement = content.querySelector(`[data-coin-id="${coinId}"]`);
                  if (coinElement) {
                    coinElement.style.opacity = '0.5';
                    coinElement.style.pointerEvents = 'none';
                  }
                  
                  if (isServerSideMode && socket && walletParam) {
                    console.log(`√∞≈∏‚Äù‚Äú Requesting unlock: ${coinId} for ${cost} FLIP`);
                    
                    socket.off('coin_unlocked');
                    
                    socket.on('coin_unlocked', (result) => {
                      console.log('√∞≈∏‚Äú¬® Received unlock response:', result);
                      
                      if (result.success) {
                        console.log(`√¢≈ì‚Ä¶ Server confirmed unlock: ${coin.name}`);
                        
                        playerFlipBalance = result.newBalance;
                        unlockedCoins = result.unlockedCoins;
                        
                        const balanceElement = document.getElementById('flip-balance');
                        if (balanceElement) {
                          balanceElement.textContent = playerFlipBalance;
                        }
                        
                        updateCoinDisplay();
                        selectedCoin = coin;
                        updateCoinSelection();
                        
                        alert(`√∞≈∏≈Ω‚Ä∞ ${coin.name} unlocked for ${cost} FLIP!\n\nNew balance: ${playerFlipBalance} FLIP`);
                      } else {
                        console.error(`√¢¬ù≈í Server unlock failed:`, result.error);
                        alert(`√¢¬ù≈í Failed to unlock ${coin.name}:\n\n${result.error}`);
                        
                        if (coinElement) {
                          coinElement.style.opacity = '1';
                          coinElement.style.pointerEvents = 'auto';
                        }
                      }
                    });
                    
                    socket.emit('unlock_coin', {
                      address: walletParam,
                      coinId: coinId,
                      cost: cost
                    });
                  } else {
                    console.error('√¢¬ù≈í Cannot unlock - connection issue:', {
                      isServerSideMode,
                      hasSocket: !!socket,
                      hasWallet: !!walletParam
                    });
                    alert(`√¢¬ù≈í Cannot unlock coin: Server connection required`);
                    
                    if (coinElement) {
                      coinElement.style.opacity = '1';
                      coinElement.style.pointerEvents = 'auto';
                    }
                  }
                } else {
                  alert(`Not enough FLIP! You need ${cost} FLIP to unlock ${coin.name}.`);
                  return;
                }
              } else {
                selectedCoin = coin;
                console.log(`√¢≈ì‚Ä¶ Coin selected: ${coin.name}`);
              }
            }
            
            updateCoinSelection();
          };
          
          option.addEventListener('click', handleCoinSelection);
          option.addEventListener('touchstart', handleCoinSelection);
          
          option.addEventListener('mouseenter', () => {
            if (selectedCoin.id !== option.dataset.coinId) {
              option.style.transform = 'scale(1.05)';
            } else {
              option.style.transform = 'scale(1.1)';
            }
          });
          option.addEventListener('mouseleave', () => {
            if (selectedCoin.id !== option.dataset.coinId) {
              option.style.transform = 'scale(1)';
            } else {
              option.style.transform = 'scale(1.05)';
            }
          });
        });
      }
      
      function updateCoinSelection() {
        console.log(`√∞≈∏≈Ω¬® Updating coin selection visual feedback for: ${selectedCoin.id}`);
        
        content.querySelectorAll('.coin-option').forEach(opt => {
          opt.style.background = opt.dataset.unlocked === 'true' ? 'rgba(255, 215, 0, 0.08)' : 'rgba(255, 0, 0, 0.1)';
          opt.style.borderColor = opt.dataset.unlocked === 'true' ? 'rgba(255, 215, 0, 0.25)' : 'rgba(255, 0, 0, 0.5)';
          opt.style.transform = 'scale(1)';
        });
        
        const selectedOption = content.querySelector(`[data-coin-id="${selectedCoin.id}"]`);
        if (selectedOption) {
          selectedOption.style.background = 'rgba(255, 215, 0, 0.4)';
          selectedOption.style.borderColor = '#FFD700';
          selectedOption.style.borderWidth = '3px';
          selectedOption.style.transform = 'scale(1.1)';
          selectedOption.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.6)';
          console.log(`√¢≈ì‚Ä¶ Visual feedback applied to selected coin: ${selectedCoin.name}`);
        } else {
          console.log(`√¢¬ù≈í Could not find selected coin option for ID: ${selectedCoin.id}`);
        }
      }
      
      content.querySelectorAll('.material-option').forEach(option => {
        const handleMaterialSelection = (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const materialId = option.dataset.materialId;
          selectedMaterial = coinMaterials.find(m => m.id === materialId);
          
          console.log(`√∞≈∏‚Äù¬ß Material selection attempt: ${materialId}`);
          
          if (selectedMaterial) {
            content.querySelectorAll('.material-option').forEach(opt => {
              opt.style.background = 'rgba(255, 255, 255, 0.05)';
              opt.style.borderColor = 'rgba(255, 255, 255, 0.2)';
              opt.style.transform = 'scale(1)';
            });
            
            option.style.background = 'rgba(255, 215, 0, 0.2)';
            option.style.borderColor = '#FFD700';
            option.style.transform = 'scale(1.05)';
            
            console.log(`√¢≈ì‚Ä¶ Material selected: ${selectedMaterial.name}`);
          } else {
            console.log(`√¢¬ù≈í Material not found: ${materialId}`);
          }
        };
        
        option.addEventListener('click', handleMaterialSelection);
        option.addEventListener('touchstart', handleMaterialSelection);
        
        option.addEventListener('mouseenter', () => {
          if (selectedMaterial.id !== option.dataset.materialId) {
            option.style.background = 'rgba(255, 255, 255, 0.1)';
            option.style.transform = 'scale(1.05)';
          } else {
            option.style.background = 'rgba(255, 215, 0, 0.3)';
            option.style.transform = 'scale(1.1)';
          }
        });
        option.addEventListener('mouseleave', () => {
          if (selectedMaterial.id !== option.dataset.materialId) {
            option.style.background = 'rgba(255, 255, 255, 0.05)';
            option.style.transform = 'scale(1)';
          } else {
            option.style.background = 'rgba(255, 215, 0, 0.2)';
            option.style.transform = 'scale(1.05)';
          }
        });
      });
      
      const closeBtn = content.querySelector('.close-btn');
      
      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.transform = 'translateY(-2px)';
        closeBtn.style.boxShadow = '0 6px 20px rgba(255, 20, 147, 0.6)';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.transform = 'translateY(0)';
        closeBtn.style.boxShadow = '0 4px 15px rgba(255, 20, 147, 0.4)';
      });
      
      const handleCloseButton = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('√∞≈∏‚Äù¬¥ APPLY CHANGES button clicked - closing modal');
        
        tubes[tubeIndex].selectedCoin = selectedCoin;
        tubes[tubeIndex].selectedMaterial = selectedMaterial;
        
        const loader = new THREE.TextureLoader();
        loader.load(selectedCoin.headsImage, (headsTexture) => {
          headsTexture.minFilter = THREE.LinearFilter;
          headsTexture.magFilter = THREE.LinearFilter;
          headsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
          headsTexture.generateMipmaps = false;
          
          loader.load(selectedCoin.tailsImage, (tailsTexture) => {
            tailsTexture.minFilter = THREE.LinearFilter;
            tailsTexture.magFilter = THREE.LinearFilter;
            tailsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
            tailsTexture.generateMipmaps = false;
            
            tubes[tubeIndex].coin.material[1].uniforms.map.value = headsTexture;
            tubes[tubeIndex].coin.material[1].needsUpdate = true;
            tubes[tubeIndex].coin.material[2].uniforms.map.value = tailsTexture;
            tubes[tubeIndex].coin.material[2].needsUpdate = true;
            
            const edgeColor = new THREE.Color(selectedMaterial.edgeColor);
            tubes[tubeIndex].coin.material[0].color.copy(edgeColor);
            tubes[tubeIndex].coin.material[0].emissive.copy(edgeColor);
            tubes[tubeIndex].coin.material[0].emissiveIntensity = 0.3;
            tubes[tubeIndex].coin.material[0].needsUpdate = true;
            
            console.log(`√¢≈ì‚Ä¶ Applied ${selectedCoin.name} with ${selectedMaterial.name} material to ${players[tubeIndex].name}'s coin`);
            
            if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === tubeIndex) {
              socket.emit('physics_update_coin', {
                gameId: gameIdParam,
                address: walletParam,
                coinData: {
                  id: selectedCoin.id,
                  type: selectedCoin.type,
                  name: selectedCoin.name,
                  headsImage: selectedCoin.headsImage,
                  tailsImage: selectedCoin.tailsImage,
                  material: selectedMaterial
                }
              });
              console.log(`√∞≈∏≈Ω¬Ø Sent coin update to server: ${selectedCoin.name}`);
            }
          });
        });
        
        modal.remove();
      };
      
      closeBtn.addEventListener('click', handleCloseButton);
      closeBtn.addEventListener('touchend', handleCloseButton);

      const handleModalClose = (e) => {
        console.log('√∞≈∏‚Äì¬±√Ø¬∏¬è Background click detected, target:', e.target, 'modal:', modal);
        if (e.target === modal) {
          console.log('√¢≈ì‚Ä¶ Closing modal via background click');
          e.preventDefault();
          e.stopPropagation();
          modal.remove();
        }
      };
      
      modal.addEventListener('click', handleModalClose);
      modal.addEventListener('touchend', handleModalClose);
      modal.addEventListener('touchstart', (e) => {
        if (e.target === modal) {
          e.preventDefault();
        }
      });
      
      content.addEventListener('click', (e) => {
        e.stopPropagation();
        console.log('√∞≈∏‚Ä∫¬°√Ø¬∏¬è Content click prevented from closing modal');
      });
      content.addEventListener('touchend', (e) => {
        e.stopPropagation();
        console.log('√∞≈∏‚Ä∫¬°√Ø¬∏¬è Content touch prevented from closing modal');
      });
    }

    function shatterGlass(tubeIndex, powerLevel) {
      const tube = tubes[tubeIndex];
      if (tube.isShattered) return;
      
      const powerPercent = powerLevel / 100;
      console.log(`√∞≈∏‚Äô¬• Shattering glass for tube ${tubeIndex + 1} at ${powerLevel.toFixed(0)}% power`);
      
      stopSound(powerChargeSound);
      playSound(glassBreakSound);
      
      tube.isShattered = true;
      
      tube.tube.visible = false;
      tube.backing.visible = false;
      tube.topRim.visible = false;
      tube.bottomRim.visible = false;
      tube.liquid.visible = false; // Hide the transparent liquid surface mesh
      
      tube.coinShadow.visible = true;
      
      physicsWorld.removeBody(tube.glassBody);
      
      const shardCount = Math.floor(20 + (powerPercent * 60));
      const tubeY = 200;
      
      for (let s = 0; s < shardCount; s++) {
        const size = Math.random() * 12 + 5;
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0, 0, 0,
          size, 0, 0,
          size * 0.5, size, 0
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        const material = new THREE.MeshStandardMaterial({
          color: 0xe0e0e0, // Bright silver
          metalness: 0.95, // Very metallic silver
          roughness: 0.1,
          emissive: 0xc0c0c0, // Silver glow
          emissiveIntensity: 0.4,
          side: THREE.DoubleSide
        });
        
        const shard = new THREE.Mesh(geometry, material);
        
        const angle = (s / shardCount) * Math.PI * 2;
        const heightPos = (Math.random() - 0.5) * TUBE_HEIGHT;
        shard.position.set(
          tube.tube.position.x + Math.cos(angle) * TUBE_RADIUS,
          tubeY + heightPos,
          Math.sin(angle) * TUBE_RADIUS
        );
        
        shard.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        const baseSpeed = 2 + (powerPercent * 12);
        const velocity = {
          x: Math.cos(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5),
          y: Math.random() * 3 - 1.5,
          z: Math.sin(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5)
        };
        
        const rotVelocity = {
          x: (Math.random() - 0.5) * 0.3,
          y: (Math.random() - 0.5) * 0.3,
          z: (Math.random() - 0.5) * 0.3
        };
        
        scene.add(shard);
        
        tube.glassShards.push({
          mesh: shard,
          velocity,
          rotVelocity,
          lifetime: 0
        });
      }
      
      tube.liquidParticles.forEach((particleBody, idx) => {
        const dx = particleBody.position.x - tube.tube.position.x;
        const dz = particleBody.position.z - tube.tube.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz) || 1;
        
        const baseForce = 2000 + (powerPercent * 16000);
        const explosionForce = baseForce + Math.random() * (baseForce * 0.3);
        
        particleBody.velocity.set(
          (dx / distance) * explosionForce,
          Math.random() * 800 - 400,
          (dz / distance) * explosionForce
        );
        
        const spinForce = 15 * powerPercent;
        particleBody.angularVelocity.set(
          Math.random() * spinForce * 2 - spinForce,
          Math.random() * spinForce * 2 - spinForce,
          Math.random() * spinForce * 2 - spinForce
        );
      });
      
      console.log(`√∞≈∏‚Äô¬• Glass shattered! ${shardCount} shards + ${tube.liquidParticles.length} liquid particles at ${powerLevel.toFixed(0)}% power`);
    }

    const FLIP_REWARDS = [
      { amount: 50, color: '#ffffff', weight: 40 },      // White - Very common
      { amount: 100, color: '#87ceeb', weight: 25 },     // Sky blue - Common
      { amount: 250, color: '#ffff00', weight: 15 },     // Yellow - Uncommon
      { amount: 300, color: '#00ff00', weight: 10 },     // Green - Uncommon
      { amount: 500, color: '#ff8800', weight: 5 },      // Orange - Rare
      { amount: 750, color: '#9d00ff', weight: 3 },      // Purple - Very rare
      { amount: 1000, color: '#FFD700', weight: 2 }      // Gold - Extremely rare
    ];

    function getRandomFlipReward() {
      const totalWeight = FLIP_REWARDS.reduce((sum, r) => sum + r.weight, 0);
      let random = Math.random() * totalWeight;
      
      for (const reward of FLIP_REWARDS) {
        random -= reward.weight;
        if (random <= 0) {
          return reward;
        }
      }
      
      return FLIP_REWARDS[0]; // Fallback to 50
    }

    function showFlipReward(tubeIndex, serverReward = null) {
      const tube = tubes[tubeIndex];
      const player = players[tubeIndex];
      
      
      const reward = serverReward || getRandomFlipReward();
      console.log(`√∞≈∏‚Äô¬∞ Player ${tubeIndex + 1} earned ${reward.amount} FLIP!`);
      
      if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === tubeIndex) {
        socket.emit('award_flip_tokens', {
          gameId: gameIdParam,
          address: walletParam,
          amount: reward.amount,
          reason: 'coin_flip_reward'
        });
        console.log(`√∞≈∏≈Ω¬Ø Sent FLIP token award to server: ${reward.amount} tokens`);
        
        updateXPCounter(reward.amount);
      }
      
      const rewardBox = document.createElement('div');
      rewardBox.style.cssText = `
        width: 200px;
        padding: 12px 18px;
        background: #0a0f2e;
        border: 3px solid ${reward.color};
        border-radius: 12px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        box-shadow: 0 0 40px ${reward.color}99;
        pointer-events: none;
        transform: scaleY(-1);
        backdrop-filter: blur(10px);
      `;
      
      rewardBox.innerHTML = `
        <div style="
          font-size: 28px;
          font-weight: bold;
          color: ${reward.color};
          text-transform: uppercase;
          letter-spacing: 2px;
          margin-bottom: 3px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          +${reward.amount} FLIP
        </div>
        <div style="
          font-size: 13px;
          color: #ffffff;
          text-transform: uppercase;
          letter-spacing: 1px;
          opacity: 0.9;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          Token Reward
        </div>
      `;
      
      const cssObject = new CSS3DObject(rewardBox);
      const tubeTopY = 200 + (TUBE_HEIGHT / 2);
      cssObject.position.set(tube.tube.position.x, tubeTopY + 100, 0);
      cssObject.scale.set(0.5, 0.5, 0.5);
      scene.add(cssObject);
      
      tube.rewardBox = cssObject;
      
      rewardBox.style.opacity = '0';
      rewardBox.style.transform = 'scaleY(-1) scale(0.5) translateY(30px)';
      rewardBox.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
      
      setTimeout(() => {
        rewardBox.style.opacity = '1';
        rewardBox.style.transform = 'scaleY(-1) scale(1) translateY(0px)';
      }, 50);
      
      setTimeout(() => {
        rewardBox.style.transition = 'all 0.5s ease-in';
        rewardBox.style.opacity = '0';
        rewardBox.style.transform = 'scaleY(-1) scale(1.1) translateY(-40px)';
      }, 1500);
      
      setTimeout(() => {
        scene.remove(cssObject);
      }, 2100);
    }

    function flipCoinWithPower(tubeIndex, powerLevel, playerChoice) {
      const tube = tubes[tubeIndex];
      const coin = coins[tubeIndex];
      const powerPercent = powerLevel / 100;
      
      showFlipReward(tubeIndex);
      
      const material = tube.selectedMaterial || coinMaterials[2]; // Default to glass
      const speedMult = material.speedMultiplier;
      const durationMult = material.durationMultiplier;
      
      const baseDuration = 2000 + (powerPercent * 6000);
      const flipDuration = baseDuration * durationMult;
      
      const basePowerSpeed = Math.max(0.08, 0.05 + (powerPercent * 0.25));
      const baseFlipSpeed = basePowerSpeed * speedMult;
      
      console.log(`ü™ô Material: ${material.name} - Speed: ${speedMult}x, Duration: ${durationMult}x`);
      
      // √¢≈ì‚Ä¶ FIX: Use sweet spot accuracy to influence outcome!
      const accuracyData = calculateReleaseAccuracy(powerLevel);
      const winChance = accuracyData.winChance;
      
      // Random roll against win chance
      const randomRoll = Math.random();
      const didWin = randomRoll < winChance;
      
      // Result is based on whether they won, not pure random
      const result = didWin ? playerChoice : (playerChoice === 'heads' ? 'tails' : 'heads');
      
      console.log(`ü™ô Flipping coin ${tubeIndex + 1} - Power: ${powerLevel}%, Accuracy: ${accuracyData.accuracy}, Win Chance: ${(winChance * 100).toFixed(1)}%, Roll: ${(randomRoll * 100).toFixed(1)}%, Won: ${didWin}, Result: ${result}, Choice: ${playerChoice}`);
      
      const startTime = Date.now();
      
      // √¢≈ì‚Ä¶ FIX: Calculate natural landing rotation to prevent snapback
      const targetRotationX = result === 'heads' ? Math.PI / 2 : (3 * Math.PI / 2);
      
      tube.isFlipping = true;
      
      const startRotation = coin.rotation.x;
      const rotationsPerSecond = baseFlipSpeed * 60;
      const totalRotations = (rotationsPerSecond * (flipDuration / 1000)) / (Math.PI * 2);
      
      // √¢≈ì‚Ä¶ FIX: Calculate how many full rotations to do, then land naturally on target
      // We want the coin to spin many times, then decelerate to land on the target face
      const minFullRotations = Math.floor(totalRotations) - 1; // At least this many full spins
      const targetRotationTotal = startRotation + (minFullRotations * Math.PI * 2) + targetRotationX;
      
      const animateFlip = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / flipDuration, 1);
        
        // √¢≈ì‚Ä¶ FIX: Smooth deceleration curve - no snap!
        const easeOutQuart = 1 - Math.pow(1 - progress, 4);
        coin.rotation.x = startRotation + (targetRotationTotal - startRotation) * easeOutQuart;
        
        // Wobble during flip for realism
        if (progress < 0.9) {
          coin.rotation.y = (Math.PI / 2) + Math.sin(progress * Math.PI * 8) * 0.1;
          coin.rotation.z = Math.sin(progress * Math.PI * 6) * 0.05;
        } else {
          // Stabilize at the end
          const stabilizeProgress = (progress - 0.9) / 0.1;
          coin.rotation.y = (Math.PI / 2) + (1 - stabilizeProgress) * Math.sin(progress * Math.PI * 8) * 0.1;
          coin.rotation.z = (1 - stabilizeProgress) * Math.sin(progress * Math.PI * 6) * 0.05;
        }
        
        if (progress < 1) {
          requestAnimationFrame(animateFlip);
        } else {
          // Final position - perfectly facing camera
          coin.rotation.x = targetRotationTotal;
          coin.rotation.y = Math.PI / 2;
          coin.rotation.z = 0;
          
          tube.isFlipping = false;
          console.log(`√¢≈ì‚Ä¶ Coin ${tubeIndex + 1} landed on ${result} facing camera`);
          
          showResult(tubeIndex, didWin, result);
        }
      };
      
      animateFlip();
    }

    function updateWinsDisplay(tubeIndex) {
      const player = players[tubeIndex];
      const tube = tubes[tubeIndex];
      
      if (!tube.cardElement) return;
      
      const winsDisplay = tube.cardElement.querySelector('.wins-display');
      const playerInfo = tube.cardElement.querySelector('.player-info');
      
      if (player.wins > 0) {
        // Show WIN text if player has wins
        if (!winsDisplay && playerInfo) {
          const winElement = document.createElement('div');
          winElement.className = 'wins-display';
          winElement.style.cssText = 'margin-top: 8px; justify-content: center; align-items: center;';
          winElement.textContent = 'WIN';
          playerInfo.appendChild(winElement);
        } else if (winsDisplay) {
          winsDisplay.textContent = 'WIN';
          winsDisplay.style.display = 'block';
        }
      } else {
        // Hide WIN text if player has no wins
        if (winsDisplay) {
          winsDisplay.style.display = 'none';
        }
      }
      
      console.log(`√∞≈∏¬è‚Ä† Updated wins display for player ${tubeIndex + 1}: ${player.wins} wins`);
    }


    function updatePlayerCardChoice(tubeIndex, choice) {
      const tube = tubes[tubeIndex];
      if (!tube.cardElement) return;
      
      const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
      const choiceBadge = tube.cardElement.querySelector('.choice-badge');
      
      if (choiceButtons && choiceBadge) {
        choiceButtons.style.display = 'none';
        choiceBadge.className = `choice-badge ${choice}`;
        choiceBadge.textContent = choice.toUpperCase();
        choiceBadge.style.display = 'block';
      }
      
      console.log(`√∞≈∏≈Ω¬Ø Updated player ${tubeIndex + 1} choice to: ${choice}`);
    }

    function showResult(tubeIndex, didWin, result) {
      const tube = tubes[tubeIndex];
      const coin = coins[tubeIndex];
      const player = players[tubeIndex];
      
      if (didWin) {
        const winLight = new THREE.PointLight(0x00ff00, 8, 200);
        winLight.position.set(0, 0, 0);
        coin.add(winLight);
        tube.winLight = winLight;
        
        coin.children.forEach(child => {
          if (child.isLight && child !== winLight) {
            child.color.setHex(0x00ff00);
            child.intensity = 6;
          }
        });
        
        console.log(`√∞≈∏≈Ω‚Ä∞ Player ${tubeIndex + 1} WON! Wins: ${player.wins}/3`);
        
        
        if (player.wins >= 3) {
          console.log(`√∞≈∏¬è‚Ä† Player ${tubeIndex + 1} reached 3 wins!`);
        }
      } else {
        const loseLight = new THREE.PointLight(0xff0000, 6, 200);
        loseLight.position.set(0, 0, 0);
        coin.add(loseLight);
        tube.loseLight = loseLight;
        
        
        console.log(`√¢¬ù≈í Player ${tubeIndex + 1} LOST this round`);
      }
      
      const resultBox = document.createElement('div');
      resultBox.style.cssText = `
        width: 300px;
        padding: 20px;
        background: ${didWin ? 'linear-gradient(135deg, #004d00, #003300)' : 'linear-gradient(135deg, #1a0000, #0d0000)'};
        border: 3px solid ${didWin ? '#00ff00' : '#ff0000'};
        border-radius: 16px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        box-shadow: 0 0 30px ${didWin ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 0, 0, 0.6)'};
        pointer-events: none;
      `;
      
      // ‚úÖ Build announcement message: "Heads you won" or "Tails you lost" etc.
      const resultMessage = didWin 
        ? `${result.charAt(0).toUpperCase() + result.slice(1)} you won!` 
        : `${result.charAt(0).toUpperCase() + result.slice(1)} you lost`;
      
      resultBox.innerHTML = `
        <div style="
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
          margin-bottom: 10px;
        ">
          <img src="/images/potion.png" style="width: 40px; height: 40px; object-fit: contain; ${didWin ? '' : 'filter: grayscale(100%) brightness(0.5);'}" />
          <div style="
            font-size: 30px;
            font-weight: bold;
            color: ${didWin ? '#00ff00' : '#ff0000'};
            text-transform: uppercase;
            letter-spacing: 2px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          ">
            ${didWin ? 'ROUND WON!' : 'YOU LOST'}
          </div>
        </div>
        <div style="
          font-size: 24px;
          color: #ffffff;
          text-transform: uppercase;
          letter-spacing: 2px;
          font-weight: bold;
          margin-bottom: 8px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          ${resultMessage}
        </div>
        <div style="
          font-size: 18px;
          color: #cccccc;
          text-transform: uppercase;
          letter-spacing: 1px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          Result: ${result.toUpperCase()}
        </div>
      `;
      
      const cssObject = new CSS3DObject(resultBox);
      cssObject.position.set(tube.tube.position.x, coin.position.y - 100, 0);
      cssObject.scale.set(0.5, 0.5, 0.5);
      scene.add(cssObject);
      
      tube.resultBox = cssObject;
      
      resultBox.style.opacity = '0';
      resultBox.style.transition = 'all 0.5s ease-out';
      
      setTimeout(() => {
        resultBox.style.opacity = '1';
        
      }, 50);
    }

    
    
    

    
    
    function showChoiceRequiredMessage(playerIndex) {
      const player = players[playerIndex];
      const tube = tubes[playerIndex];
      
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = `
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff1493, #ff69b4);
        border: 3px solid #ff1493;
        border-radius: 15px;
        padding: 20px 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
        z-index: 10000;
        animation: bounceIn 0.5s ease-out;
      `;
      
      messageDiv.innerHTML = `
        <div style="margin-bottom: 8px;">√¢≈°¬†√Ø¬∏¬è</div>
        <div>${player.name.toUpperCase()}</div>
        <div style="font-size: 14px; margin-top: 5px; opacity: 0.9;">
          Choose HEADS or TAILS first!
        </div>
      `;
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes bounceIn {
          0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.1); }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(messageDiv);
      
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.style.animation = 'bounceOut 0.3s ease-in forwards';
          setTimeout(() => {
            if (messageDiv.parentNode) {
              messageDiv.parentNode.removeChild(messageDiv);
            }
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
          }, 300);
        }
      }, 2000);
      
      if (!document.querySelector('#bounceOutStyle')) {
        const bounceOutStyle = document.createElement('style');
        bounceOutStyle.id = 'bounceOutStyle';
        bounceOutStyle.textContent = `
          @keyframes bounceOut {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
          }
        `;
        document.head.appendChild(bounceOutStyle);
      }
    }
    
    function showXPAwardNotification(amount, totalXP) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #00ff00;
        border-radius: 15px;
        padding: 20px 25px;
        color: #00ff00;
        font-family: 'Orbitron', sans-serif;
        font-weight: bold;
        font-size: 18px;
        z-index: 10001;
        box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
      `;
      
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <div style="font-size: 24px;">üí∞</div>
          <div>
            <div style="font-size: 20px; margin-bottom: 5px;">+${amount} FLIP</div>
            <div style="font-size: 14px; opacity: 0.8;">Total: ${totalXP}</div>
          </div>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 100);
      
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    function showGamePhaseIndicator(phase, message) {
      const existing = document.getElementById('game-phase-indicator');
      if (existing) {
        existing.remove();
      }
      
      const indicator = document.createElement('div');
      indicator.id = 'game-phase-indicator';
      indicator.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid ${phase === 'waiting' ? '#ffaa00' : phase === 'starting' ? '#00ff00' : phase === 'in_progress' ? '#0088ff' : '#ff0000'};
        border-radius: 15px;
        padding: 15px 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: #ffffff;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 0 30px ${phase === 'waiting' ? 'rgba(255, 170, 0, 0.5)' : phase === 'starting' ? 'rgba(0, 255, 0, 0.5)' : phase === 'in_progress' ? 'rgba(0, 136, 255, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
        z-index: 9998;
        animation: phaseIndicatorPulse 0.5s ease-out;
      `;
      
      const phaseIcon = phase === 'waiting' ? '√¢¬è¬≥' : phase === 'starting' ? '√∞≈∏≈Ω¬Æ' : phase === 'in_progress' ? '√¢≈°‚Äù√Ø¬∏¬è' : '√∞≈∏¬è¬Å';
      indicator.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 24px;">${phaseIcon}</span>
          <span>${message}</span>
        </div>
      `;
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes phaseIndicatorPulse {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(indicator);
    }

    function showGameStartNotification() {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #00ff00, #39ff14);
        border: 3px solid #00ff00;
        border-radius: 20px;
        padding: 40px 60px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: #000;
        font-size: 32px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 3px;
        box-shadow: 0 0 60px rgba(0, 255, 0, 0.8);
        z-index: 10001;
        animation: gameStartPulse 0.5s ease-out;
      `;
      
      notification.innerHTML = `
        <div style="margin-bottom: 10px;">üéÆ</div>
        <div>GAME STARTED!</div>
        <div style="font-size: 18px; margin-top: 10px;">Round 1 Beginning</div>
      `;
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes gameStartPulse {
            0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'gameStartPulse 0.5s ease-out reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 500);
      }, 3000);
    }

    function showGameOverScreen(winnerIndex, winnerName) {
      console.log('√∞≈∏¬è¬Å GAME OVER - Showing end screen');
      
      if (gameOver) {
        console.log('√¢≈°¬†√Ø¬∏¬è Game over screen already shown, ignoring duplicate call');
        return;
      }
      
      gameOver = true;
      
      showGamePhaseIndicator('ended', 'Game Over - Claim your rewards!');
      
      const didCurrentPlayerWin = (playerSlot === winnerIndex);
      
      console.log(`√∞≈∏¬è¬Å Game Over Debug:`, {
        playerSlot,
        winnerIndex,
        didCurrentPlayerWin,
        winnerName
      });
      
      if (isServerSideMode && socket && gameIdParam && walletParam && !window.flipTokensAwarded) {
        const gameResult = didCurrentPlayerWin ? 'won' : 'lost';
        
        const currentPlayerLives = players[playerSlot]?.lives || 0;
        
        window.flipTokensAwarded = true;
        
        socket.emit('award_flip_tokens_final', {
          gameId: gameIdParam,
          address: walletParam,
          gameResult: gameResult,
          finalLives: currentPlayerLives,
          totalFlip: currentPlayerXP
        });
        
        console.log(`√∞≈∏≈Ω¬Å Awarding FLIP tokens directly: ${gameResult}, ${currentPlayerXP} FLIP`);
      }
      
      const gameOverDiv = document.createElement('div');
      gameOverDiv.id = 'game-over-overlay';
      gameOverDiv.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        pointer-events: auto;
        opacity: 1;
        font-family: 'Orbitron', sans-serif;
      `;
      
      const contentDiv = document.createElement('div');
      contentDiv.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 4px solid ${didCurrentPlayerWin ? '#FFD700' : '#ff0000'};
        border-radius: 25px;
        padding: 50px;
        text-align: center;
        box-shadow: 0 0 50px ${didCurrentPlayerWin ? 'rgba(255, 215, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
        max-width: 600px;
        width: 90%;
      `;
      
      if (didCurrentPlayerWin) {
        contentDiv.innerHTML = `
            <div style="font-size: 80px; margin-bottom: 20px;">√∞≈∏¬è‚Ä†</div>
            <div style="font-size: 48px; font-weight: bold; color: #FFD700; margin-bottom: 20px;">
                VICTORY!
            </div>
            <div style="font-size: 24px; color: #ffffff; margin-bottom: 30px;">
                You earned ${currentPlayerXP} FLIP tokens!
            </div>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 30px;">
                <button id="claim-nft-btn" style="
                    background: linear-gradient(135deg, #ff0088, #ff1493);
                    border: none;
                    border-radius: 15px;
                    padding: 15px 30px;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 18px;
                    font-weight: bold;
                    color: #fff;
                    cursor: pointer;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                ">
                    üé® Claim NFT Prize
                </button>
            </div>
        `;
      } else {
        contentDiv.innerHTML = `
            <div style="font-size: 60px; margin-bottom: 20px;">üí∞</div>
            <div style="font-size: 36px; font-weight: bold; color: #ff0000; margin-bottom: 20px;">
                DEFEATED
            </div>
            <div style="font-size: 24px; color: #ffffff; margin-bottom: 20px;">
                Winner: ${winnerName || 'Unknown'}
            </div>
            <div style="font-size: 20px; color: #00ff00; margin-bottom: 30px;">
                You earned ${currentPlayerXP} FLIP tokens!
            </div>
        `;
      }
      
      contentDiv.innerHTML += `
        <button id="return-lobby-btn" style="
            background: linear-gradient(135deg, #666, #888);
            border: none;
            border-radius: 15px;
            padding: 12px 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 20px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        ">
            Return Home
        </button>
      `;
      
      gameOverDiv.appendChild(contentDiv);
      document.body.appendChild(gameOverDiv);

      try {
        document.body.style.overflow = 'hidden';
      } catch (e) {}

      try {
        debugOverlayVisibility('game-over-overlay');
      } catch (e) {
        console.warn('√¢≈°¬†√Ø¬∏¬è Overlay debug failed:', e?.message);
      }
      
      setTimeout(() => {
        const claimNftBtn = document.getElementById('claim-nft-btn');
        const returnLobbyBtn = document.getElementById('return-lobby-btn');
        
        if (claimNftBtn && didCurrentPlayerWin) {
            claimNftBtn.addEventListener('click', () => {
                if (!gameIdParam || !walletParam) {
                    console.error('Cannot claim NFT: missing gameId or walletParam');
                    alert('Missing game information. Redirecting to profile...');
                    window.location.href = `/profile?address=${walletParam || ''}`;
                    return;
                }
                
                console.log('üé® Redirecting to profile to claim NFT...', { gameId: gameIdParam, winner: walletParam });
                
                // Just redirect to profile where they can complete the claim process
                window.location.href = `/profile?address=${walletParam}&claimGame=${gameIdParam}`;
            });
        }
        
        if (returnLobbyBtn) {
            returnLobbyBtn.addEventListener('click', () => {
                window.location.href = '/';
            });
        }
      }, 100);
    }

    function debugOverlayVisibility(elementId) {
      const el = document.getElementById(elementId);
      if (!el) {
        console.warn(`√∞≈∏‚Äù≈Ω Overlay '${elementId}' not found in DOM`);
        return;
      }
      const cs = window.getComputedStyle(el);
      console.log('√∞≈∏‚Äù≈Ω Overlay computed styles:', {
        display: cs.display,
        visibility: cs.visibility,
        opacity: cs.opacity,
        position: cs.position,
        zIndex: cs.zIndex,
        pointerEvents: cs.pointerEvents
      });

      const all = Array.from(document.body.querySelectorAll('*'));
      const candidates = all
        .filter(n => {
          const s = window.getComputedStyle(n);
          return (s.position === 'fixed' || s.position === 'sticky' || s.position === 'absolute') && Number(s.zIndex) > 0;
        })
        .map(n => ({
          node: n,
          tag: n.tagName,
          id: n.id,
          class: n.className,
          z: Number(window.getComputedStyle(n).zIndex) || 0
        }))
        .sort((a, b) => b.z - a.z)
        .slice(0, 5);
      console.log('√∞≈∏‚Äù≈Ω Top stacking candidates (highest z-index):', candidates);
    }



    console.log('√¢≈ì‚Ä¶ Game loaded! Hold CHARGE POWER button to fill tubes!');
    console.log('üéÆ Server-authoritative game ready - all game logic managed by server');
    
    function updatePlayerCards() {
      console.log('√∞≈∏‚Äù‚Äû Updating player cards with real data...');
      tubes.forEach((tube, index) => {
        const player = players[index];
        console.log(`√∞≈∏‚Äù¬ç Tube ${index + 1}:`, { hasCardElement: !!tube.cardElement, player: player?.name });
        if (!tube.cardElement || !player) return;
        
        createMobilePlayerCards();
        
        const showButtons = !player.isEmpty;
        
        console.log(`√∞≈∏≈Ω¬Ø Player ${index + 1} button logic (DEBUGGING MODE):`, {
          playerAddress: player.address,
          isEmpty: player.isEmpty,
          showButtons: showButtons
        });
        
        const playerNameElement = tube.cardElement.querySelector('.player-name');
        const playerAddressElement = tube.cardElement.querySelector('.player-address');
        const playerAvatarElement = tube.cardElement.querySelector('.player-avatar');
        
        console.log(`√∞≈∏‚Äú¬ù Updating player ${index + 1}:`, { name: player.name, address: player.address, isEmpty: player.isEmpty });
        
        if (playerNameElement) playerNameElement.textContent = player.name;
        if (playerAddressElement) {
          const shortAddress = player.address ? `${player.address.slice(0, 6)}...${player.address.slice(-4)}` : '';
          playerAddressElement.textContent = shortAddress;
        }
        if (playerAvatarElement) {
          playerAvatarElement.src = player.avatar || '/images/default-avatar.png';
          playerAvatarElement.alt = player.name;
        }
        
        const winsDisplay = tube.cardElement.querySelector('.wins-display');
        if (player.wins > 0) {
          if (!winsDisplay) {
            const playerInfo = tube.cardElement.querySelector('.player-info');
            if (playerInfo) {
              const winElement = document.createElement('div');
              winElement.className = 'wins-display';
              winElement.style.cssText = 'margin-top: 8px; justify-content: center; align-items: center;';
              winElement.textContent = 'WIN';
              playerInfo.appendChild(winElement);
            }
          } else {
            winsDisplay.textContent = 'WIN';
            winsDisplay.style.display = 'block';
          }
        } else {
          if (winsDisplay) {
            winsDisplay.style.display = 'none';
          }
        }
        
        const existingOverlay = tube.cardElement.querySelector('.empty-slot-overlay');
        console.log(`√∞≈∏≈Ω¬Ø Player ${index + 1} empty slot logic:`, { 
          isEmpty: player.isEmpty, 
          hasExistingOverlay: !!existingOverlay,
          playerName: player.name,
          playerAddress: player.address 
        });
        
        if (existingOverlay) {
          console.log(`√∞≈∏¬ß¬π Removing existing overlay from player slot ${index + 1}`);
          existingOverlay.remove();
        }
        
        if (player.isEmpty) {
          console.log(`√¢≈æ‚Ä¢ Adding pink X overlay to empty slot ${index + 1}`);
          const overlay = document.createElement('div');
          overlay.className = 'empty-slot-overlay';
          overlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 50, 0.9);
            border-radius: 16px;
            z-index: 10;
          `;
          overlay.textContent = '';
          tube.cardElement.appendChild(overlay);
        }
        
        const actionButtons = tube.cardElement.querySelectorAll('.action-btn');
        const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
        
        if (showButtons) {
          actionButtons.forEach(btn => btn.style.display = 'block');
          if (choiceButtons) choiceButtons.style.display = 'flex';
        } else {
          actionButtons.forEach(btn => btn.style.display = 'none');
          if (choiceButtons) choiceButtons.style.display = 'none';
        }
      });
      
      updateCoinRotationsFromPlayerChoices();
    }

    async function loadParticipants() {
      try {
        if (!gameIdParam) return;
        const res = await fetch(`/api/battle-royale/${encodeURIComponent(gameIdParam)}`);
        if (!res.ok) throw new Error('Failed to load participants');
        const data = await res.json();
        const parts = (data?.game?.participants || []).slice().sort((a,b) => (a.slot_number||0)-(b.slot_number||0));
        console.log('√∞≈∏‚Äù¬ç Raw participants data:', parts);
        
        players = [1,2,3,4].map((slot, idx) => {
          const p = parts[idx];
          if (!p) {
            console.log(`√∞≈∏‚Äú¬≠ Slot ${idx+1}: Empty`);
            return { id: idx+1, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true };
          }
          
          const playerData = {
            id: idx+1,
            name: p.username || p.name || `Player ${idx+1}`,
            wins: 0,
            address: p.player_address || '',
            choice: null,
            avatar: p.avatar || '/images/default-avatar.png',
            isEmpty: false
          };
          
          console.log(`√∞≈∏‚Äò¬§ Slot ${idx+1}:`, {
            raw: p,
            processed: playerData
          });
          
          return playerData;
        });
        roundStartWins = players.map(player => player.wins);
        console.log('√∞≈∏‚Äú≈† Participants mapped:', players);
        
        updatePlayerCards();
        
        createMobilePlayerCards();
        
        
        
        if (!gameOver) {
          showGameStartNotification();
        }
      } catch (err) {
        console.warn('Participants load failed:', err);
      }
    }
    await loadParticipants();

    (async () => {
      try {
        if (!gameIdParam) return;
        if (roleParam === 'spectator') {
          console.log('√∞≈∏‚Äò‚Ç¨ Spectator mode - skipping join');
          return;
        }
        if (!walletParam) {
          console.warn('√¢≈°¬†√Ø¬∏¬è No wallet address provided; cannot join game');
          return;
        }
        const res = await fetch(`/api/battle-royale/${encodeURIComponent(gameIdParam)}/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...(tokenParam ? { Authorization: `Bearer ${tokenParam}` } : {}) },
          body: JSON.stringify({ player_address: walletParam })
        });
        const data = await res.json().catch(() => ({}));
        if (res.ok) {
          console.log('√¢≈ì‚Ä¶ Joined game on server:', data);
        } else {
          console.warn('√¢≈°¬†√Ø¬∏¬è Join failed:', data?.error || res.statusText);
        }
      } catch (err) {
        console.error('√¢¬ù≈í Join error:', err);
      }
    })();
    
    setTimeout(() => {
      if (typeof updatePlayerCardButtons === 'function') {
        updatePlayerCardButtons();
      }
      
      if (typeof updateCoinRotationsFromPlayerChoices === 'function') {
        updateCoinRotationsFromPlayerChoices();
      }
    }, 1000); // 1 second delay
    
    
    function isMobile() {
      return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    function triggerHaptic() {
      if (navigator.vibrate) {
        navigator.vibrate(30);
      }
    }

    function initializeMobileUI() {
      if (!isMobile()) return;
      
      console.log('√∞≈∏‚Äú¬± Initializing clean mobile UI');
      
      setupMobileControls();
      
      createMobilePlayerCards();
      
      updateMobileDisplays();
    }

    function setupMobileControls() {
      const changeCoinBtn = document.getElementById('mobile-change-coin');
      if (changeCoinBtn) {
        changeCoinBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          console.log('Change coin clicked');
          if (typeof showCoinSelector === 'function') {
            showCoinSelector(playerSlot);
          }
        });
      }
      
      const chatBtn = document.getElementById('mobile-chat');
      if (chatBtn) {
        chatBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          console.log('Chat clicked');
          const desktopBtn = document.getElementById('chat-btn');
          if (desktopBtn) desktopBtn.click();
        });
      }
      
      const fullscreenBtn = document.getElementById('mobile-fullscreen');
      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          
          console.log('√∞≈∏‚Äù¬¥ FULLSCREEN BUTTON CLICKED - FORCING BACKGROUND UPDATE');
          console.log('Current dimensions:', window.innerWidth, 'x', window.innerHeight);
          console.log('Is Landscape?', window.innerWidth > window.innerHeight);
          
          document.body.style.background = 'none';
          document.body.style.backgroundImage = 'none';
          void document.body.offsetHeight;
          
          document.body.style.backgroundImage = "url('/Images/Background/game room2.png')";
          document.body.style.backgroundSize = window.innerWidth + 'px ' + window.innerHeight + 'px';
          document.body.style.backgroundPosition = 'center center';
          document.body.style.backgroundRepeat = 'no-repeat';
          document.body.style.backgroundAttachment = 'scroll';
          
          console.log('√¢≈ì‚Ä¶ Background applied with dimensions:', document.body.style.backgroundSize);
          
          if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
          }
        });
      }
      
      const headsBtn = document.getElementById('mobile-heads');
      if (headsBtn) {
        headsBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (currentPlayer && !currentPlayer.choice) {
            currentPlayer.choice = 'heads';
            updatePlayerChoice(currentPlayer);
            
            headsBtn.classList.add('selected');
            tailsBtn.classList.remove('selected');
          }
        });
      }

      const tailsBtn = document.getElementById('mobile-tails');
      if (tailsBtn) {
        tailsBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (currentPlayer && !currentPlayer.choice) {
            currentPlayer.choice = 'tails';
            updatePlayerChoice(currentPlayer);
            
            tailsBtn.classList.add('selected');
            headsBtn.classList.remove('selected');
          }
        });
      }

      const powerBtn = document.getElementById('mobile-power');
      if (powerBtn) {
        let powerInterval = null;
        let isCharging = false;
        
        const startCharging = () => {
          if (isCharging) return;
          
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (!currentPlayer) {
            console.log('√¢¬ù≈í No current player found for mobile power');
            return;
          }
          
          const playerSlot = players.findIndex(p => p.address === currentPlayer.address);
          if (playerSlot === -1) {
            console.log('√¢¬ù≈í Current player slot not found');
            return;
          }
          
          triggerHaptic();
          isCharging = true;
          
          if (tubes[playerSlot]) {
            tubes[playerSlot].isFilling = true;
            tubes[playerSlot].power = 0;
            tubes[playerSlot].chargingStartTime = Date.now();
          }
          
          powerInterval = setInterval(() => {
            if (tubes[playerSlot] && tubes[playerSlot].isFilling) {
              const elapsed = Date.now() - tubes[playerSlot].chargingStartTime;
              const powerPercent = Math.min(100, (elapsed / 2000) * 100); // 2 second max charge
              
              tubes[playerSlot].power = powerPercent;
              tubes[playerSlot].powerLevel = Math.min(5, Math.max(1, Math.ceil(powerPercent / 20)));
              tubes[playerSlot].foamIntensity = powerPercent / 100;
              
              const powerFill = document.getElementById('mobile-power-fill');
              const powerValue = document.querySelector('#mobile-power-text .power-value');
              if (powerFill && powerValue) {
                powerFill.style.width = `${powerPercent}%`;
                powerValue.textContent = Math.round(powerPercent);
              }
              
              if (isServerSideMode && socket && gameIdParam && walletParam) {
                socket.emit('physics_power_charging', {
                  gameId: gameIdParam,
                  address: walletParam,
                  power: powerPercent,
                  powerLevel: tubes[playerSlot].powerLevel,
                  playerSlot: playerSlot,
                  isFilling: true
                });
              }
            }
          }, 50);
        };
        
        const stopCharging = () => {
          if (!isCharging) return;
          
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (!currentPlayer) {
            console.log('√¢¬ù≈í No current player found for mobile power stop');
            return;
          }
          
          const playerSlot = players.findIndex(p => p.address === currentPlayer.address);
          if (playerSlot === -1) {
            console.log('√¢¬ù≈í Current player slot not found for stop');
            return;
          }
          
          triggerHaptic();
          isCharging = false;
          
          if (powerInterval) {
            clearInterval(powerInterval);
            powerInterval = null;
          }
          
          if (tubes[playerSlot]) {
            const finalPower = tubes[playerSlot].power;
            tubes[playerSlot].isFilling = false;
            
            console.log(`√¢≈°¬° Mobile power released at ${finalPower.toFixed(0)}%`);
            
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              socket.emit('physics_power_charging_stop', {
                gameId: gameIdParam,
                address: walletParam,
                playerSlot: playerSlot,
                finalPower: finalPower
              });
            }
            
            if (finalPower > 10) { // Minimum 10% power to spin
              if (isServerSideMode && socket && gameIdParam && walletParam) {
                socket.emit('physics_coin_flip', {
                  gameId: gameIdParam,
                  address: walletParam,
                  power: finalPower,
                  playerSlot: playerSlot
                });
              }
            }
          }
        };
        
        powerBtn.addEventListener('touchstart', startCharging);
        powerBtn.addEventListener('touchend', stopCharging);
        powerBtn.addEventListener('mousedown', startCharging);
        powerBtn.addEventListener('mouseup', stopCharging);
      }

      const coinBtn = document.getElementById('mobile-change-coin');
      if (coinBtn) {
        coinBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          const globalBtn = document.getElementById('global-change-coin-btn');
          if (globalBtn) globalBtn.click();
        });
      }

    }

    function createMobilePlayerCards() {
      const container = document.getElementById('mobile-player-cards');
      if (!container) {
        console.log('√¢¬ù≈í Mobile player cards container not found');
        return;
      }

      console.log('√∞≈∏‚Äù‚Äû Creating mobile player cards...', { tubes: tubes.length, players: players.length });
      container.innerHTML = '';
      
      for (let i = 0; i < 4; i++) {
        const player = players[i];
        console.log(`√∞≈∏‚Äù¬ç Player ${i + 1}:`, { player: player?.name, isEmpty: player?.isEmpty });
        
        const box = document.createElement('div');
        box.className = 'player-box';
        
        if (player && !player.isEmpty) {
          box.innerHTML = `
            <img src="${player.avatar || '/images/default-avatar.png'}" class="player-avatar" alt="${player.name}" />
            <div class="player-info">
              <div class="player-name">${player.name}</div>
              ${player.wins > 0 ? '<div class="player-wins">WIN</div>' : ''}
            </div>
          `;
          console.log(`‚úÖ Created mobile box for ${player.name}`);
        } else {
          box.innerHTML = `
            <div class="player-info">
              <div class="player-name">Empty</div>
              ${''}
            </div>
          `;
          console.log(`√¢¬è¬≠√Ø¬∏¬è Created empty box for slot ${i + 1}`);
        }
        
        container.appendChild(box);
      }
      
      console.log(`√∞≈∏‚Äú¬± Mobile player boxes created: ${container.children.length} boxes`);
    }

    function updateMobileDisplays() {

      const earnings = document.getElementById('mobile-earnings');
      if (earnings) {
        earnings.textContent = `${currentPlayerXP} FLIP`;
      }

      const powerFill = document.getElementById('mobile-power-fill');
      const powerValue = document.querySelector('#mobile-power-text .power-value');
      if (powerFill && powerValue) {
        let totalPower = 0;
        let playerCount = 0;
        
        tubes.forEach(tube => {
          if (tube.power !== undefined) {
            totalPower += tube.power;
            playerCount++;
          }
        });

        const averagePower = playerCount > 0 ? totalPower / playerCount : 0;
        const powerPercentage = Math.min(100, Math.max(0, averagePower));

        powerFill.style.width = `${powerPercentage}%`;
        powerValue.textContent = powerPercentage.toFixed(0);
      }
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }
    }

    setTimeout(initializeMobileUI, 1000);

    
    function optimizeForMobile() {
      if (!isMobile()) return;
      
      console.log('√∞≈∏‚Äú¬± Applying mobile performance optimizations');
      
      webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio for performance
      webglRenderer.antialias = false; // Disable antialiasing for performance
      webglRenderer.shadowMap.enabled = false; // Disable shadows for performance
      
      tubes.forEach(tube => {
        if (tube.liquidParticleMeshes) {
          const maxParticles = 30; // Reduced for mobile
          tube.liquidParticleMeshes.slice(maxParticles).forEach(mesh => {
            mesh.visible = false;
          });
        }
      });
      
      if (ambientLight) ambientLight.intensity = 0.4;
      if (directionalLight) {
        directionalLight.intensity = 0.6;
        directionalLight.castShadow = false;
      }
      
      console.log('√¢≈ì‚Ä¶ Mobile performance optimizations applied');
    }

    setTimeout(optimizeForMobile, 2000);
    

    let frameCount = 0;
    const timeStep = 1 / 60; // 60 FPS
    
    function animate() {
      frameCount++;

      physicsWorld.step(timeStep);

      tubes.forEach((tube, i) => {
        const offset = i * 0.4;
        
        if (tube.isFilling && !tube.isShattered) {
          tube.power = Math.min(tube.power + 0.6, 100);
          const powerPercent = tube.power / 100;
          
          tube.foamIntensity = powerPercent;
          
          const powerLevel = Math.min(5, Math.max(1, Math.ceil(tube.power / 20)));
          
          if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === i) {
            if (frameCount % 5 === 0) { // Changed from every frame to every 5 frames
              socket.emit('physics_power_charging', {
                gameId: gameIdParam,
                address: walletParam,
                power: tube.power,
                powerLevel: powerLevel,
                playerSlot: i,
                isFilling: tube.isFilling
              });
            }
          }
          
          if (tube.cardElement) {
            const powerFill = tube.cardElement.querySelector('.power-fill');
            const powerValue = tube.cardElement.querySelector('.power-value');
            if (powerFill) powerFill.style.width = `${tube.power}%`;
            if (powerValue) powerValue.textContent = tube.power.toFixed(0);
          }
          
          updatePearlColors(tube, powerPercent, i);
        }
        
        if ((tube.isFilling || tube.foamIntensity > 0) && !tube.isShattered) {
          updatePearlPhysics(tube, tube.foamIntensity, i, frameCount);
        }
        
        tube.liquidParticles.forEach((particleBody, idx) => {
          tube.liquidParticleMeshes[idx].position.copy(particleBody.position);
          tube.liquidParticleMeshes[idx].quaternion.copy(particleBody.quaternion);
        });
        
        if (tube.foamIntensity > 0) {
          const lightPulse = Math.sin(frameCount * 0.15 + offset) * 0.5;
          tube.liquidLight.intensity = tube.liquidLight.intensity + lightPulse * tube.foamIntensity;
        }
      });

      coins.forEach((coin, i) => {
        const tube = tubes[i];
        
        coin.visible = true;
        
        // Check animation state instead of multiple boolean flags
        const isAnimating = tube.animationState !== 'idle';
        const animationAge = Date.now() - tube.animationStartTime;
        
        if (isAnimating) {
          // During any animation, let the animation handler control position
          // Don't interfere with position/rotation during animations
          if (tube.animationState === 'flipping' && !tube.isFilling) {
            // Flipping animation handles position
            const tubeX = tube.tube.position.x;
            coin.position.x = tubeX;
            coin.position.y = 200;
            coin.position.z = 0;
          }
          // Landing animation handles everything
          // Shattered state handles everything
        } else if (tube.isFilling && !tube.isShattered) {
          // Power charging vibration
          const vibIntensity = (tube.power / 100) * 8;
          const vibSpeed = (tube.power / 100) * 20;
          
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX + Math.sin(frameCount * vibSpeed) * vibIntensity;
          coin.position.y = 200 + Math.cos(frameCount * vibSpeed * 1.3) * vibIntensity;
          coin.position.z = Math.sin(frameCount * vibSpeed * 0.7) * vibIntensity * 0.5;
          
          coin.rotation.z = Math.sin(frameCount * vibSpeed * 0.5) * (vibIntensity / 50);
        } else {
          // Truly idle - maintain stable position
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX;
          coin.position.y = 200;
          coin.position.z = 0;
          
          // Gently return to stable rotation if needed
          if (tube.lastStableRotation) {
            coin.rotation.x += (tube.lastStableRotation.x - coin.rotation.x) * 0.05;
            coin.rotation.y += (tube.lastStableRotation.y - coin.rotation.y) * 0.05;
            coin.rotation.z += (tube.lastStableRotation.z - coin.rotation.z) * 0.05;
          }
        }
      });
      
      tubes.forEach((tube, i) => {
        if (tube.glassShards.length > 0) {
          tube.glassShards.forEach(shard => {
            shard.lifetime += 0.016;
            
            shard.mesh.position.x += shard.velocity.x;
            shard.mesh.position.y += shard.velocity.y;
            shard.mesh.position.z += shard.velocity.z;
            
            shard.velocity.y -= 0.3;
            
            shard.mesh.rotation.x += shard.rotVelocity.x;
            shard.mesh.rotation.y += shard.rotVelocity.y;
            shard.mesh.rotation.z += shard.rotVelocity.z;
            
            shard.mesh.material.opacity = Math.max(0, 0.6 - (shard.lifetime / 2) * 0.6);
            
            if (shard.lifetime > 2) {
              shard.mesh.visible = false;
            }
          });
        }
      });

      
      const originalMask = camera.layers.mask; // Save original layer mask
      camera.layers.disableAll(); // Clear all layers
      camera.layers.enable(0); // Only enable layer 0
      
      if (frameCount === 1) {
        console.log('üé¨ Frame 1 - Layer 0 mask:', camera.layers.mask, 'Should be 1 for layer 0');
      }
      
      webglRenderer.autoClear = true;
      webglRenderer.clear(true, true, true); // Clear color, depth, stencil
      webglRenderer.render(scene, camera);
      
      if (frameCount === 1) {
        console.log('‚úÖ Main scene (layer 0) rendered to screen');
      }
      
      camera.layers.disableAll();
      camera.layers.enable(1); // Only enable layer 1 (pearls + plasma)
      
      if (frameCount === 1) {
        console.log('üé¨ Frame 1 - Layer 1 mask:', camera.layers.mask, 'Should be 2 for layer 1');
      }
      
      bloomComposer.render();
      
      if (frameCount === 1) {
        console.log('‚úÖ Pearls (layer 1) rendered to bloom buffer');
        console.log('üîç Bloom composer render target:', bloomComposer.renderTarget1 ? 'Found' : 'Missing');
        console.log('üîç Bloom composer read buffer:', bloomComposer.readBuffer ? 'Found' : 'Missing');
      }
      
      webglRenderer.autoClear = false; // Don't clear - we want to blend on top!
      
      const bloomTexture = bloomComposer.readBuffer.texture;
      
      if (frameCount === 1) {
        console.log('üé® Bloom texture:', bloomTexture ? 'Found' : 'Missing');
        if (bloomTexture) {
          console.log('üé® Bloom texture details:', {
            width: bloomTexture.image?.width,
            height: bloomTexture.image?.height,
            format: bloomTexture.format,
            type: bloomTexture.type
          });
        }
      }
      
      if (frameCount === 1) {
        let visiblePearls = 0;
        tubes.forEach((tube, i) => {
          if (tube.liquidParticleMeshes) {
            const tubeVisiblePearls = tube.liquidParticleMeshes.filter(mesh => mesh.visible).length;
            visiblePearls += tubeVisiblePearls;
            console.log(`üîç Tube ${i + 1} has ${tubeVisiblePearls} visible pearls on layer 1`);
          }
        });
        console.log(`üîç Total visible pearls on layer 1: ${visiblePearls}`);
      }
      
      if (!window.bloomQuadMesh) {
        const quadGeometry = new THREE.PlaneGeometry(2, 2);
        const quadMaterial = new THREE.MeshBasicMaterial({
          map: bloomTexture,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          depthWrite: false,
          toneMapped: false // Preserve bloom colors!
        });
        const quadMesh = new THREE.Mesh(quadGeometry, quadMaterial);
        
        const quadScene = new THREE.Scene();
        quadScene.add(quadMesh);
        
        const quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        window.bloomQuadMesh = quadMesh;
        window.bloomQuadScene = quadScene;
        window.bloomQuadCamera = quadCamera;
        
        console.log('‚ú® Bloom composite quad created!');
      }
      
      if (window.bloomQuadMesh && bloomTexture) {
        window.bloomQuadMesh.material.map = bloomTexture;
        window.bloomQuadMesh.material.needsUpdate = true;
        
        if (bloomTexture.needsUpdate !== undefined) {
          bloomTexture.needsUpdate = true;
        }
      }
      
      if (window.bloomQuadScene && window.bloomQuadCamera && bloomTexture) {
        webglRenderer.render(window.bloomQuadScene, window.bloomQuadCamera);
      } else {
        console.log('‚ö†Ô∏è Bloom rendering failed, using fallback direct rendering');
        camera.layers.disableAll();
        camera.layers.enable(1); // Enable layer 1
        webglRenderer.render(scene, camera);
        camera.layers.mask = originalMask; // Restore original mask
      }
      
      if (frameCount === 1) {
        console.log('‚úÖ Bloomed pearls composited on top');
        console.log('üéâ Selective bloom rendering complete!');
      }
      
      webglRenderer.autoClear = true;
      camera.layers.mask = originalMask; // Restore original layer mask
      
      cssRenderer.render(scene, camera);

      requestAnimationFrame(animate);
    }

    animate();

    window.addEventListener('resize', () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;

      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();

      webglRenderer.setSize(newWidth, newHeight);
      cssRenderer.setSize(newWidth, newHeight);
      bloomComposer.setSize(newWidth, newHeight);

      if (isMobile()) {
        setTimeout(() => {
          document.querySelectorAll('.mobile-player-card').forEach(card => card.remove());
          createMobilePlayerCards();
        }, 100);
      }

      console.log(`√∞≈∏‚Äú¬ê Resized to ${newWidth}x${newHeight}`);
    });

    window.addEventListener('orientationchange', function() {
      const body = document.body;
      const originalDisplay = body.style.display;
      
      body.style.display = 'none';
      body.offsetHeight; // Force browser to acknowledge the change
      body.style.display = originalDisplay || '';
      
      body.classList.add('orientation-changing');
      setTimeout(() => {
        body.classList.remove('orientation-changing');
      }, 50);
      
      console.log('üì± Orientation changed - background refreshed');
    });

    let resizeTimer;
    if (isMobile()) {
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          const aspectRatio = window.innerWidth / window.innerHeight;
          if ((aspectRatio > 1 && window.lastAspectRatio < 1) || 
              (aspectRatio < 1 && window.lastAspectRatio > 1)) {
            document.body.style.backgroundImage = document.body.style.backgroundImage || 
              "url('/Images/Background/game room2.png')";
            console.log('üì± Rotation detected via resize - background refreshed');
          }
          window.lastAspectRatio = aspectRatio;
        }, 100);
      });
      window.lastAspectRatio = window.innerWidth / window.innerHeight;
    }
  </script>
</body>
</html>

