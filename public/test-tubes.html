<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, orientation=landscape">
  <title>Glass Tube Game Test</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }
    
    body {
      font-family: 'Orbitron', sans-serif;
      background: url('/Images/Background/game room2.png') no-repeat center center;
      background-size: cover;
      background-attachment: fixed;
      background-position: center center;
      min-height: 100vh;
      width: 100%;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }

    /* ===== RESPONSIVE MOBILE-FIRST DESIGN ===== */
    
    /* Mobile UI - Hidden by default */
    .mobile-ui {
      display: none;
    }
    
    /* Mobile Detection */
    @media (max-width: 768px) {
      /* Show mobile UI */
      .mobile-ui {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
        pointer-events: none;
      }
      
      /* Mobile body base styles */
      body {
        overflow: hidden;
        -webkit-overflow-scrolling: touch;
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      
      /* Hide scrollbars */
      body::-webkit-scrollbar {
        display: none;
      }
      
      /* Portrait Orientation - No background needed, warning covers it */
      @media (orientation: portrait) {
        body {
          background: #0a0f23 !important; /* Simple solid color */
          background-image: none !important; /* Remove image completely */
        }
      }
      
      /* Landscape Orientation - Stretch background to fit */
      @media (orientation: landscape) {
        body {
          background: url('/Images/Background/game room2.png') no-repeat center center !important;
          background-size: 100% 100% !important; /* Stretch to fill screen */
          background-attachment: scroll !important;
        }
      }
      
      /* Override room-specific backgrounds on mobile */
      
      /* Portrait - disable all room backgrounds */
      @media (orientation: portrait) {
        body.lab-room,
        body.cyber-room,
        body.mech-room,
        body {
          background: #0a0f23 !important;
          background-image: none !important;
          background-attachment: scroll !important;
        }
      }
      
      /* Landscape - stretch room backgrounds to fit */
      @media (orientation: landscape) {
        body.lab-room {
          background: url('/images/background/thelab.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
        
        body.cyber-room {
          background: url('/images/background/cyber.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
        
        body.mech-room {
          background: url('/images/background/mech.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
        
        /* Default room (game room2.png) */
        body:not(.lab-room):not(.cyber-room):not(.mech-room) {
          background: url('/Images/Background/game room2.png') no-repeat center center !important;
          background-size: 100% 100% !important;
          background-attachment: scroll !important;
        }
      }
      
      /* Hide desktop elements on mobile */
      .player-card,
      #xp-counter,
      #change-coin-box,
      #leave-btn {
        display: none !important;
      }
      
      /* Show game-info on mobile but position it at top center - smaller and compact */
      .game-info {
        position: fixed !important;
        top: 10px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 10001 !important;
        width: 160px !important;
        text-align: center !important;
        height: auto !important;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95)) !important;
        border: 2px solid #9d00ff !important;
        border-radius: 12px !important;
        padding: 8px 12px !important;
        font-family: 'Orbitron', sans-serif !important;
        color: white !important;
        box-shadow: 0 0 20px rgba(157, 0, 255, 0.6) !important;
        pointer-events: auto !important;
        text-align: center !important;
        display: block !important;
      }
      
      /* Hide mute and chat buttons on mobile */
      .game-info button {
        display: none !important;
      }
      
      /* Hide desktop layout on mobile */
      .game-info .desktop-timer-layout {
        display: none !important;
      }
      
      /* Show mobile layout on mobile */
      .game-info .mobile-timer-round {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        gap: 8px !important;
        font-size: 14px !important;
        font-weight: bold !important;
        color: #00ffff !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      .game-info .mobile-timer-round .round-text {
        color: #00ffff !important;
        font-size: 14px !important;
      }
      
      .game-info .mobile-timer-round .timer-text {
        color: #00ff00 !important;
        font-size: 14px !important;
      }
      
      /* Floating UI Elements - Lobby Style */
      .floating-btn.change-coin-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10001;
      }
      
      .floating-btn.chat-btn {
        position: fixed;
        bottom: 100px;
        right: 15px;
        z-index: 10001;
        width: 25px;
        height: 25px;
        font-size: 8px;
      }
      
      .floating-earnings {
        position: fixed;
        top: 15px;
        right: 70px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        color: #00ffff;
        font-size: 12px;
        font-weight: bold;
        padding: 6px 12px;
        border-radius: 15px;
        border: 2px solid #00ffff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        text-align: center;
        min-width: 80px;
        z-index: 10001;
        pointer-events: auto;
        backdrop-filter: blur(15px);
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
      }
      
      .floating-btn {
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.2), rgba(0, 255, 255, 0.2));
        border: 3px solid #00ffff;
        border-radius: 50%;
        color: #00ffff;
        font-size: 16px;
        width: 50px;
        height: 50px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        backdrop-filter: blur(10px);
        font-family: 'Orbitron', sans-serif;
      }
      
      .floating-btn:hover {
        transform: scale(1.1);
        border-color: #9d00ff;
        box-shadow: 0 0 30px rgba(157, 0, 255, 0.5);
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.3), rgba(0, 255, 255, 0.3));
      }
      
      .floating-btn.fullscreen-btn {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 10001;
      }
      
      
      /* Bottom Control Panel - Lobby Style */
      .bottom-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        border-top: 3px solid #00ffff;
        padding: 12px 15px;
        pointer-events: auto;
        z-index: 10001;
        backdrop-filter: blur(15px);
        box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
      }
      
      .control-section {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      
      .game-controls {
        display: flex;
        gap: 6px;
        flex: 1;
      }
      
      .power-section {
        flex-shrink: 0;
        width: 120px;
      }
      
      .mobile-btn {
        flex: 1;
        padding: 8px 6px;
        border: 3px solid;
        border-radius: 12px;
        font-family: 'Orbitron', sans-serif;
        font-weight: bold;
        font-size: 9px;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.3s ease;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        min-height: 32px;
        backdrop-filter: blur(10px);
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      }
      
      .mobile-btn.heads-btn {
        background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 204, 106, 0.2));
        border-color: #00ff88;
        color: #00ff88;
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      }
      
      .mobile-btn.heads-btn.selected {
        background: linear-gradient(135deg, rgba(255, 20, 147, 0.4), rgba(255, 105, 180, 0.4));
        border-color: #ff1493;
        color: #ff1493;
        box-shadow: 0 0 30px rgba(255, 20, 147, 0.6);
        transform: scale(1.05);
      }
      
      .mobile-btn.tails-btn {
        background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(157, 0, 255, 0.2));
        border-color: #00ffff;
        color: #00ffff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }
      
      .mobile-btn.tails-btn.selected {
        background: linear-gradient(135deg, rgba(255, 20, 147, 0.4), rgba(255, 105, 180, 0.4));
        border-color: #ff1493;
        color: #ff1493;
        box-shadow: 0 0 30px rgba(255, 20, 147, 0.6);
        transform: scale(1.05);
      }
      
      .mobile-btn.power-btn {
        background: linear-gradient(135deg, rgba(255, 20, 147, 0.2), rgba(255, 105, 180, 0.2));
        border-color: #ff1493;
        color: #ff1493;
        box-shadow: 0 0 20px rgba(255, 20, 147, 0.3);
      }
      
      .mobile-btn.change-btn {
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.2), rgba(0, 255, 255, 0.2));
        border-color: #9d00ff;
        color: #9d00ff;
        box-shadow: 0 0 20px rgba(157, 0, 255, 0.3);
      }
      
      .mobile-btn.action-btn {
        background: linear-gradient(135deg, rgba(157, 0, 255, 0.2), rgba(0, 255, 255, 0.2));
        border-color: #9d00ff;
        color: #9d00ff;
        box-shadow: 0 0 20px rgba(157, 0, 255, 0.3);
      }
      
      .mobile-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        border-color: #00ffff;
      }
      
      .mobile-btn:active {
        transform: scale(0.95);
      }
      
       /* Player Cards - 4 flat boxes attached directly to bottom */
       .player-cards {
         position: fixed;
         bottom: 80px;
         left: 0;
         right: 0;
         height: 40px;
         display: flex;
         gap: 0;
         pointer-events: auto;
         z-index: 10001;
         align-items: stretch;
         justify-content: space-between;
         padding: 0 5px;
         border-bottom: 2px solid #00ffff;
       }
      
       /* Individual player boxes - flat and wide */
       .player-box {
         flex: 1;
         height: 40px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        border: 1px solid #00ffff;
        border-bottom: 1px solid #00ffff;
        border-radius: 0;
        padding: 2px 4px;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        font-size: 7px;
        backdrop-filter: blur(15px);
        transition: all 0.3s ease;
        font-family: 'Orbitron', sans-serif;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: flex-start;
        margin: 0;
        min-width: 0;
      }
      
      .player-box:hover {
        border-color: #9d00ff;
        box-shadow: 0 0 30px rgba(157, 0, 255, 0.5);
        transform: translateY(-2px);
      }
      
      
      .player-card {
        width: 80px;
        height: 50px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.95), rgba(16, 33, 62, 0.95));
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 4px;
        text-align: center;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        font-size: 8px;
        backdrop-filter: blur(15px);
        transition: all 0.3s ease;
        font-family: 'Orbitron', sans-serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      
      .player-card:hover {
        border-color: #9d00ff;
        box-shadow: 0 0 30px rgba(157, 0, 255, 0.5);
        transform: translateY(-2px);
      }
      
      .player-box .player-avatar {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        object-fit: cover;
        border: 1px solid #00ffff;
        margin-right: 4px;
        display: block;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
        flex-shrink: 0;
      }
      
      .player-box .player-info {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        flex: 1;
        min-width: 0;
        margin-left: 4px;
      }
      
      .player-box .player-name {
        font-size: 7px;
        color: #00ffff;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-shadow: 0 0 3px rgba(0, 255, 255, 0.5);
        line-height: 1;
        flex: 1;
        text-align: left;
      }
      
      .player-box .player-wins {
        font-size: 6px;
        color: #FFD700;
        font-weight: bold;
        text-shadow: 0 0 3px rgba(255, 215, 0, 0.5);
        line-height: 1;
        flex-shrink: 0;
        margin-left: 4px;
      }
      
      .timer, .earnings {
        color: #00ffff;
        font-size: 10px;
        font-weight: bold;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
      }
      
      .earnings {
        color: #FFD700;
        text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
      }
      
      .power-bar {
        position: relative;
        height: 24px;
        background: linear-gradient(135deg, rgba(10, 15, 35, 0.8), rgba(16, 33, 62, 0.8));
        border: 2px solid #00ffff;
        border-radius: 12px;
        overflow: hidden;
        width: 100%;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      }
      
      .power-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff88, #00ff88);
        border-radius: 10px;
        transition: width 0.1s ease;
        width: 0%;
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
      }
      
      .power-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ff88;
        font-size: 9px;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(0, 255, 136, 0.8);
        font-family: 'Orbitron', sans-serif;
      }
      
    }
    
    /* Portrait Warning Overlay */
    .portrait-warning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 99999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      padding: 20px;
    }

    @media (max-width: 768px) and (orientation: portrait) {
      .portrait-warning {
        display: flex !important;
      }
    }

    .portrait-warning-content {
      background: linear-gradient(135deg, rgba(157, 0, 255, 0.3), rgba(0, 255, 255, 0.3));
      border: 3px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      max-width: 300px;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
      backdrop-filter: blur(10px);
    }

    .portrait-warning-icon {
      font-size: 60px;
      margin-bottom: 20px;
      animation: rotate-phone 2s ease-in-out infinite;
    }

    @keyframes rotate-phone {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }

    .portrait-warning h2 {
      color: #00ffff;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      margin-bottom: 15px;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    }

    .portrait-warning p {
      color: white;
      font-family: 'Orbitron', sans-serif;
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 10px;
    }
    
    /* Desktop: Show desktop layout, hide mobile layout */
    @media (min-width: 768px) {
      .game-info .desktop-timer-layout {
        display: block !important;
      }
      
      .game-info .mobile-timer-round {
        display: none !important;
      }
      
      .game-info button {
        display: block !important;
      }
    }

    /* Lab room background */
    body.lab-room {
      background: url('/images/background/thelab.png') no-repeat center center fixed;
    }
    
    /* Cyber Bay room background */
    body.cyber-room {
      background: url('/images/background/cyber.png') no-repeat center center fixed;
    }
    
    /* Mech Room background */
    body.mech-room {
      background: url('/images/background/mech.png') no-repeat center center fixed;
    }

    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: auto; /* Enable interactions for CSS3D/UI elements */
    }
    
    #container canvas {
      pointer-events: auto; /* Re-enable clicks on the canvas */
    }

    /* Player Card Styling */
    .player-card {
      width: 320px;
      background: rgba(10, 15, 35, 0.95);
      border: 3px solid #00ffff;
      border-radius: 16px;
      padding: 15px 20px;
      font-family: 'Orbitron', sans-serif;
      color: white;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
      pointer-events: auto;
      position: relative;
    }

    .card-header {
      margin-bottom: 15px;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .player-avatar {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      object-fit: cover;
      border: 2px solid #00ffff;
      flex-shrink: 0;
    }

    .player-info {
      flex: 1;
      text-align: right;
    }

    .player-name {
      font-size: 22px;
      font-weight: bold;
      color: #00ffff;
      margin-bottom: 5px;
    }

    .player-address {
      font-size: 16px;
      color: #ffffff;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
    }

    .trophy-symbol {
      font-size: 24px;
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
      margin: 5px;
    }

    @keyframes puffWin {
      0% { 
        transform: scale(0.3); 
        opacity: 0; 
        box-shadow: 0 0 0 rgba(255, 215, 0, 0);
      }
      50% { 
        transform: scale(1.3); 
        opacity: 1; 
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
      }
      100% { 
        transform: scale(1); 
        opacity: 1; 
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
      }
    }

    .choice-badge {
      padding: 12px;
      margin: 15px 0;
      border-radius: 8px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .choice-badge.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      border: 2px solid #00ff00;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-badge.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      border: 2px solid #00d4ff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-buttons {
      display: flex;
      gap: 10px;
      margin: 15px 0;
    }

    .choice-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      pointer-events: auto;
    }

    .choice-btn.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-btn.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-btn:hover {
      transform: translateY(-3px);
      filter: brightness(1.2);
    }
    
    .choice-btn.heads:hover {
      box-shadow: 0 5px 20px rgba(0, 255, 0, 0.8);
    }
    
    .choice-btn.tails:hover {
      box-shadow: 0 5px 20px rgba(0, 212, 255, 0.8);
    }

    .action-btn {
      width: 100%;
      padding: 15px;
      background: white;
      border: 2px solid #ff1493;
      border-radius: 8px;
      color: #ff1493;
      font-weight: 900;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-top: 10px;
      pointer-events: auto;
    }

    .action-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 20, 147, 0.3);
      background: #ffe6f2;
    }

    .action-btn:active {
      transform: translateY(0);
    }

    /* Pulse animation for eliminated players */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    #info {
      display: none; /* Hidden */
    }
  </style>
</head>
<body>
  <!-- Portrait Orientation Warning -->
  <div class="portrait-warning">
    <div class="portrait-warning-content">
      <div class="portrait-warning-icon">üì±‚û°Ô∏è</div>
      <h2>Please Rotate Your Device</h2>
      <p>This game is designed for landscape mode.</p>
      <p>Please rotate your device to continue playing!</p>
    </div>
  </div>
  
  <div id="container"></div>
  
  <!-- Responsive Mobile Layout -->
  <div id="mobile-ui" class="mobile-ui">
    <!-- Player Cards -->
    <div class="player-cards" id="mobile-player-cards">
      <!-- Player cards will be dynamically created here -->
    </div>
    
    <!-- Floating UI Elements -->
    <!-- Top-left Change Coin -->
    <button class="floating-btn change-coin-btn" id="mobile-change-coin">ü™ô</button>
    
    <!-- Top-right Earnings -->
    <div class="floating-earnings" id="mobile-earnings">1,250 FLIP</div>
    
    <!-- Top-right Fullscreen -->
    <button class="floating-btn fullscreen-btn" id="mobile-fullscreen">‚õ∂</button>
    
    <!-- Bottom-right Chat -->
    <button class="floating-btn chat-btn" id="mobile-chat">üí¨</button>
    
    <!-- Bottom Control Panel -->
    <div class="bottom-panel">
      <!-- Game Controls and Power Bar -->
      <div class="control-section">
        <div class="game-controls">
          <button class="mobile-btn heads-btn" id="mobile-heads">HEADS</button>
          <button class="mobile-btn tails-btn" id="mobile-tails">TAILS</button>
          <button class="mobile-btn power-btn" id="mobile-power">POWER</button>
        </div>
        <div class="power-section">
          <div class="power-bar">
            <div class="power-fill" id="mobile-power-fill"></div>
            <div class="power-text" id="mobile-power-text">POWER: 0%</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="info">
    üéÆ Glass Tube Game Test<br>
    Loading Three.js...
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
      }
    }
  </script>
  
  <!-- Socket.io for server-side physics -->
  <script src="/socket.io/socket.io.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import * as CANNON from 'cannon-es';

    const info = document.getElementById('info');

    // ===== URL PARAMS =====
    const urlParams = new URLSearchParams(window.location.search);
    const gameIdParam = urlParams.get('gameId') || '';
    const roleParam = urlParams.get('role') || 'player';
    const userNameParam = urlParams.get('username') || '';
    let walletParam = urlParams.get('address') || '';
    const avatarParam = urlParams.get('avatar') || '';
    const roomParam = urlParams.get('room') || 'potion'; // Default to potion room
    const tokenParam = urlParams.get('token') || '';
    
    // Fallback: Try to get wallet from localStorage if not in URL (for React redirects)
    if (!walletParam) {
      walletParam = localStorage.getItem('walletAddress') || '';
      console.log('üîç No wallet in URL, trying localStorage:', walletParam);
      
      // Additional fallback: try to get from window.ethereum
      if (!walletParam && window.ethereum?.selectedAddress) {
        walletParam = window.ethereum.selectedAddress;
        console.log('üîç Got wallet from window.ethereum:', walletParam);
      }
      
      // Debug: show all available wallet sources
      console.log('üîç Wallet detection debug:', {
        urlParam: urlParams.get('address'),
        localStorage: localStorage.getItem('walletAddress'),
        ethereum: window.ethereum?.selectedAddress,
        final: walletParam
      });
    }

    if (gameIdParam) {
      document.title = `Glass Tube Game ‚Ä¢ ${gameIdParam}`;
    }
    
    // Apply room-specific styling
    if (roomParam === 'lab') {
      document.body.classList.add('lab-room');
    } else if (roomParam === 'cyber') {
      document.body.classList.add('cyber-room');
    } else if (roomParam === 'mech') {
      document.body.classList.add('mech-room');
    }
    
    // Mobile background orientation handler - AGGRESSIVE VERSION
    function updateMobileBackground() {
      if (!isMobile()) return;
      
      const isLandscape = window.innerWidth > window.innerHeight;
      const roomParam = new URLSearchParams(window.location.search).get('room');
      
      // STEP 1: Completely remove ALL background properties
      document.body.style.background = 'none';
      document.body.style.backgroundImage = 'none';
      document.body.style.backgroundSize = '';
      document.body.style.backgroundAttachment = '';
      document.body.style.backgroundPosition = '';
      document.body.style.backgroundRepeat = '';
      
      // STEP 2: Force a reflow
      void document.body.offsetHeight;
      
      // STEP 3: Set new background based on orientation
      if (isLandscape) {
        let bgImage = "url('/Images/Background/game room2.png')";
        if (roomParam === 'lab') bgImage = "url('/images/background/thelab.png')";
        else if (roomParam === 'cyber') bgImage = "url('/images/background/cyber.png')";
        else if (roomParam === 'mech') bgImage = "url('/images/background/mech.png')";
        
        // Set properties individually to force update
        document.body.style.backgroundImage = bgImage;
        document.body.style.backgroundSize = "100% 100%";
        document.body.style.backgroundPosition = "center center";
        document.body.style.backgroundRepeat = "no-repeat";
        document.body.style.backgroundAttachment = "scroll";
      } else {
        // Portrait - solid color
        document.body.style.backgroundColor = "#0a0f23";
      }
      
      // STEP 4: Force another reflow
      void document.body.offsetHeight;
      
      console.log('üì± Background FORCE UPDATED for', isLandscape ? 'LANDSCAPE' : 'PORTRAIT', 'Width:', window.innerWidth, 'Height:', window.innerHeight);
    }

    // Run immediately
    updateMobileBackground();

    // Listen for orientation changes with delay
    window.addEventListener('orientationchange', function() {
      console.log('üîÑ Orientation change detected');
      setTimeout(updateMobileBackground, 50);
      setTimeout(updateMobileBackground, 200);
      setTimeout(updateMobileBackground, 500);
    });

    // Fallback: listen for resize
    let resizeTimeout;
    window.addEventListener('resize', function() {
      if (isMobile()) {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateMobileBackground, 100);
      }
    });
    
    info.textContent = 'üéÆ Initializing 4-Player Glass Tube Game...';

    // ===== SOCKET.IO CONNECTION =====
    let socket = null;
    let gameState = null;
    let playerSlot = -1;
    let isServerSideMode = true; // Enable server-side physics
    
    // Initialize socket connection
    function initializeSocket() {
      if (typeof io === 'undefined') {
        console.error('‚ùå Socket.io not loaded');
        return;
      }
      
      socket = io();
      
      socket.on('connect', () => {
        console.log('‚úÖ Connected to server');
        
        // Load saved state and send to server
        const savedState = loadGameState();
        
        // Join physics room
        if (gameIdParam && walletParam) {
          socket.emit('physics_join_room', {
            roomId: `game_${gameIdParam}`,
            address: walletParam,
            savedState: savedState // ‚Üê Send saved state to server
          });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('‚ùå Disconnected from server');
      });
      
      // Handle reconnection
      socket.on('reconnect', () => {
        console.log('üîÑ Reconnecting to server...');
        
        // Load saved state and send to server
        const savedState = loadGameState();
        
        // Rejoin the game room with saved state
        if (gameIdParam && walletParam) {
          socket.emit('physics_rejoin_room', {
            roomId: `game_${gameIdParam}`,
            address: walletParam,
            lastKnownSlot: playerSlot,
            savedState: savedState, // ‚Üê Send saved state to server
            disconnectTime: savedState?.timestamp || Date.now() // ‚Üê Send disconnect time
          });
        }
      });

      socket.on('game_state_restored', (data) => {
        console.log('‚úÖ Game state restored:', data);
        
        // Restore player choices
        if (data.playerChoices) {
          Object.keys(data.playerChoices).forEach(slot => {
            const slotIndex = parseInt(slot);
            if (players[slotIndex]) {
              players[slotIndex].choice = data.playerChoices[slot];
              updatePlayerCardChoice(slotIndex, data.playerChoices[slot]);
            }
          });
        }
        
        // Restore coin selections
        if (data.coinSelections) {
          data.coinSelections.forEach((selection, index) => {
            if (selection && tubes[index]) {
              tubes[index].selectedCoin = coinOptions.find(c => c.id === selection.coinId) || coinOptions[0];
              tubes[index].selectedMaterial = coinMaterials.find(m => m.id === selection.materialId) || coinMaterials[0];
              // Apply the coin textures
              applyCoinSelection(index, tubes[index].selectedCoin, tubes[index].selectedMaterial);
            }
          });
        }
        
        // Restore game phase
        if (data.phase) {
          gameState = { ...gameState, phase: data.phase };
          if (data.phase === 'game_over') {
            gameOver = true;
            handleGameEnd(data);
          }
        }
      });
      
      // Server-side physics events
      socket.on('physics_state_update', (state) => {
        console.log('üìä Received physics state update:', {
          phase: state?.phase,
          currentRound: state?.currentRound,
          roundTimer: state?.roundTimer,
          players: state?.players ? Object.keys(state.players).length : 0
        });
        gameState = state;
        updateClientFromServerState(state);
        
        // Update mobile player cards when state changes
        createMobilePlayerCards();
      });
      
      socket.on('physics_coin_flip_start', (data) => {
        console.log('ü™ô Coin flip started:', data);
        startClientCoinFlipAnimation(data);
      });
      
      socket.on('physics_coin_result', (data) => {
        console.log('üé≤ Coin flip result:', data);
        showCoinFlipResult(data);
      });
      
      socket.on('physics_power_charging', (data) => {
        console.log('‚ö° Power charging:', data);
        updatePowerChargingVisual(data);
      });
      
      // üéØ NEW: Handle charging start event
      socket.on('physics_power_charging_start', (data) => {
        console.log('‚ö° Received charging start:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = true;
            tube.power = 0;
            tube.chargingStartTime = Date.now();
            console.log(`üåä Started pearl animation for tube ${data.playerSlot + 1}`);
            
            // üéØ FORCE PEARL VISIBILITY: Ensure pearls are visible when charging starts
            if (tube.liquidParticleMeshes) {
              tube.liquidParticleMeshes.forEach(mesh => {
                mesh.visible = true;
              });
              console.log(`üåä Forced pearl visibility on charging start for tube ${data.playerSlot + 1}`);
            }
          }
        }
      });

      // üéØ NEW: Handle charging stop event
      socket.on('physics_power_charging_stop', (data) => {
        console.log('‚ö° Received charging stop:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = false;
            tube.power = data.finalPower || tube.power;
            console.log(`üõë Stopped pearl animation for tube ${data.playerSlot + 1} at ${tube.power}%`);
          }
        }
      });
      
      socket.on('physics_coin_angle_update', (data) => {
        console.log('üéØ Coin angle update:', data);
        updateCoinAngleVisual(data);
      });
      
      // Handle FLIP token award confirmation
      socket.on('flip_tokens_awarded', (data) => {
        console.log('üí∞ FLIP tokens awarded:', data);
        if (data.success) {
          // Show floating message instead of immediate XP update
          showFloatingMessage(`+${data.amount} FLIP earned!`, '#FFD700', 3000);
        } else {
          console.error('‚ùå Failed to award FLIP tokens:', data.error);
        }
      });

      // Handle direct FLIP token award
      socket.on('flip_tokens_awarded_final', (data) => {
        console.log('üéÅ FLIP tokens awarded:', data);
        if (data.success) {
          showFloatingMessage(`+${data.totalFlip} FLIP tokens added to your profile!`, '#00ff00', 4000);
        } else {
          console.error('‚ùå FLIP token award failed:', data.error);
          showFloatingMessage(`Failed to award FLIP tokens: ${data.error}`, '#ff0000', 3000);
        }
      });

      // Handle FLIP collection confirmation
      socket.on('flip_tokens_collected', (data) => {
        console.log('üíé FLIP tokens collected:', data);
        if (data.success) {
          const claimBtn = document.getElementById('claim-flip-btn');
          if (claimBtn) {
            claimBtn.textContent = `‚úÖ Claimed ${data.amount} FLIP!`;
            claimBtn.style.background = 'linear-gradient(135deg, #888, #666)';
            claimBtn.disabled = true;
          }
          showFloatingMessage(`Successfully claimed ${data.amount} FLIP!`, '#00ff00', 3000);
        }
      });

      // Handle NFT claim confirmation
      socket.on('nft_prize_claimed', (data) => {
        console.log('üèÜ NFT prize claimed:', data);
        if (data.success) {
          const nftBtn = document.getElementById('claim-nft-btn');
          if (nftBtn) {
            nftBtn.textContent = '‚úÖ NFT Claimed!';
            nftBtn.style.background = 'linear-gradient(135deg, #888, #666)';
            nftBtn.disabled = true;
          }
          showFloatingMessage('NFT successfully transferred to your wallet!', '#FFD700', 3000);
        }
      });
      
      socket.on('physics_error', (error) => {
        console.error('‚ùå Physics error:', error);
        
        // üéØ NEW: Reset the tube state on error
        const playerIndex = players.findIndex(p => p.address === walletParam);
        if (playerIndex !== -1 && tubes[playerIndex]) {
          tubes[playerIndex].isFilling = false;
          tubes[playerIndex].power = 0;
          tubes[playerIndex].powerLevel = 0;
          isCharging = false;
          
          // Stop charging sound if playing
          if (powerChargeSound && !powerChargeSound.paused) {
            powerChargeSound.pause();
            powerChargeSound.currentTime = 0;
          }
          
          console.log(`üîÑ Reset tube ${playerIndex + 1} state after error`);
        }
        
        alert(`Game Error: ${error.message}`);
      });
      
      // Listen for player choice updates from server
      socket.on('player_choice_update', (data) => {
        console.log('üéØ Player choice update:', data);
        updatePlayerChoice(data);
      });
      
      // Listen for coin updates from server
      socket.on('coin_update', (data) => {
        console.log('ü™ô Coin update received:', data);
        updateCoinFromServer(data);
      });
      
      // Listen for player flip actions from server
      socket.on('player_flip_action', (data) => {
        console.log('üé∞ Player flip action:', data);
        // This will be handled by physics_coin_flip_start event
      });
      
      // Listen for glass shatter events
      socket.on('glass_shatter', (data) => {
        console.log('üí• Glass shatter:', data);
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          shatterGlass(data.playerSlot, data.power);
        }
      });
    }
    
    // Update client state from server
    function updateClientFromServerState(state) {
      if (!state) return;
      
      // SERVER-AUTHORITATIVE: Client only reacts to server state
      if (state.phase === 'round_active' && !gameOver) {
        // Server manages timer, client just displays
        // Clear any waiting phase indicator and show round active
        const existingIndicator = document.getElementById('game-phase-indicator');
        if (existingIndicator) {
          existingIndicator.remove();
        }
        console.log(`üéÆ Game is now round_active - Round ${state.currentRound}`);
        
        // Update button visibility for the new round
        updatePlayerCardButtons();
      } else if (state.phase === 'game_over') {
        gameOver = true;
        
        // Handle server-side game end
        if (state.winner) {
          // Find winner index
          const winnerIndex = players.findIndex(p => p.address && p.address.toLowerCase() === state.winner.toLowerCase());
          if (winnerIndex >= 0) {
            console.log(`üèÜ Server declared winner: ${players[winnerIndex].name}`);
            showGameOverScreen(winnerIndex, players[winnerIndex].name);
          } else {
            console.log(`üèÜ Server declared winner but couldn't find player: ${state.winner}`);
            showGameOverScreen(-1, state.winner);
          }
        } else {
          console.log(`üèÜ Server declared game over with no winner`);
          showGameOverScreen(-1, null);
        }
      }
      
      // Update player data
      if (state.players && walletParam) {
        const normalizedAddress = walletParam.toLowerCase();
        const player = state.players[normalizedAddress];
        if (player) {
          const oldPlayerSlot = playerSlot;
          playerSlot = player.slotNumber;
          console.log(`üéÆ Player slot: ${playerSlot}`);
          
          // Mark this as the current player's tube
          if (playerSlot >= 0 && playerSlot < 4) {
            tubes[playerSlot].isCurrentPlayer = true;
            players[playerSlot].isCurrentPlayer = true;
          }
          
          // Update button visibility for all player cards
          updatePlayerCardButtons();
        }
        
        // Sync all player choices from server state
        Object.keys(state.players).forEach(address => {
          const serverPlayer = state.players[address];
          if (serverPlayer && serverPlayer.slotNumber >= 0 && serverPlayer.slotNumber < 4) {
            const localPlayer = players[serverPlayer.slotNumber];
            if (localPlayer && !localPlayer.isEmpty) {
              // Update choice if it changed (including reset to null)
              if (serverPlayer.choice !== localPlayer.choice) {
                console.log(`üîÑ Syncing player ${serverPlayer.slotNumber + 1} choice: ${serverPlayer.choice || 'null'} (was: ${localPlayer.choice || 'null'})`);
                localPlayer.choice = serverPlayer.choice;
                
                // Update UI for this player
                const tube = tubes[serverPlayer.slotNumber];
                if (tube && tube.cardElement) {
                  const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
                  const choiceBadge = tube.cardElement.querySelector('.choice-badge');
                  
                  if (choiceButtons && choiceBadge) {
                    if (serverPlayer.choice) {
                      // Show choice badge
                      choiceButtons.style.display = 'none';
                      choiceBadge.style.display = 'inline-block';
                      choiceBadge.textContent = serverPlayer.choice.toUpperCase();
                      choiceBadge.className = `choice-badge ${serverPlayer.choice}`;
                    } else {
                      // Hide choice badge, show buttons for current player
                      choiceBadge.style.display = 'none';
                      if (playerSlot === serverPlayer.slotNumber) {
                        choiceButtons.style.display = 'flex';
                      } else {
                        choiceButtons.style.display = 'none';
                      }
                    }
                  }
                }
              }
              
              // Update wins if changed
              if (serverPlayer.wins !== undefined && localPlayer.wins !== serverPlayer.wins) {
                localPlayer.wins = serverPlayer.wins;
                updateWinsDisplay(serverPlayer.slotNumber);
              }
            }
          }
        });
      }
      
      // SERVER-AUTHORITATIVE: Display server timer only
      if (state.roundTimer !== undefined) {
        updateTimerDisplay(state.roundTimer);
      }
      
      // Update round
      if (state.currentRound !== undefined) {
        const oldRound = currentRound;
        currentRound = state.currentRound;
        updateRoundDisplay();
        saveGameState();
        
        // üéØ ROUND RESET: Reset ALL player states for new round
        if (currentRound > oldRound) {
          console.log(`üîÑ Round ${currentRound} started - FULL RESET`);
          tubes.forEach((tube, i) => {
            // 1. Reset power usage
            tube.hasUsedPower = false;
            tube.power = 0;
            tube.isFilling = false;
            tube.foamIntensity = 0;
            
            // 2. Reset glass shatter state
            tube.isShattered = false;
            tube.isFlipping = false;
            
            // 3. Show glass tube and rims again
            tube.tube.visible = true;
            tube.backing.visible = true;
            tube.topRim.visible = true;
            tube.bottomRim.visible = true;
            tube.liquid.visible = true;
            tube.coinShadow.visible = false;
            
            // 4. Clear glass shards
            if (tube.glassShards && tube.glassShards.length > 0) {
              tube.glassShards.forEach(shard => {
                scene.remove(shard.mesh);
              });
              tube.glassShards = [];
            }
            
            // 5. Re-add physics container
            if (!physicsWorld.bodies.includes(tube.glassBody)) {
              physicsWorld.addBody(tube.glassBody);
            }
            
            // 6. Reset pearl colors to neutral
            updatePearlColors(tube, 0, i);
            
            // 6.5. Reset pearl positions to bottom of tube
            tube.liquidParticles.forEach((particleBody, idx) => {
              // Reset position to bottom of tube
              const angle = Math.random() * Math.PI * 2;
              const radius = Math.random() * (TUBE_RADIUS - 25);
              const pearlX = tube.tube.position.x + Math.cos(angle) * radius;
              const pearlZ = Math.sin(angle) * radius;
              const pearlY = 200 - (TUBE_HEIGHT / 2) + 30 + Math.random() * 60;
              
              particleBody.position.set(pearlX, pearlY, pearlZ);
              particleBody.velocity.set(0, 0, 0);
              particleBody.angularVelocity.set(0, 0, 0);
              
              // Make sure pearl is visible
              if (tube.liquidParticleMeshes[idx]) {
                tube.liquidParticleMeshes[idx].visible = true;
              }
            });
            
            // 6.6. Reset liquid light to neutral
            tube.liquidLight.color.setHex(0x1a1a2e); // Dark blue-grey
            tube.liquidLight.intensity = 0.3;
            
            // 7. Reset coin to default position
            const coin = coins[i];
            if (coin) {
              coin.position.set(tube.tube.position.x, 200, 0);
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
              
              // Remove any result lights
              if (tube.winLight) {
                coin.remove(tube.winLight);
                tube.winLight = null;
              }
              if (tube.loseLight) {
                coin.remove(tube.loseLight);
                tube.loseLight = null;
              }
            }
            
            // 8. Remove result box
            if (tube.resultBox) {
              scene.remove(tube.resultBox);
              tube.resultBox = null;
            }
            
            // 9. Reset UI - Power button
            if (tube.cardElement) {
              const powerButton = tube.cardElement.querySelectorAll('.action-btn')[0]; // Fixed: was [1], now [0]
              if (powerButton) {
                powerButton.style.background = 'linear-gradient(135deg, #9d00ff, #c44aff)';
                powerButton.style.color = '#ffffff';
                powerButton.style.borderColor = '#9d00ff';
                powerButton.disabled = false;
                powerButton.style.opacity = '1';
                powerButton.style.cursor = 'pointer';
              }
              
              // Reset power bar
              const powerBar = tube.cardElement.querySelector('.power-bar');
              const powerText = tube.cardElement.querySelector('.power-text');
              if (powerBar) {
                powerBar.style.width = '0%';
                powerBar.style.background = 'linear-gradient(90deg, #00ff00, #39ff14)';
              }
              if (powerText) {
                powerText.textContent = 'POWER: 0%';
              }
            }
          });
          
          // 10. Reset player choices for new round
          players.forEach((player, i) => {
            if (!player.isEmpty) {
              player.choice = null;
              
              // Update UI to show choice buttons again
              const tube = tubes[i];
              if (tube && tube.cardElement) {
                const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
                const choiceBadge = tube.cardElement.querySelector('.choice-badge');
                
                if (choiceButtons && choiceBadge) {
                  choiceBadge.style.display = 'none';
                  // Only show buttons for current player
                  if (playerSlot === i) {
                    choiceButtons.style.display = 'flex';
                    
                    // Reset choice button styles
                    const choiceBtnElements = tube.cardElement.querySelectorAll('.choice-btn');
                    choiceBtnElements.forEach(btn => {
                      btn.style.opacity = '1';
                      btn.style.transform = 'scale(1)';
                      btn.style.boxShadow = '';
                    });
                  } else {
                    choiceButtons.style.display = 'none';
                  }
                }
              }
            }
          });
          
          // 11. Reset mobile choice highlighting
          const mobileHeadsBtn = document.getElementById('mobile-heads');
          const mobileTailsBtn = document.getElementById('mobile-tails');
          if (mobileHeadsBtn && mobileTailsBtn) {
            mobileHeadsBtn.classList.remove('selected');
            mobileTailsBtn.classList.remove('selected');
          }
          
          // 12. Reset mobile power bar
          const mobilePowerFill = document.getElementById('mobile-power-fill');
          const mobilePowerText = document.getElementById('mobile-power-text');
          if (mobilePowerFill && mobilePowerText) {
            mobilePowerFill.style.width = '0%';
            mobilePowerText.textContent = 'POWER: 0%';
          }
          
          console.log(`‚úÖ Round ${currentRound} reset complete - players can charge and choose again`);
          
          // üéØ CRITICAL: Update button visibility after reset
          updatePlayerCardButtons();
        }
      }
      
      // Update coin states from server physics
      if (state.coinStates) {
        updateCoinStatesFromServer(state.coinStates);
      }
      
      // Update coin rotations based on player choices (before flipping)
      updateCoinRotationsFromPlayerChoices();
    }
    
    // Update coin rotations based on player choices (before flipping)
    function updateCoinRotationsFromPlayerChoices() {
      tubes.forEach((tube, i) => {
        const player = players[i];
        const coin = coins[i];
        
        if (coin && !tube.isFlipping && !tube.isShattered) {
          if (player && !player.isEmpty) {
            // Only update rotation if player has made a choice and coin is not flipping
            if (player.choice === 'heads') {
              // Show heads face (standing on edge, heads facing camera)
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            } else if (player.choice === 'tails') {
              // Show tails face (standing on edge, tails facing camera)
              coin.rotation.x = 3 * Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            } else {
              // If no choice made, default to standing on edge (heads position)
              coin.rotation.x = Math.PI / 2;
              coin.rotation.y = Math.PI / 2;
              coin.rotation.z = 0;
            }
          } else {
            // For empty players, ensure coin is in default upright position (not sideways)
            coin.rotation.x = Math.PI / 2;
            coin.rotation.y = Math.PI / 2;
            coin.rotation.z = 0;
          }
        }
      });
    }
    
    // Update coin states from server physics
    function updateCoinStatesFromServer(coinStates) {
      coinStates.forEach((coinState, index) => {
        if (coinState && coinState.position) {
          const coin = coins[index];
          const tube = tubes[index];
          if (coin && tube) {
            // ONLY update from server if we're NOT currently flipping locally
            // Local flip animations take priority to prevent jittery visuals
            if (!tube.isFlipping) {
              // Update coin position from server, but ensure it stays within the correct tube
              const tubeX = tube.tube.position.x;
              coin.position.set(tubeX, coinState.position.y, coinState.position.z);
              
              // Update coin rotation from server, but preserve choice-based rotation when not flipping
              if (coinState.rotation && coinState.isFlipping) {
                // Only update rotation from server if the coin is actually flipping
                coin.quaternion.set(
                  coinState.rotation.x,
                  coinState.rotation.y,
                  coinState.rotation.z,
                  coinState.rotation.w
                );
              } else {
                // When not flipping, ensure coin maintains proper choice-based rotation
                updateCoinRotationsFromPlayerChoices();
              }
            }
            
            // Update flip state
            if (coinState.isFlipping) {
              tubes[index].isFlipping = true;
            } else {
              tubes[index].isFlipping = false;
            }
          }
        }
      });
    }
    
    // Start client coin flip animation (visual only)
    function startClientCoinFlipAnimation(data) {
      console.log('üéÅ Received flip reward data:', data.flipReward);
      console.log('üéÅ Full data object:', data);
      
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        
        if (tube && coin) {
          tube.isFlipping = true;
          
          // Start visual animation based on server data
          animateCoinFlip(data.playerSlot, data.power, data.duration);
          
          // ‚úÖ Show FLIP reward for everyone to see (more fun!)
          showFlipReward(data.playerSlot, data.flipReward);
        }
      }
    }
    
    // Show coin flip result
    function showCoinFlipResult(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        
        if (tube && coin) {
          tube.isFlipping = false;
          
          // Lock coin to final rotation based on result
          const targetRotationX = data.result === 'heads' ? Math.PI / 2 : (3 * Math.PI / 2);
          const finalCycles = Math.floor(coin.rotation.x / (Math.PI * 2));
          coin.rotation.x = finalCycles * (Math.PI * 2) + targetRotationX;
          coin.rotation.y = Math.PI / 2;
          coin.rotation.z = 0;
          
          console.log(`‚úÖ Coin ${data.playerSlot + 1} landed on ${data.result} facing camera (server-side)`);
          
          // Show result
          showResult(data.playerSlot, data.won, data.result);
          
        }
      }
    }
    
    // üéØ REFACTORED: Update power charging visual - REAL-TIME for all players
    function updatePowerChargingVisual(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        if (!tube) return;
        
        tube.power = data.power;
        tube.powerLevel = data.powerLevel || Math.min(5, Math.max(1, Math.ceil(data.power / 20)));
        tube.isFilling = data.isFilling;
        
        const powerPercent = tube.power / 100;
        tube.foamIntensity = powerPercent;
        
        console.log(`‚ö° Updated power visual for player ${data.playerSlot + 1}: ${data.power}% (level ${tube.powerLevel}, foamIntensity: ${tube.foamIntensity}, isFilling: ${tube.isFilling})`);
        
        // üéØ UNIFIED ANIMATION - Same code for charger and viewers!
        updatePearlColors(tube, powerPercent, data.playerSlot);
        
        // Debug: Check if pearls exist and are visible
        if (tube.liquidParticleMeshes && tube.liquidParticleMeshes.length > 0) {
          const visibleCount = tube.liquidParticleMeshes.filter(mesh => mesh.visible).length;
          console.log(`üîç Tube ${data.playerSlot + 1} has ${tube.liquidParticleMeshes.length} pearls, ${visibleCount} visible`);
        }
        
        // üéØ FORCE PEARL VISIBILITY: Ensure pearls are always visible when charging
        if (tube.isFilling && tube.liquidParticleMeshes) {
          tube.liquidParticleMeshes.forEach(mesh => {
            mesh.visible = true;
          });
          console.log(`üåä Forced pearl visibility for tube ${data.playerSlot + 1}`);
        }
      }
    }
    
    // üéØ NEW: Update pearl colors - Extracted for reusability
    function updatePearlColors(tube, powerPercent, tubeIndex) {
      const darkPearl = new THREE.Color(0x1a1a1a); // Dark grey (neutral start)
      
      // Define neon colors for each tube
      const neonColors = [
        new THREE.Color(0x00ff00), // Tube 1: NEON GREEN
        new THREE.Color(0x00ddff), // Tube 2: NEON BLUE
        new THREE.Color(0xff0088), // Tube 3: NEON PINK
        new THREE.Color(0xffff00)  // Tube 4: NEON YELLOW
      ];
      
      const neonColor = neonColors[tubeIndex] || neonColors[0];
      const currentColor = darkPearl.clone().lerp(neonColor, powerPercent);
      
      // Update pearl colors with MAXIMUM NEON - ULTRA VIBRANT with bloom!
      tube.liquidParticleMeshes.forEach(particleMesh => {
        particleMesh.material.color.copy(currentColor);
        particleMesh.material.emissive.copy(currentColor);
        particleMesh.material.emissiveIntensity = 0.2 + (powerPercent * 25.0); // 0.2 to 25.2 - Perfect with bloom!
      });
      
      // Update liquid light to match pearl color
      tube.liquidLight.color.copy(currentColor);
      tube.liquidLight.intensity = 0.3 + (powerPercent * 15.0); // 0.3 to 15.3 - MEGA INTENSE!
    }

    // üéØ NEW: Update pearl physics - Extracted for reusability
    function updatePearlPhysics(tube, powerPercent, tubeIndex, frameCount) {
      const spinSpeed = powerPercent * 0.3; // Rotation speed increases with power
      const spinForce = powerPercent * 1200; // Orbital force
      const buoyancyForce = powerPercent * 800; // Upward float force
      
      tube.liquidParticles.forEach((particleBody, idx) => {
        // BUOYANCY - Float upward!
        particleBody.force.y += buoyancyForce;
        
        // Calculate position relative to tube center
        const dx = particleBody.position.x - tube.tube.position.x;
        const dz = particleBody.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 1) {
          // Calculate tangential force (perpendicular to radius) for circular motion
          const angle = Math.atan2(dz, dx);
          const tangentAngle = angle + Math.PI / 2; // 90 degrees to create orbit
          
          // Apply circular orbital force - pearls spin around the walls!
          const orbitForceX = Math.cos(tangentAngle) * spinForce * (1 + idx * 0.05);
          const orbitForceZ = Math.sin(tangentAngle) * spinForce * (1 + idx * 0.05);
          
          particleBody.force.x += orbitForceX;
          particleBody.force.z += orbitForceZ;
        }
        
        // Add chaotic bouncing movement
        const chaos = Math.sin(frameCount * 0.2 + idx) * 200 * powerPercent;
        particleBody.force.x += chaos;
        particleBody.force.z += Math.cos(frameCount * 0.2 + idx * 1.3) * 200 * powerPercent;
      });
    }
    
    
    // Update coin from server
    function updateCoinFromServer(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        const player = players[data.playerSlot];
        
        if (tube && coin && player && data.coinData) {
          console.log(`ü™ô Updating coin for player ${data.playerSlot + 1}: ${data.coinData.name}`);
          
          // Update stored selections
          tube.selectedCoin = data.coinData;
          tube.selectedMaterial = coinMaterials.find(m => m.id === data.coinData.material) || coinMaterials[0];
          
          // Load and apply new coin textures
          const textureLoader = new THREE.TextureLoader();
          textureLoader.load(data.coinData.headsImage, (headsTex) => {
            headsTex.minFilter = THREE.LinearFilter;
            headsTex.magFilter = THREE.LinearFilter;
            headsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
            headsTex.generateMipmaps = false;
            
            textureLoader.load(data.coinData.tailsImage, (tailsTex) => {
              tailsTex.minFilter = THREE.LinearFilter;
              tailsTex.magFilter = THREE.LinearFilter;
              tailsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
              tailsTex.generateMipmaps = false;
              
              // Update textures
              coin.material[1].uniforms.map.value = headsTex;
              coin.material[1].needsUpdate = true;
              coin.material[2].uniforms.map.value = tailsTex;
              coin.material[2].needsUpdate = true;
              
              // Update coin edge color based on material
              const edgeColor = new THREE.Color(tube.selectedMaterial.edgeColor);
              coin.material[0].color.copy(edgeColor);
              coin.material[0].emissive.copy(edgeColor);
              coin.material[0].emissiveIntensity = 0.3;
              coin.material[0].needsUpdate = true;
              
              console.log(`‚úÖ Applied ${data.coinData.name} with ${tube.selectedMaterial.name} material to ${player.name}'s coin`);
            });
          });
        }
      }
    }
    
    // Update coin angle visual
    function updateCoinAngleVisual(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const coin = coins[data.playerSlot];
        const tube = tubes[data.playerSlot];
        if (coin && tube && !tube.isFlipping) {
          // Only update angle if NOT currently flipping (prevent conflict)
          const angleRad = (data.angle * Math.PI) / 180;
          coin.rotation.z = angleRad;
        }
      }
    }
    
    // Update player choice from server broadcast
    function updatePlayerChoice(data) {
      console.log('üéØ Updating player choice:', data);
      
      // Find player by address or slot
      let playerIndex = -1;
      
      if (data.playerSlot !== undefined && data.playerSlot >= 0 && data.playerSlot < 4) {
        playerIndex = data.playerSlot;
      } else if (data.address) {
        const normalizedAddress = data.address.toLowerCase();
        playerIndex = players.findIndex(p => p.address && p.address.toLowerCase() === normalizedAddress);
      }
      
      if (playerIndex >= 0 && playerIndex < 4) {
        const player = players[playerIndex];
        if (player && !player.isEmpty) {
          // Update player choice
          player.choice = data.choice;
          console.log(`‚úÖ Updated player ${playerIndex + 1} choice to: ${data.choice}`);
          
          // Update the UI - find the choice badge and update it
          const tube = tubes[playerIndex];
          if (tube && tube.cardElement) {
            const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
            const choiceBadge = tube.cardElement.querySelector('.choice-badge');
            
            if (choiceButtons && choiceBadge) {
              // Replace choice buttons with badge
              choiceButtons.style.display = 'none';
              choiceBadge.style.display = 'inline-block';
              choiceBadge.textContent = data.choice.toUpperCase();
              choiceBadge.className = `choice-badge ${data.choice}`;
            }
          }
          
          // Update coin rotation to show the chosen face
          updateCoinRotationsFromPlayerChoices();
        }
      }
    }
    
    // Initialize socket connection
    initializeSocket();

    // ===== PLAYER CARD BUTTON MANAGEMENT =====
    
    // Update button visibility for all player cards based on current player slot
    function updatePlayerCardButtons() {
      tubes.forEach((tube, i) => {
        if (tube.cardElement) {
          const player = players[i];
          if (!player || player.isEmpty) return;
          
          // Determine if this is the current player's slot
          const isCurrentPlayer = isServerSideMode ? (playerSlot === i) : true;
          
          // Update choice buttons visibility
          const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
          const choiceBadge = tube.cardElement.querySelector('.choice-badge');
          
          if (isCurrentPlayer) {
            // Show choice buttons for current player only if they haven't made a choice yet
            if (player.choice) {
              // Player has made a choice - show the badge
              if (choiceButtons) choiceButtons.style.display = 'none';
              if (choiceBadge) {
                choiceBadge.style.display = 'inline-block';
                choiceBadge.textContent = player.choice.toUpperCase();
                choiceBadge.className = `choice-badge ${player.choice}`;
              }
            } else {
              // Player hasn't made a choice yet - show buttons
              if (choiceBadge) choiceBadge.style.display = 'none';
              if (choiceButtons) choiceButtons.style.display = 'flex';
            }
          } else if (player.choice) {
            // Show choice badge for other players
            if (choiceButtons) choiceButtons.style.display = 'none';
            if (choiceBadge) choiceBadge.style.display = 'block';
          } else {
            // Hide everything for other players without choices
            if (choiceButtons) choiceButtons.style.display = 'none';
            if (choiceBadge) choiceBadge.style.display = 'none';
          }
          
          // Update action buttons visibility
          const actionButtons = tube.cardElement.querySelectorAll('.action-btn');
          
          if (isCurrentPlayer) {
            // Show action buttons for current player
            actionButtons.forEach(btn => {
              btn.style.display = 'block';
              btn.style.pointerEvents = 'auto';
            });
            console.log(`üéØ Power button for slot ${i}: display=block, pointerEvents=auto`);
          } else {
            // Hide action buttons for other players
            actionButtons.forEach(btn => btn.style.display = 'none');
          }
          
          console.log(`üéØ Updated buttons for slot ${i}: isCurrentPlayer=${isCurrentPlayer}, hasChoice=${!!player.choice}`);
        }
      });
    }

    // ===== MISSING HELPER FUNCTIONS =====
    
    // Update round display
    function updateRoundDisplay() {
      // Update desktop round display
      const roundElement = document.getElementById('round-number');
      if (roundElement) {
        roundElement.textContent = currentRound;
      }
      
      // Update mobile round display
      const mobileRoundElement = document.getElementById('round-number-mobile');
      if (mobileRoundElement) {
        mobileRoundElement.textContent = currentRound;
      }
    }
    
    // Animate coin flip (visual only - for server-side physics)
    function animateCoinFlip(playerSlot, power, duration) {
      const tube = tubes[playerSlot];
      const coin = coins[playerSlot];
      
      if (!tube || !coin) return;
      
      // Visual animation only - no game logic
      const powerPercent = power / 100;
      const material = tube.selectedMaterial || coinMaterials[2]; // Default to glass
      const speedMult = material.speedMultiplier;
      const durationMult = material.durationMultiplier;
      
      const flipDuration = duration || (2000 + (powerPercent * 6000)) * durationMult;
      const basePowerSpeed = Math.max(0.08, 0.05 + (powerPercent * 0.25));
      const flipSpeed = basePowerSpeed * speedMult;
      
      console.log(`üé¨ Starting visual coin flip for slot ${playerSlot}: duration=${flipDuration}ms, speed=${flipSpeed}`);
      
      const startTime = Date.now();
      
      const animateFlip = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / flipDuration, 1);
        
        if (progress < 0.7) {
          // Fast spinning phase (first 70%)
          coin.rotation.x += flipSpeed;
        } else {
          // Deceleration phase (last 30%)
          const decelProgress = (progress - 0.7) / 0.3;
          const currentSpeed = flipSpeed * (1 - decelProgress);
          coin.rotation.x += currentSpeed;
        }
        
        if (progress < 1) {
          requestAnimationFrame(animateFlip);
        } else {
          // Animation complete - server will send actual result
          console.log(`üé¨ Visual flip animation complete for slot ${playerSlot}`);
        }
      };
      
      animateFlip();
    }

    // ===== AUDIO SYSTEM =====
    let isMuted = false;
    const glassBreakSound = new Audio('../Sound/glassclipped.mp3');
    glassBreakSound.volume = 0.7; // Adjust volume as needed
    
    const powerChargeSound = new Audio('../Sound/powerclipped.mp3');
    powerChargeSound.volume = 0.6; // Adjust volume as needed
    powerChargeSound.loop = true; // Loop while charging
    
    // Function to play sound with mute check
    function playSound(audio) {
      if (!isMuted && audio) {
        audio.currentTime = 0; // Reset to start
        audio.play().catch(err => console.log('Audio play prevented:', err));
      }
    }
    
    // Function to stop sound
    function stopSound(audio) {
      if (audio) {
        audio.pause();
        audio.currentTime = 0;
      }
    }
    
    // Function to toggle mute
    function toggleMute() {
      isMuted = !isMuted;
      console.log(`üîä Sound ${isMuted ? 'MUTED' : 'UNMUTED'}`);
      
      // Mute/unmute all audio elements
      glassBreakSound.muted = isMuted;
      powerChargeSound.muted = isMuted;
      
      return isMuted;
    }

    const COLORS = {
      cyan: 0x00ffff,
      neonGreen: 0x00ff00, // NEON GREEN
      brightGreen: 0x39ff14, // Bright neon green
      pink: 0xff1493,
      gold: 0xFFD700,
      glass: 0x88ccff
    };

    let players = [
      { id: 1, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 2, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 3, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 4, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true }
    ];

    // Coin options - MUST be defined before tubes are created
    const coinOptions = [
      { id: 'plain', name: 'Classic', headsImage: '/coins/plainh.png', tailsImage: '/coins/plaint.png', cost: 0, category: 'free' },
      { id: 'skull', name: 'Skull', headsImage: '/coins/skullh.png', tailsImage: '/coins/skullt.png', cost: 200, category: 'premium' },
      { id: 'trump', name: 'Trump', headsImage: '/coins/trumpheads.webp', tailsImage: '/coins/trumptails.webp', cost: 300, category: 'premium' },
      { id: 'mario', name: 'Mario', headsImage: '/coins/mario.png', tailsImage: '/coins/luigi.png', cost: 300, category: 'premium' },
      { id: 'stinger', name: 'Stinger', headsImage: '/coins/stingerh.png', tailsImage: '/coins/stingert.png', cost: 300, category: 'premium' },
      { id: 'dragon', name: 'Èæô', headsImage: '/coins/dragonh.png', tailsImage: '/coins/dragont.png', cost: 300, category: 'premium' },
      { id: 'jestress', name: 'Jestress', headsImage: '/coins/jestressh.png', tailsImage: '/coins/jestresst.png', cost: 500, category: 'epic' },
      { id: 'manga', name: 'Heroine', headsImage: '/coins/mangah.png', tailsImage: '/coins/mangat.png', cost: 500, category: 'epic' },
      { id: 'pharaoh', name: 'Pharaoh', headsImage: '/coins/pharaohh.png', tailsImage: '/coins/pharaoht.png', cost: 1000, category: 'legendary' },
      { id: 'calavera', name: 'Calavera', headsImage: '/coins/calaverah.png', tailsImage: '/coins/calaverat.png', cost: 1000, category: 'legendary' }
    ];

    // Coin material options with physics properties - MUST be defined before tubes are created
    const coinMaterials = [
      {
        id: 'graphite',
        name: 'Graphite',
        description: 'Ultra-Light & Swift',
        edgeColor: '#1a1a1a',
        speedMultiplier: 2.0,
        durationMultiplier: 0.5,
        characteristics: 'Ultra-fast flips, chaotic motion'
      },
      {
        id: 'penny',
        name: 'Penny',
        description: 'Lightweight & Fast',
        edgeColor: '#CD7F32',
        speedMultiplier: 1.5,
        durationMultiplier: 0.7,
        characteristics: 'Fast flips, unpredictable'
      },
      {
        id: 'glass',
        name: 'Glass',
        description: 'Crystal Clear & Elegant',
        edgeColor: '#87CEEB',
        speedMultiplier: 1.3,
        durationMultiplier: 0.8,
        characteristics: 'Smooth, elegant flips'
      },
      {
        id: 'silver-dollar',
        name: 'Silver Dollar',
        description: 'Heavy & Controlled',
        edgeColor: '#C0C0C0',
        speedMultiplier: 0.7,
        durationMultiplier: 1.3,
        characteristics: 'Slow, controlled, predictable'
      },
      {
        id: 'titanium',
        name: 'Titanium',
        description: 'Ultra-Heavy & Precise',
        edgeColor: '#2D1B69',
        speedMultiplier: 0.5,
        durationMultiplier: 1.6,
        characteristics: 'Very slow, precise flips'
      }
    ];

    // Game state
    let currentRound = 1;
    // SERVER-AUTHORITATIVE: Timer comes from server only
    let roundCounterElement = null;
    let timerElement = null;
    // SERVER-AUTHORITATIVE: Auto-flip is now handled by the server
    let gameOver = false;
    let roundStartWins = []; // Track wins at start of each round

    // LocalStorage persistence with expiry
    function saveGameState() {
      if (!gameIdParam || !walletParam) return;
      
      const gameState = {
        gameId: gameIdParam,
        playerSlot: playerSlot,
        currentRound: currentRound,
        playerWins: players[playerSlot]?.wins || 0,
        playerChoice: players[playerSlot]?.choice || null,
        selectedCoin: tubes[playerSlot]?.selectedCoin?.id || 'plain',
        selectedMaterial: tubes[playerSlot]?.selectedMaterial?.id || 'graphite',
        timestamp: Date.now(),
        expiresAt: Date.now() + (30 * 60 * 1000) // 30 minutes
      };
      
      const storageKey = `game_${gameIdParam}_${walletParam}`;
      localStorage.setItem(storageKey, JSON.stringify(gameState));
      console.log('üíæ Game state saved to localStorage:', gameState);
    }

    function loadGameState() {
      if (!gameIdParam || !walletParam) return null;
      
      const storageKey = `game_${gameIdParam}_${walletParam}`;
      const savedData = localStorage.getItem(storageKey);
      
      if (!savedData) {
        console.log('üìÇ No saved game state found');
        return null;
      }
      
      try {
        const gameState = JSON.parse(savedData);
        
        // Check if expired
        if (Date.now() > gameState.expiresAt) {
          console.log('‚è∞ Saved game state expired, clearing...');
          localStorage.removeItem(storageKey);
          return null;
        }
        
        console.log('‚úÖ Loaded game state from localStorage:', gameState);
        return gameState;
      } catch (err) {
        console.error('‚ùå Failed to parse saved game state:', err);
        localStorage.removeItem(storageKey);
        return null;
      }
    }

    // Color Management - ENABLED for proper emissive glow
    THREE.ColorManagement.enabled = true;
    
    // Scene
    const scene = new THREE.Scene();
    scene.background = null; // Transparent to show CSS background image
    
    // ===== ADD BACKGROUND IMAGE AS TEXTURED PLANE (1920x1080) =====
    const bgTextureLoader = new THREE.TextureLoader();
    const bgCandidates = roomParam === 'lab' 
      ? ['/images/background/thelab.png']
      : roomParam === 'cyber'
      ? ['/images/background/cyber.png']
      : roomParam === 'mech'
      ? ['/images/background/mech.png']
      : ['/images/background/game room2.png'];
    function loadBackground(paths, onSuccess, onFail) {
      if (!paths.length) { onFail && onFail(new Error('No background paths worked')); return; }
      const path = paths[0];
      bgTextureLoader.load(path, onSuccess, undefined, () => loadBackground(paths.slice(1), onSuccess, onFail));
    }
    loadBackground(bgCandidates, (bgTexture) => {
      // Keep texture in sRGB color space - don't convert
      bgTexture.colorSpace = THREE.SRGBColorSpace;
      bgTexture.minFilter = THREE.LinearFilter;
      bgTexture.magFilter = THREE.LinearFilter;
      
      // Calculate correct plane size based on camera FOV and distance
      // Camera: FOV=30¬∞, position z=1400, background z=-500
      const distanceFromCamera = 1400 - (-500); // 1900 units
      const vFOV = camera.fov * Math.PI / 180; // Convert to radians
      const planeHeight = 2 * Math.tan(vFOV / 2) * distanceFromCamera;
      const planeWidth = planeHeight * camera.aspect; // Match screen aspect ratio
      
      // Create plane with calculated dimensions
      const bgGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: bgTexture,
        side: THREE.FrontSide,
        depthWrite: false, // Don't write to depth buffer
        depthTest: false, // Always render behind
        toneMapped: false, // CRITICAL: Don't apply tone mapping to background!
        fog: false, // Not affected by fog
        color: 0xcccccc // Slightly darkened (80% brightness) - adjust this if needed
      });
      const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
      bgPlane.position.set(0, 150, -500); // Behind the tubes
      bgPlane.renderOrder = -1; // Render first (behind everything)
      bgPlane.layers.set(0); // Layer 0 - main scene
      scene.add(bgPlane);
      scene.background = null; // Remove fallback color now that we have the texture
      console.log(`üñºÔ∏è Background image loaded! Size: ${planeWidth.toFixed(0)}x${planeHeight.toFixed(0)} at distance ${distanceFromCamera}`);
    }, undefined, (error) => {
      console.error('‚ùå Failed to load background image:', error);
    });

    // Camera - FLATTER VIEW
    const width = window.innerWidth;
    const height = window.innerHeight;
    const camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000); // Narrower FOV
    camera.position.set(0, 150, 1400); // Higher camera position
    camera.lookAt(0, 150, 0); // Look at raised tubes
    camera.layers.enable(0); // Default layer - tubes, coins, etc.
    camera.layers.enable(1); // Bloom layer - pearls and plasma
    console.log('üì∑ Camera positioned for shorter tubes with dual-layer support');

    // WebGL Renderer
    const webglRenderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: true // Enable transparency for video background
    });
    webglRenderer.setSize(width, height);
    webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    webglRenderer.setClearColor(0x000000, 0); // Transparent clear color
    webglRenderer.autoClear = true;
    webglRenderer.toneMapping = THREE.ACESFilmicToneMapping; // Filmic tone mapping for vibrant colors
    webglRenderer.toneMappingExposure = 1.0; // Neutral exposure - don't brighten anything
    webglRenderer.outputColorSpace = THREE.SRGBColorSpace; // Proper color space
    console.log('üé® WebGL Renderer initialized with transparency');
    document.getElementById('container').appendChild(webglRenderer.domElement);
    
    // TEST 1: Make canvas semi-transparent to see if background shows through
    webglRenderer.domElement.style.opacity = "0.5"; // Make it semi-transparent to see if background shows through

    // ===== SELECTIVE BLOOM SETUP - Layer 1 (pearls) only! =====
    
    // Create bloom render target for layer 1 (pearls + plasma)
    const bloomRenderTarget = new THREE.WebGLRenderTarget(width, height, {
      type: THREE.HalfFloatType,
      format: THREE.RGBAFormat,
      colorSpace: THREE.SRGBColorSpace,
      stencilBuffer: false,
      depthBuffer: true
    });
    
    // Bloom composer - renders ONLY layer 1
    const bloomComposer = new EffectComposer(webglRenderer, bloomRenderTarget);
    
    // Render pass for layer 1 only (pearls + plasma)
    const bloomRenderPass = new RenderPass(scene, camera);
    bloomRenderPass.clear = true;
    bloomRenderPass.clearColor = new THREE.Color(0, 0, 0);
    bloomRenderPass.clearAlpha = 0; // Clear to transparent black
    bloomComposer.addPass(bloomRenderPass);
    
    // Bloom effect - ULTRA CRISP neon glow with minimal blur!
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(width, height),
      1.0,  // Strength - increased for better visibility
      0.3,  // Radius - slightly increased for better glow
      0.1   // Threshold - VERY LOW to catch all pearl emission
    );
    bloomPass.renderToScreen = false; // DON'T render to screen - keep in buffer!
    bloomComposer.addPass(bloomPass);
    
    bloomComposer.renderToScreen = false; // Keep result in render target!
    
    console.log('‚ú® Selective bloom composer created for layer 1 (pearls)!');
    
    // ===== ADDITIVE BLEND SHADER - Composites bloomed pearls on top =====
    const AdditiveBlendShader = {
      uniforms: {
        baseTexture: { value: null },
        bloomTexture: { value: null }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D baseTexture;
        uniform sampler2D bloomTexture;
        varying vec2 vUv;
        void main() {
          vec4 base = texture2D(baseTexture, vUv);
          vec4 bloom = texture2D(bloomTexture, vUv);
          // Additive blending - add bloom on top
          gl_FragColor = base + bloom;
        }
      `
    };
    
    console.log('üé® Additive blend shader created for compositing!');

    // CSS3D Renderer
    const cssRenderer = new CSS3DRenderer();
    cssRenderer.setSize(width, height);
    cssRenderer.domElement.style.position = 'absolute';
    cssRenderer.domElement.style.top = '0';
    cssRenderer.domElement.style.pointerEvents = 'auto';
    document.getElementById('container').appendChild(cssRenderer.domElement);

    // ===== LEAVE GAME BUTTON =====
    const leaveBtn = document.createElement('button');
    leaveBtn.textContent = 'Leave Game';
    leaveBtn.style.cssText = `
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10001;
      padding: 10px 14px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 1px;
      color: #fff;
      background: linear-gradient(135deg, #ff4444, #cc0000);
      border: 2px solid #ff4444;
      border-radius: 10px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
      display: none;
    `;
    leaveBtn.addEventListener('mouseenter', () => {
      leaveBtn.style.transform = 'translateY(-2px)';
      leaveBtn.style.boxShadow = '0 8px 18px rgba(255, 68, 68, 0.6)';
    });
    leaveBtn.addEventListener('mouseleave', () => {
      leaveBtn.style.transform = 'translateY(0)';
      leaveBtn.style.boxShadow = '0 0 15px rgba(255, 68, 68, 0.5)';
    });
    leaveBtn.onclick = () => {
      const confirmLeave = confirm('Leave game? You may forfeit if the match is active.');
      if (!confirmLeave) return;
      const lobbyUrl = gameIdParam ? `/battle-royale/${gameIdParam}` : '/';
      window.location.href = lobbyUrl;
    };
    document.body.appendChild(leaveBtn);

    // XP Counter for current player
    let currentPlayerXP = 0;
    const xpCounter = document.createElement('div');
    xpCounter.id = 'xp-counter';
    xpCounter.style.cssText = `
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10001;
      padding: 12px 18px;
      background: #0a0f2e;
      border: 2px solid #00ff88;
      border-radius: 12px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 14px;
      color: #00ff88;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      backdrop-filter: blur(10px);
      pointer-events: auto;
    `;
      xpCounter.innerHTML = `
        <div style="font-size: 12px; color: #ffffff; opacity: 0.8; margin-bottom: 4px;">Total Earnings</div>
        <div style="font-size: 18px; margin-bottom: 2px;">${currentPlayerXP} FLIP</div>
        <div style="font-size: 10px; color: #ffffff; opacity: 0.8;">This Game</div>
      `;
    document.body.appendChild(xpCounter);

    // Create separate change coin box - positioned beside earnings box
    const changeCoinBox = document.createElement('div');
    changeCoinBox.id = 'change-coin-box';
    changeCoinBox.style.cssText = `
      position: fixed;
      top: 20px;
      right: 240px;
      width: 160px;
      height: 50px;
      padding: 0;
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      border: 4px solid #ff8f00;
      border-radius: 12px;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 0 20px rgba(255, 235, 59, 0.6);
      backdrop-filter: blur(10px);
      pointer-events: auto;
      z-index: 1000;
    `;
    changeCoinBox.innerHTML = `
      <button id="global-change-coin-btn" style="
        width: 100%;
        height: 100%;
        padding: 0;
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        border: 4px solid #ff8f00;
        border-radius: 8px;
        color: #6a1b9a;
        font-family: 'Orbitron', sans-serif;
        font-weight: 900;
        font-size: 16px;
        cursor: pointer;
        box-shadow: 0 0 15px rgba(255, 235, 59, 0.6);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 25px rgba(255, 235, 59, 0.8)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 15px rgba(255, 235, 59, 0.6)'">CHANGE COIN</button>
    `;
    document.body.appendChild(changeCoinBox);

    // Add global change coin button handler
    setTimeout(() => {
      const globalChangeCoinBtn = document.getElementById('global-change-coin-btn');
      if (globalChangeCoinBtn) {
        globalChangeCoinBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('üé® Global change coin button clicked');
          
          // Try to find current player slot
          let currentPlayerSlot = playerSlot;
          
          // Fallback: search for current player if playerSlot is not set
          if (currentPlayerSlot === undefined || currentPlayerSlot < 0) {
            currentPlayerSlot = players.findIndex(p => p.address === walletParam);
            console.log(`üîç Fallback search found player slot: ${currentPlayerSlot}`);
          }
          
          if (currentPlayerSlot !== undefined && currentPlayerSlot >= 0) {
            console.log(`üé® Opening coin selector for player slot ${currentPlayerSlot}`);
            showCoinSelector(currentPlayerSlot);
          } else {
            console.log('‚ùå Player slot not found for coin selection. PlayerSlot:', playerSlot, 'WalletParam:', walletParam);
            console.log('Available players:', players.map((p, i) => ({ slot: i, address: p.address, name: p.name })));
          }
        });
      }
    }, 100);

    // Function to update XP counter
    function updateXPCounter(amount) {
      currentPlayerXP += amount;
      const xpDisplay = xpCounter.querySelectorAll('div')[1]; // Second div contains the FLIP amount
      xpDisplay.textContent = `${currentPlayerXP} FLIP`;
      
      // Update mobile displays
      if (isMobile()) {
        updateMobileDisplays();
      }
      
      // Add a subtle glow effect when XP increases
      xpCounter.style.boxShadow = '0 0 30px rgba(0, 255, 136, 0.6)';
      setTimeout(() => {
        xpCounter.style.boxShadow = '0 0 20px rgba(0, 255, 136, 0.3)';
      }, 500);
    }

    // Function to show floating messages
    function showFloatingMessage(message, color, duration = 3000) {
      const floatingMsg = document.createElement('div');
      floatingMsg.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: ${color};
        padding: 15px 25px;
        border-radius: 12px;
        border: 2px solid ${color};
        font-family: 'Orbitron', sans-serif;
        font-size: 18px;
        font-weight: bold;
        z-index: 10000;
        text-align: center;
        box-shadow: 0 0 40px ${color}99;
        pointer-events: none;
        animation: floatIn 0.5s ease-out;
      `;
      
      floatingMsg.textContent = message;
      document.body.appendChild(floatingMsg);
      
      // Add CSS animation if not already added
      if (!document.getElementById('floating-animations')) {
        const style = document.createElement('style');
        style.id = 'floating-animations';
        style.textContent = `
          @keyframes floatIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          }
        `;
        document.head.appendChild(style);
      }
      
      setTimeout(() => {
        floatingMsg.style.animation = 'floatIn 0.5s ease-out reverse';
        setTimeout(() => {
          if (floatingMsg.parentNode) {
            floatingMsg.parentNode.removeChild(floatingMsg);
          }
        }, 500);
      }, duration);
    }

    // Global variables for collection UI
    let currentCollectionId = null;
    let collectionExpiryTimer = null;

    // Function to show collection UI
    function showCollectionUI(collectionId, totalFlip, gameResult, expiresAt) {
      currentCollectionId = collectionId;
      
      // Create collection overlay
      const overlay = document.createElement('div');
      overlay.id = 'collection-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.5s ease-out;
      `;

      // Create collection box
      const collectionBox = document.createElement('div');
      collectionBox.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 3px solid ${gameResult === 'won' ? '#FFD700' : '#00ff00'};
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 0 50px ${gameResult === 'won' ? '#FFD700' : '#00ff00'}99;
        animation: scaleIn 0.5s ease-out;
      `;

      const title = gameResult === 'won' ? 'üèÜ VICTORY!' : 'üí∞ Game Complete';
      const titleColor = gameResult === 'won' ? '#FFD700' : '#00ff00';
      
      collectionBox.innerHTML = `
        <h2 style="color: ${titleColor}; margin: 0 0 20px 0; font-size: 28px;">${title}</h2>
        <div style="font-size: 24px; margin: 20px 0; color: #FFD700;">
          üíé ${totalFlip} FLIP Tokens Earned
        </div>
        <div style="font-size: 14px; color: #888; margin: 20px 0;">
          ‚è∞ Collect within 24 hours or they expire!
        </div>
        <div style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
          <button id="collect-flip-btn" style="
            background: linear-gradient(45deg, #00ff00, #00cc00);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
          ">üíé Claim FLIP</button>
          ${gameResult === 'won' ? `
          <button id="claim-nft-btn" style="
            background: linear-gradient(45deg, #ff0088, #cc0066);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
          ">üèÜ Claim NFT</button>
          ` : ''}
        </div>
        <div style="font-size: 12px; color: #666; margin-top: 15px;">
          Collection expires: ${new Date(expiresAt).toLocaleString()}
        </div>
      `;

      overlay.appendChild(collectionBox);
      document.body.appendChild(overlay);

      // Add button hover effects
      const collectBtn = document.getElementById('collect-flip-btn');
      const claimNftBtn = document.getElementById('claim-nft-btn');
      
      collectBtn.addEventListener('mouseenter', () => {
        collectBtn.style.transform = 'scale(1.05)';
        collectBtn.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.6)';
      });
      collectBtn.addEventListener('mouseleave', () => {
        collectBtn.style.transform = 'scale(1)';
        collectBtn.style.boxShadow = 'none';
      });

      if (claimNftBtn) {
        claimNftBtn.addEventListener('mouseenter', () => {
          claimNftBtn.style.transform = 'scale(1.05)';
          claimNftBtn.style.boxShadow = '0 0 20px rgba(255, 0, 136, 0.6)';
        });
        claimNftBtn.addEventListener('mouseleave', () => {
          claimNftBtn.style.transform = 'scale(1)';
          claimNftBtn.style.boxShadow = 'none';
        });
      }

      // Add event listeners
      collectBtn.addEventListener('click', () => {
        if (isServerSideMode && socket && gameIdParam && walletParam) {
          socket.emit('collect_flip_tokens', {
            collectionId: collectionId,
            address: walletParam
          });
        }
      });

      if (claimNftBtn) {
        claimNftBtn.addEventListener('click', () => {
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('claim_nft', {
              collectionId: collectionId,
              address: walletParam
            });
          }
        });
      }

      // Set expiry timer
      const expiryTime = new Date(expiresAt).getTime() - Date.now();
      if (expiryTime > 0) {
        collectionExpiryTimer = setTimeout(() => {
          showFloatingMessage('‚è∞ Collection expired!', '#ff4444', 3000);
          hideCollectionUI();
        }, expiryTime);
      }

      // Add CSS animations if not already added
      if (!document.getElementById('collection-animations')) {
        const style = document.createElement('style');
        style.id = 'collection-animations';
        style.textContent = `
          @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
          }
          @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
          }
        `;
        document.head.appendChild(style);
      }
    }

    // Function to hide collection UI
    function hideCollectionUI() {
      const overlay = document.getElementById('collection-overlay');
      if (overlay) {
        overlay.style.animation = 'fadeIn 0.5s ease-out reverse';
        setTimeout(() => {
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        }, 500);
      }
      
      currentCollectionId = null;
      if (collectionExpiryTimer) {
        clearTimeout(collectionExpiryTimer);
        collectionExpiryTimer = null;
      }
    }

    // Lighting - Very low ambient to protect background from any indirect brightening
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Minimal ambient
    scene.add(ambientLight);

    const topLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced
    topLight.position.set(0, 600, 400);
    scene.add(topLight);

    const leftAccent = new THREE.PointLight(COLORS.cyan, 1, 1500); // Reduced
    leftAccent.position.set(-800, 200, 400);
    scene.add(leftAccent);

    const rightAccent = new THREE.PointLight(COLORS.pink, 1, 1500); // Reduced
    rightAccent.position.set(800, 200, 400);
    scene.add(rightAccent);

    // Front light - illuminates the tubes from camera position
    const frontLight = new THREE.DirectionalLight(0xffffff, 1.0); // Good brightness for tubes
    frontLight.position.set(0, 200, 1200); // From camera position
    frontLight.target.position.set(0, 200, 0); // Pointing at tubes
    scene.add(frontLight);
    scene.add(frontLight.target);

    // Create tubes
    const NUM_TUBES = 4;
    const TUBE_RADIUS = 80;
    const TUBE_HEIGHT = 350; // Shorter tubes
    const SPACING = 350;

    // Calculate tube positions
    const totalWidth = SPACING * (NUM_TUBES - 1);
    const startX = -totalWidth / 2;

    // ===== LOAD BRASS/METALLIC TEXTURES =====
    const textureLoader = new THREE.TextureLoader();
    const brassColorMap = textureLoader.load('/Images/textures/Brass/textures/rusty_metal_04_diff_4k.jpg');
    const brassDisplacementMap = textureLoader.load('/Images/textures/Brass/textures/rusty_metal_04_disp_4k.png');
    
    brassColorMap.wrapS = THREE.RepeatWrapping;
    brassColorMap.wrapT = THREE.RepeatWrapping;
    brassColorMap.repeat.set(2, 2);
    
    brassDisplacementMap.wrapS = THREE.RepeatWrapping;
    brassDisplacementMap.wrapT = THREE.RepeatWrapping;
    brassDisplacementMap.repeat.set(2, 2);

    console.log('üé® Brass metallic textures loaded');

    // ===== CREATE SHARED ALPHA MAP FOR GLASS CUTOUT (ONE FOR ALL TUBES) =====
    const tubeAlphaCanvas = document.createElement('canvas');
    tubeAlphaCanvas.width = 512;
    tubeAlphaCanvas.height = 512;
    const tubeAlphaCtx = tubeAlphaCanvas.getContext('2d');
    
    // Fill with white (visible glass)
    tubeAlphaCtx.fillStyle = 'white';
    tubeAlphaCtx.fillRect(0, 0, 512, 512);
    
    // Create rectangular cutout with rounded corners (centered on front, where coin is)
    tubeAlphaCtx.globalCompositeOperation = 'destination-out';
    tubeAlphaCtx.fillStyle = 'black';
    
    // Rectangle dimensions (full height of glass, centered horizontally)
    const rectWidth = 200;
    const rectHeight = 440; // Full height of tube
    const rectX = 256 - rectWidth / 2;
    const rectY = 36; // Start near top
    const cornerRadius = 30; // Larger rounded corners
    
    // Draw rounded rectangle cutout
    tubeAlphaCtx.beginPath();
    tubeAlphaCtx.moveTo(rectX + cornerRadius, rectY);
    tubeAlphaCtx.lineTo(rectX + rectWidth - cornerRadius, rectY);
    tubeAlphaCtx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + cornerRadius);
    tubeAlphaCtx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerRadius);
    tubeAlphaCtx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - cornerRadius, rectY + rectHeight);
    tubeAlphaCtx.lineTo(rectX + cornerRadius, rectY + rectHeight);
    tubeAlphaCtx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - cornerRadius);
    tubeAlphaCtx.lineTo(rectX, rectY + cornerRadius);
    tubeAlphaCtx.quadraticCurveTo(rectX, rectY, rectX + cornerRadius, rectY);
    tubeAlphaCtx.closePath();
    tubeAlphaCtx.fill();
    
    const tubeAlphaTexture = new THREE.CanvasTexture(tubeAlphaCanvas);
    tubeAlphaTexture.wrapS = THREE.RepeatWrapping;
    tubeAlphaTexture.wrapT = THREE.ClampToEdgeWrapping;

    // ===== PHYSICS WORLD SETUP =====
    const physicsWorld = new CANNON.World({
      gravity: new CANNON.Vec3(0, -980, 0) // Gravity in cm/s^2
    });
    physicsWorld.defaultContactMaterial.friction = 0.1;
    physicsWorld.defaultContactMaterial.restitution = 0.3;

    console.log('‚öôÔ∏è Physics world created with gravity');

    // ===== ROOM-SPECIFIC TUBE STYLES =====
    function getTubeStyle(roomType) {
      if (roomType === 'lab') {
        return {
          // Lab tubes: More scientific/industrial look
          glassColor: 0x4a90e2, // Steel blue
          glassOpacity: 0.2,
          glassEmissive: 0x1a3a5c,
          glassEmissiveIntensity: 0.1,
          capColor: 0x8B4513, // Cork brown
          capMetalness: 0.1, // Low metalness for cork
          capRoughness: 0.8, // High roughness for cork texture
          rimColor: 0x00ff88, // Neon green (scientific)
          backingColor: 0x34495e, // Dark steel backing
          backingMetalness: 0.8,
          backingRoughness: 0.4,
          // Lab-specific geometry
          tubeShape: 'lab', // Different shape for lab tubes
          tubeRadius: TUBE_RADIUS * 0.8, // Slightly narrower
          tubeHeight: TUBE_HEIGHT * 1.1 // Slightly taller
        };
      } else if (roomType === 'cyber') {
        return {
          // Cyber Bay tubes: Futuristic/cyberpunk look
          glassColor: 0x00ffff, // Cyan glass
          glassOpacity: 0.25,
          glassEmissive: 0x004444,
          glassEmissiveIntensity: 0.2,
          capColor: 0xff6600, // Bright neon orange
          capMetalness: 0.3,
          capRoughness: 0.2,
          rimColor: 0xff6600, // Bright neon orange
          backingColor: 0x001122, // Dark cyber backing
          backingMetalness: 0.9,
          backingRoughness: 0.1,
          // Cyber-specific geometry
          tubeShape: 'cyber', // Different shape for cyber tubes
          tubeRadius: TUBE_RADIUS * 0.9, // Slightly narrower than potion
          tubeHeight: TUBE_HEIGHT * 1.05 // Slightly taller
        };
      } else if (roomType === 'mech') {
        return {
          // Mech Room tubes: Industrial/mechanical look
          glassColor: 0x666666, // Dark steel glass
          glassOpacity: 0.3,
          glassEmissive: 0x220000,
          glassEmissiveIntensity: 0.1,
          capColor: 0xff0000, // Bright red
          capMetalness: 0.8,
          capRoughness: 0.3,
          rimColor: 0xff0000, // Bright red
          backingColor: 0x222222, // Dark industrial backing
          backingMetalness: 0.9,
          backingRoughness: 0.2,
          // Mech-specific geometry
          tubeShape: 'mech', // Different shape for mech tubes
          tubeRadius: TUBE_RADIUS * 0.95, // Slightly narrower
          tubeHeight: TUBE_HEIGHT * 1.02 // Slightly taller
        };
      } else {
        // Default potion room style
        return {
          glassColor: 0xd0d0d0, // Bright silver
          glassOpacity: 0.15,
          glassEmissive: 0x505050,
          glassEmissiveIntensity: 0.15,
          capColor: 0xcd7f32, // Brass
          capMetalness: 0.98,
          capRoughness: 0.1,
          rimColor: 0xff8800, // Orange
          backingColor: 0xe0e0e0, // Chrome
          backingMetalness: 0.98,
          backingRoughness: 0.1,
          // Default geometry
          tubeShape: 'potion',
          tubeRadius: TUBE_RADIUS,
          tubeHeight: TUBE_HEIGHT
        };
      }
    }

    const tubeStyle = getTubeStyle(roomParam);
    console.log(`üé® Using ${roomParam} room tube style:`, tubeStyle);

    const tubes = [];
    const coins = [];

    for (let i = 0; i < NUM_TUBES; i++) {
      const x = startX + (i * SPACING);
      const player = players[i];

      // Glass tube - ROOM-SPECIFIC STYLING with RECTANGULAR CUTOUT around coin
      let tubeGeometry;
      if (tubeStyle.tubeShape === 'lab') {
        // Lab tubes: More circular/rounded shape with higher segment count
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius * 0.9, // Top slightly narrower
          tubeStyle.tubeRadius, // Bottom wider
          tubeStyle.tubeHeight, 
          128, // Double the segments for more circular look
          1, true
        );
      } else if (tubeStyle.tubeShape === 'cyber') {
        // Cyber tubes: Futuristic tapered shape
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius * 0.85, // Top narrower
          tubeStyle.tubeRadius * 1.05, // Bottom wider
          tubeStyle.tubeHeight, 
          128, // High segments for smooth look
          1, true
        );
      } else if (tubeStyle.tubeShape === 'mech') {
        // Mech tubes: Industrial straight cylinder with high segments
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius, 
          tubeStyle.tubeRadius, 
          tubeStyle.tubeHeight, 
          128, // High segments for industrial precision
          1, true
        );
      } else {
        // Potion tubes: Standard cylinder with more segments for circular look
        tubeGeometry = new THREE.CylinderGeometry(
          tubeStyle.tubeRadius, 
          tubeStyle.tubeRadius, 
          tubeStyle.tubeHeight, 
          128, // More segments for circular appearance
          1, true
        );
      }
      
      const glassMaterial = new THREE.MeshStandardMaterial({
        color: tubeStyle.glassColor,
        transparent: true,
        opacity: tubeStyle.glassOpacity,
        alphaMap: tubeAlphaTexture, // Apply shared rectangular cutout
        roughness: 0.2,
        metalness: 1.0, // Full metallic
        emissive: tubeStyle.glassEmissive,
        emissiveIntensity: tubeStyle.glassEmissiveIntensity,
        side: THREE.DoubleSide
      });
      const tube = new THREE.Mesh(tubeGeometry, glassMaterial);
      tube.position.set(x, 200, 0); // Move tubes higher up
      tube.rotation.y = Math.PI; // Rotate 180¬∞ so cutout faces camera
      scene.add(tube);

      // ===== ROOM-SPECIFIC BACKING PANEL - Creates contrast with background image =====
      const backingGeometry = new THREE.CylinderGeometry(
        tubeStyle.tubeRadius + 5, 
        tubeStyle.tubeRadius + 5, 
        tubeStyle.tubeHeight + 20, 
        32, 1, false
      );
      const backingMaterial = new THREE.MeshStandardMaterial({
        color: tubeStyle.backingColor,
        roughness: tubeStyle.backingRoughness,
        metalness: tubeStyle.backingMetalness,
        emissive: 0x404040,
        emissiveIntensity: 0.1,
        side: THREE.BackSide // Only visible from inside
      });
      const backing = new THREE.Mesh(backingGeometry, backingMaterial);
      backing.position.set(x, 200, -10); // Position slightly behind the tube
      scene.add(backing);

      // ===== ROOM-SPECIFIC CAPS (TOP & BOTTOM LIDS) - METALLIC =====
      const capMaterial = new THREE.MeshStandardMaterial({
        map: brassColorMap,
        displacementMap: brassDisplacementMap,
        displacementScale: 0.2,
        color: tubeStyle.capColor,
        metalness: tubeStyle.capMetalness,
        roughness: tubeStyle.capRoughness,
      });

      // Top cap with transparent circle cutout for coin viewing
      const capGeometry = new THREE.CylinderGeometry(
        tubeStyle.tubeRadius + 10, 
        tubeStyle.tubeRadius + 10, 
        15, 64
      );
      
      // Create alpha map with transparent circle
      const capCanvas = document.createElement('canvas');
      capCanvas.width = 256;
      capCanvas.height = 256;
      const capCtx = capCanvas.getContext('2d');
      
      // Fill with white (opaque brass)
      capCtx.fillStyle = 'white';
      capCtx.fillRect(0, 0, 256, 256);
      
      // Cut out transparent circle in center
      capCtx.globalCompositeOperation = 'destination-out';
      capCtx.fillStyle = 'black';
      capCtx.beginPath();
      capCtx.arc(128, 128, 60, 0, Math.PI * 2); // Circle cutout
      capCtx.fill();
      
      const capAlphaTexture = new THREE.CanvasTexture(capCanvas);
      
      const topCapMaterial = capMaterial.clone();
      topCapMaterial.alphaMap = capAlphaTexture;
      topCapMaterial.transparent = true;
      
      const topCap = new THREE.Mesh(capGeometry, topCapMaterial);
      topCap.position.set(x, 200 + (tubeStyle.tubeHeight / 2) + 7.5, 0);
      scene.add(topCap);

      // Bottom cap (solid room-specific metallic disc)
      const bottomCap = new THREE.Mesh(capGeometry, capMaterial.clone());
      bottomCap.position.set(x, 200 - (tubeStyle.tubeHeight / 2) - 7.5, 0);
      scene.add(bottomCap);

      // Decorative rims (ROOM-SPECIFIC COLOR - SMOOTH & GLOSSY)
      const rimGeometry = new THREE.TorusGeometry(tubeStyle.tubeRadius + 5, 8, 32, 64);
      const rimMaterial = new THREE.MeshStandardMaterial({
        color: tubeStyle.rimColor,
        metalness: 0.95,
        roughness: 0.1,
      });
      
      const topRim = new THREE.Mesh(rimGeometry, rimMaterial);
      topRim.position.set(x, 200 + tubeStyle.tubeHeight / 2, 0);
      topRim.rotation.x = Math.PI / 2;
      scene.add(topRim);

      const bottomRim = topRim.clone();
      bottomRim.position.y = 200 - tubeStyle.tubeHeight / 2;
      scene.add(bottomRim);

      // ===== PHYSICS-BASED LIQUID SYSTEM =====
      
      // Create glass container collision boundaries (SEALED CONTAINER)
      const glassBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        position: new CANNON.Vec3(x, 200, 0)
      });
      
      // SOLID BOTTOM CAP - thick box to seal bottom completely
      const bottomCapShape = new CANNON.Box(new CANNON.Vec3(tubeStyle.tubeRadius + 5, 20, tubeStyle.tubeRadius + 5));
      const bottomCapOffset = new CANNON.Vec3(0, -(tubeStyle.tubeHeight / 2) - 15, 0);
      glassBody.addShape(bottomCapShape, bottomCapOffset);
      
      // SOLID TOP CAP - VERY THICK box to seal top completely (prevents all escape!)
      const topCapShape = new CANNON.Box(new CANNON.Vec3(tubeStyle.tubeRadius + 5, 30, tubeStyle.tubeRadius + 5));
      const topCapOffset = new CANNON.Vec3(0, (tubeStyle.tubeHeight / 2) + 20, 0);
      glassBody.addShape(topCapShape, topCapOffset);
      
      // Cylindrical walls - 16 segments for smooth circular containment
      const numWalls = 16;
      const wallThickness = 3;
      for (let w = 0; w < numWalls; w++) {
        const angle = (w / numWalls) * Math.PI * 2;
        const wallX = Math.cos(angle) * (tubeStyle.tubeRadius - 6);
        const wallZ = Math.sin(angle) * (tubeStyle.tubeRadius - 6);
        
        const wallShape = new CANNON.Box(new CANNON.Vec3(wallThickness, (tubeStyle.tubeHeight - 10) / 2, wallThickness));
        const wallOffset = new CANNON.Vec3(wallX, 0, wallZ);
        glassBody.addShape(wallShape, wallOffset);
      }
      
      physicsWorld.addBody(glassBody);
      console.log(`‚öôÔ∏è Sealed physics container created for tube ${i + 1}`);

      // Create PEARL particles (glowing pink balls inside the tube)
      const liquidParticles = [];
      const liquidParticleMeshes = [];
      const particleRadius = 7; // Pearl-sized
      const maxLayers = 80; // Double the pearls for more dramatic effect
      const pRadius = particleRadius;
      
      // Start pearls at the bottom of the tube
      for (let p = 0; p < maxLayers; p++) {
        // Random position inside cylinder at bottom
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * (tubeStyle.tubeRadius - 25);
        const pearlX = x + Math.cos(angle) * radius;
        const pearlZ = Math.sin(angle) * radius;
        const pearlY = 200 - (tubeStyle.tubeHeight / 2) + 30 + Math.random() * 60; // Start at bottom
        
        // Create physics body - BOUNCY!
        const particleShape = new CANNON.Sphere(particleRadius);
        const particleBody = new CANNON.Body({
          mass: 0.3, // Lighter so they float easier
          position: new CANNON.Vec3(pearlX, pearlY, pearlZ),
          material: new CANNON.Material({ friction: 0.1, restitution: 0.8 }) // VERY BOUNCY!
        });
        particleBody.addShape(particleShape);
        particleBody.linearDamping = 0.6; // Less damping = more movement
        particleBody.angularDamping = 0.6;
        particleBody.collisionFilterGroup = 1;
        particleBody.collisionFilterMask = -1;
        
        // Add to physics world immediately
        physicsWorld.addBody(particleBody);
        
        // Create visual PEARL - starts neutral dark (will transition to tube's color)
        const particleGeometry = new THREE.SphereGeometry(particleRadius, 32, 32); // Higher segments for perfect sphere
        const particleMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x1a1a1a, // Neutral dark grey
          metalness: 0.0, // No metalness for pure emissive glow
          roughness: 0.3,
          transparent: true,
          opacity: 0.7, // More transparent to see video
          emissive: 0x0a0a0a, // Very faint neutral glow
          emissiveIntensity: 0.2,
          toneMapped: false, // Bypass tone mapping for maximum brightness!
          clearcoat: 1.0,
          clearcoatRoughness: 0.05
        });
        const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
        particleMesh.visible = true;
        particleMesh.layers.set(1); // LAYER 1 - For selective bloom!
        scene.add(particleMesh);
        
        liquidParticles.push(particleBody);
        liquidParticleMeshes.push(particleMesh);
      }

      // Visual liquid surface (smooth mesh - PRE-FILLED with darkish liquid)
      const liquidHeight = TUBE_HEIGHT - 20;
      const liquidGeometry = new THREE.CylinderGeometry(TUBE_RADIUS - 6, TUBE_RADIUS - 6, liquidHeight, 32, 32);
      const liquidMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x1a1a2e, // Dark blue-grey
        metalness: 0.05,
        roughness: 0.3,
        transparent: true,
        opacity: 0.25, // Much more transparent to see video through
        transmission: 0.6, // Higher transmission for see-through effect
        thickness: 1.5,
        clearcoat: 0.6,
        clearcoatRoughness: 0.05,
        emissive: 0x0a0a1a, // Very faint blue glow
        emissiveIntensity: 0.2,
        ior: 1.33,
        reflectivity: 0.3,
        envMapIntensity: 1.2,
        side: THREE.DoubleSide
      });
      const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
      const liquidY = 200 - (TUBE_HEIGHT / 2) + (liquidHeight / 2);
      liquid.position.set(x, liquidY, 0);
      liquid.scale.y = 1.0; // Pre-filled to 100%
      liquid.visible = true; // Visible from start
      scene.add(liquid);

      // Liquid light (starts very dim)
      const liquidLight = new THREE.PointLight(0x1a1a2e, 0.3, 400); // Dim blue-grey
      liquidLight.position.set(0, 0, 0);
      liquid.add(liquidLight);

      // Spotlight - illuminates each tube/cylinder nicely without affecting background
      const spotlight = new THREE.SpotLight(0xffffff, 0.7, 700, Math.PI / 6, 0.5, 2);
      spotlight.position.set(x, 200 + TUBE_HEIGHT / 2 + 300, 150);
      spotlight.target.position.set(x, 200, 0);
      scene.add(spotlight);
      scene.add(spotlight.target);

      // Platform (BRASS METALLIC BASE)
      const platformGeometry = new THREE.CylinderGeometry(TUBE_RADIUS + 20, TUBE_RADIUS + 20, 15, 32);
      const platformMaterial = new THREE.MeshStandardMaterial({
        map: brassColorMap,
        displacementMap: brassDisplacementMap,
        displacementScale: 0.2,
        metalness: 0.98,
        roughness: 0.1,
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.set(x, 200 - (TUBE_HEIGHT / 2) - 30, 0);
      scene.add(platform);

      // Gold coin (centered in tube) - with HEADS and TAILS textures
      const coinRadius = 65; // 30% larger (was 50)
      const coinThickness = 16; // Scaled proportionally
      const coinGeometry = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);
      const textureLoader = new THREE.TextureLoader();
      
      // Load default coin textures (will be replaced by default selection logic below)
      const headsTexture = textureLoader.load('/coins/plainh.png'); // Temporary placeholder
      const tailsTexture = textureLoader.load('/coins/plaint.png'); // Temporary placeholder
      
      headsTexture.minFilter = THREE.LinearFilter;
      headsTexture.magFilter = THREE.LinearFilter;
      headsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
      headsTexture.generateMipmaps = false;
      
      tailsTexture.minFilter = THREE.LinearFilter;
      tailsTexture.magFilter = THREE.LinearFilter;
      tailsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
      tailsTexture.generateMipmaps = false;
      
      // Custom shader that outputs RAW texture colors (no gamma, no processing)
      const rawTextureShader = {
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D map;
          varying vec2 vUv;
          void main() {
            gl_FragColor = texture2D(map, vUv);
          }
        `
      };
      
      // Create materials using RAW shader (bypasses ALL THREE.js color processing)
      const coinMaterials = [
        new THREE.MeshStandardMaterial({ 
          color: 0xFFD700,
          emissive: 0xFFD700,
          emissiveIntensity: 0.3,
          metalness: 0.8,
          roughness: 0.2,
          side: THREE.DoubleSide,
          transparent: false
        }), // Side - glowing gold
        new THREE.ShaderMaterial({
          uniforms: { 
            map: { value: headsTexture }
          },
          vertexShader: rawTextureShader.vertexShader,
          fragmentShader: rawTextureShader.fragmentShader,
          side: THREE.DoubleSide,
          depthWrite: true,
          depthTest: true,
          transparent: false
        }), // Top (heads) - RAW texture pixels
        new THREE.ShaderMaterial({
          uniforms: { 
            map: { value: tailsTexture }
          },
          vertexShader: rawTextureShader.vertexShader,
          fragmentShader: rawTextureShader.fragmentShader,
          side: THREE.DoubleSide,
          depthWrite: true,
          depthTest: true,
          transparent: false
        })  // Bottom (tails) - RAW texture pixels
      ];
      
      const coin = new THREE.Mesh(coinGeometry, coinMaterials);
      coin.rotation.x = Math.PI / 2; // Standing on edge (90 degrees)
      coin.rotation.y = Math.PI / 2; // Rotated 90 degrees left for proper facing
      coin.rotation.z = 0; // No tilt
      coin.position.set(x, 200, 0); // Centered in tube
      coin.visible = true; // Explicitly set visible
      coin.frustumCulled = false; // Never cull from view - always render
      coin.renderOrder = 1; // Render after background but before UI
      coin.layers.set(0); // Main rendering layer
      coin.matrixAutoUpdate = true; // Ensure matrix updates
      
      // Force materials to update on next render
      coin.material.forEach(mat => {
        if (mat.needsUpdate !== undefined) mat.needsUpdate = true;
      });
      
      scene.add(coin);

      // Diffused dark navy shadow backdrop (hidden initially, shows after glass breaks)
      const shadowGeometry = new THREE.CircleGeometry(coinRadius * 1.5, 64);
      
      // Create gradient shadow with custom shader for soft diffusion
      const shadowMaterial = new THREE.ShaderMaterial({
        transparent: true,
        side: THREE.DoubleSide,
        uniforms: {
          centerColor: { value: new THREE.Color(0x0a0a2e) }, // Dark navy
          edgeColor: { value: new THREE.Color(0x000000) }, // Black at edges
          opacity: { value: 0.85 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 centerColor;
          uniform vec3 edgeColor;
          uniform float opacity;
          varying vec2 vUv;
          void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(vUv, center);
            float gradient = smoothstep(0.0, 0.5, dist);
            vec3 color = mix(centerColor, edgeColor, gradient);
            float alpha = opacity * (1.0 - smoothstep(0.3, 0.5, dist));
            gl_FragColor = vec4(color, alpha);
          }
        `
      });
      
      const coinShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
      coinShadow.position.set(x, 200, -8); // Behind coin, slightly further back
      coinShadow.visible = false; // Hidden initially
      scene.add(coinShadow);

      coins.push(coin);

      // Player card (CSS3D)
      const cardElement = document.createElement('div');
      cardElement.className = 'player-card';
      
      // Initially hide buttons - they will be shown when player slot is determined
      let showButtons = false;
      if (!isServerSideMode) {
        // Fallback for local mode
        showButtons = !player.isEmpty;
      }
      // In server-side mode, buttons will be shown via updatePlayerCardButtons() when playerSlot is set
      
      console.log(`üéØ Initial Player ${i + 1} button logic (DEBUGGING MODE):`, {
        playerAddress: player.address,
        isEmpty: player.isEmpty,
        showButtons: showButtons
      });
      
      // Create empty slot overlay for empty players
      const emptySlotOverlay = player.isEmpty ? `
        <div class="empty-slot-overlay" style="
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(255, 20, 147, 0.8);
          border-radius: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 48px;
          font-weight: bold;
          color: white;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
          z-index: 10;
        ">‚úï</div>
      ` : '';
      
      cardElement.innerHTML = `
        ${emptySlotOverlay}
        <div class="card-header">
          <img src="${player.isEmpty ? '/images/potion.png' : (player.avatar || '/images/default-avatar.png')}" class="player-avatar" alt="${player.name}" style="width: 80px; height: 100px;" />
          <div class="player-info">
            <div class="player-name">${player.name}</div>
            <div class="wins-display" style="display: flex; gap: 8px; margin-top: 8px; justify-content: center; align-items: center;">
              <span class="trophy-symbol">üèÜ</span>
              <span style="color: #ffd700; font-size: 18px; font-weight: bold;">${player.wins}</span>
            </div>
          </div>
        </div>
        ${player.choice ? `
          <div class="choice-badge ${player.choice}" style="display: ${player.choice ? 'block' : 'none'};">
            ${player.choice.toUpperCase()}
          </div>
        ` : ''}
        <div class="choice-buttons" style="display: ${showButtons && !player.choice ? 'block' : 'none'};">
          <button class="choice-btn heads">HEADS</button>
          <button class="choice-btn tails">TAILS</button>
        </div>
        <div style="margin: 15px 0;">
          <div style="height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; margin-bottom: 8px;">
            <div class="power-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #00ff00, #39ff14); border-radius: 10px; transition: width 0.1s;"></div>
          </div>
          <div class="power-text" style="color: #00ff00; font-size: 14px; text-align: center;">POWER: 0%</div>
        </div>
        <button class="action-btn" style="display: ${showButtons ? 'block' : 'none'};">CHARGE POWER</button>
      `;

      cardElement.style.pointerEvents = 'auto';
      
      // Add choice button handlers (always add, visibility controlled by CSS)
      const choiceButtons = cardElement.querySelectorAll('.choice-btn');
      choiceButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          const choice = button.classList.contains('heads') ? 'heads' : 'tails';
          
          // Add visual feedback - highlight the selected button
          choiceButtons.forEach(btn => {
            btn.style.opacity = '0.5';
            btn.style.transform = 'scale(0.95)';
          });
          button.style.opacity = '1';
          button.style.transform = 'scale(1.1)';
          button.style.boxShadow = '0 0 25px rgba(255, 255, 255, 0.8)';
          
          // Update local player choice immediately
          players[i].choice = choice;
          console.log(`üéØ Local choice set for player ${i + 1}: ${choice}`);
          updateCoinRotationsFromPlayerChoices();
          saveGameState(); // ‚Üê ADD THIS
          
          // Update local UI immediately
          const choiceBadge = cardElement.querySelector('.choice-badge');
          const choiceButtonsContainer = cardElement.querySelector('.choice-buttons');
          if (choiceButtonsContainer && choiceBadge) {
            choiceButtonsContainer.style.display = 'none';
            choiceBadge.style.display = 'inline-block';
            choiceBadge.textContent = choice.toUpperCase();
            choiceBadge.className = `choice-badge ${choice}`;
          }
          
          // Update coin rotation locally
          updateCoinRotationsFromPlayerChoices();
          
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            // Send choice to server (will broadcast to other players)
            socket.emit('physics_set_choice', {
              gameId: gameIdParam,
              address: walletParam,
              choice: choice
            });
            console.log(`üéØ Sent choice to server: ${choice}`);
          }
          
          // Update button visibility after choice is made
          updatePlayerCardButtons();
        });
      });


      // Add power charge button handler (HOLD TO CHARGE) - always add, visibility controlled by CSS
      const flipButtons = cardElement.querySelectorAll('.action-btn');
      const powerButton = flipButtons[0]; // The first action button (CHARGE POWER)
      const powerBar = cardElement.querySelector('.power-bar');
      
      if (powerButton) {
        const powerText = cardElement.querySelector('.power-text');
        powerButton.style.pointerEvents = 'auto';
        
        let isCharging = false;
        
        powerButton.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          console.log(`üñ±Ô∏è Power button mousedown for player ${i + 1}`);
          
          
          // Prevent charging if player hasn't chosen heads or tails
          if (!players[i].choice) {
            showChoiceRequiredMessage(i);
            console.log(`‚ùå Player ${i + 1} must choose heads or tails first!`);
            return;
          }
          
          // Prevent charging if already used this round
          if (tubes[i].hasUsedPower) {
            console.log(`‚ùå Player ${i + 1} already used power this round`);
            return;
          }
          
          console.log(`‚ö° Charging power for tube ${i + 1}`);
          isCharging = true;
          tubes[i].isFilling = true;
          tubes[i].power = 0;
          tubes[i].chargingStartTime = Date.now(); // Track start time for sync
          
          // Play power charging sound
          playSound(powerChargeSound);
          
          // üéØ NEW: INSTANT BROADCAST - Tell everyone charging started
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_start', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: i,
              power: 0,  // ‚ö° ADD THIS
              isFilling: true  // ‚ö° ADD THIS
            });
            console.log(`üì¢ Broadcast: Player ${i + 1} started charging`);
          }
        });
        
        powerButton.addEventListener('mouseup', (e) => {
          e.stopPropagation();
          const finalPower = tubes[i].power;
          console.log(`‚ö° Power released at ${finalPower.toFixed(0)}%`);
          isCharging = false;
          tubes[i].isFilling = false;
          
          // Stop power charging sound
          stopSound(powerChargeSound);
          
          // üéØ NEW: INSTANT BROADCAST - Tell everyone charging stopped
          if (isServerSideMode && socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_stop', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: i,
              finalPower: finalPower
            });
            console.log(`üì¢ Broadcast: Player ${i + 1} stopped charging at ${finalPower}%`);
          }
          
          // Shatter glass and flip coin (minimum 5% power to prevent instant flips)
          if (finalPower >= 5) {
            // Server-side physics: Send flip request to server
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              // Get player choice from the card
              const playerChoice = players[i].choice;
              
              // Send flip request to server (server will broadcast glass shatter to all)
              socket.emit('physics_flip_coin', {
                gameId: gameIdParam,
                address: walletParam,
                power: finalPower,
                angle: 0 // Default angle for now
              });
              
              console.log(`ü™ô Sent flip request to server: power=${finalPower}, choice=${playerChoice}`);
            } else {
              // Fallback to local physics (for testing)
              shatterGlass(i, finalPower);
              const playerChoice = players[i].choice;
              flipCoinWithPower(i, finalPower, playerChoice);
            }
            
            // Disable button after use
            powerButton.disabled = true;
            powerButton.style.opacity = '0.5';
            powerButton.style.cursor = 'not-allowed';
            powerButton.style.background = '#cccccc';
            powerButton.style.color = '#666666';
            powerButton.style.borderColor = '#999999';
            tubes[i].hasUsedPower = true;
          }
        });
        
        powerButton.addEventListener('mouseleave', (e) => {
          if (isCharging) {
            const finalPower = tubes[i].power;
            console.log(`‚ö° Power released at ${finalPower.toFixed(0)}%`);
            
            // Stop power charging sound
            stopSound(powerChargeSound);
            
            // üéØ NEW: INSTANT BROADCAST - Tell everyone charging stopped
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              socket.emit('physics_power_charging_stop', {
                gameId: gameIdParam,
                address: walletParam,
                playerSlot: i,
                finalPower: finalPower
              });
              console.log(`üì¢ Broadcast: Player ${i + 1} stopped charging (mouseleave) at ${finalPower}%`);
            }
            
            // Shatter glass and flip coin (minimum 5% power)
            if (finalPower >= 5) {
              // Server-side physics: Send flip request to server
              if (isServerSideMode && socket && gameIdParam && walletParam) {
                // Get player choice from the card
                const playerChoice = players[i].choice;
                
                // Send flip request to server (server will broadcast glass shatter to all)
                socket.emit('physics_flip_coin', {
                  gameId: gameIdParam,
                  address: walletParam,
                  power: finalPower,
                  angle: 0 // Default angle for now
                });
                
                console.log(`ü™ô Sent flip request to server (mouseleave): power=${finalPower}, choice=${playerChoice}`);
              } else {
                // Fallback to local physics (for testing)
                shatterGlass(i, finalPower);
                const playerChoice = players[i].choice;
                flipCoinWithPower(i, finalPower, playerChoice);
              }
              
              // Disable button after use
              powerButton.disabled = true;
              powerButton.style.opacity = '0.5';
              powerButton.style.cursor = 'not-allowed';
              powerButton.style.background = '#cccccc';
              powerButton.style.color = '#666666';
              powerButton.style.borderColor = '#999999';
              tubes[i].hasUsedPower = true;
            }
          }
          isCharging = false;
          tubes[i].isFilling = false;
        });
        
      }

      const cssObject = new CSS3DObject(cardElement);
      // Position cards BELOW the tubes
      cssObject.position.set(x, 200 - (TUBE_HEIGHT / 2) - 140, 0);
      cssObject.scale.set(0.6, 0.45, 0.6); // Wider, less tall
      scene.add(cssObject);

      // Auto-apply default selections to fix coin picker gradient issue
      const defaultCoin = coinOptions[0]; // Classic coin
      const defaultMaterial = coinMaterials[0]; // Graphite material
      
      // Load and apply the default coin textures (heads and tails)
      textureLoader.load(defaultCoin.headsImage, (headsTex) => {
        headsTex.minFilter = THREE.LinearFilter;
        headsTex.magFilter = THREE.LinearFilter;
        headsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
        headsTex.generateMipmaps = false;
        
        textureLoader.load(defaultCoin.tailsImage, (tailsTex) => {
          tailsTex.minFilter = THREE.LinearFilter;
          tailsTex.magFilter = THREE.LinearFilter;
          tailsTex.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
          tailsTex.generateMipmaps = false;
          
          // Update both textures
          coin.material[1].uniforms.map.value = headsTex;
          coin.material[1].needsUpdate = true;
          coin.material[2].uniforms.map.value = tailsTex;
          coin.material[2].needsUpdate = true;
          coin.visible = true;
          
          console.log(`‚úÖ Applied default ${defaultCoin.name} textures to ${player.name}'s coin`);
        });
      });
      
      // Update coin edge color based on default material
      const edgeColor = new THREE.Color(defaultMaterial.edgeColor);
      coin.material[0].color.copy(edgeColor);
      coin.material[0].emissive.copy(edgeColor);
      coin.material[0].emissiveIntensity = 0.3;
      coin.material[0].needsUpdate = true;
      
      console.log(`‚úÖ Applied default ${defaultCoin.name} with ${defaultMaterial.name} material to ${player.name}'s coin`);

      tubes.push({ 
        tube, backing, topRim, bottomRim, liquid, liquidLight, spotlight, platform, coin,
        coinShadow, // Dark backdrop for coin visibility
        liquidParticles, // Physics bodies (pearls)
        liquidParticleMeshes, // Visual meshes
        glassBody, // Container collision
        cardElement, // Store card element for power bar updates
        powerButton, // Store power button for enable/disable
        particleRadius: pRadius, // Store particle size
        liquidBaseY: liquidY,
        liquidBaseHeight: liquidHeight,
        isFilling: false,
        power: 0, // Power level (0-100)
        isShattered: false, // Glass shattered state
        isFlipping: false, // Coin flip state
        glassShards: [], // Will hold glass shards when shattered
        winLight: null, // Win glow light
        loseLight: null, // Lose glow light
        resultBox: null, // Result text CSS3D object
        foamIntensity: 0, // Bubbling/frothing intensity (0-1)
        hasUsedPower: false, // Track if player has used their turn
        selectedCoin: defaultCoin, // Default to Classic coin
        selectedMaterial: defaultMaterial // Default to Graphite material
      });
    }

    // ===== SHADER PRE-WARMING (Prevent first-charge freeze) =====
    console.log('üî• Warming up pearl shaders...');
    tubes.forEach((tube, i) => {
      // Minimal power update to trigger shader compilation
      tube.power = 1;
      tube.foamIntensity = 0.01;
      updatePearlColors(tube, 0.01, i);
    });
    
    // Reset after warmup
    setTimeout(() => {
      tubes.forEach((tube, i) => {
        tube.power = 0;
        tube.foamIntensity = 0;
        updatePearlColors(tube, 0, i);
      });
      console.log('‚úÖ Shader warmup complete');
    }, 100);

    // ===== COIN TEXTURES ALREADY APPLIED DURING CREATION =====
    console.log('üéÆ Game started - coin textures already applied during tube creation');

    // ===== CREATE GAME INFO CONTAINER (Round + Timer + Controls) =====
    const gameInfoDiv = document.createElement('div');
    gameInfoDiv.className = 'game-info';
    gameInfoDiv.style.cssText = `
      width: 200px;
      background: rgba(10, 15, 35, 0.95);
      border: 3px solid #9d00ff;
      border-radius: 16px;
      padding: 15px;
      font-family: 'Orbitron', sans-serif;
      color: white;
      box-shadow: 0 0 30px rgba(157, 0, 255, 0.6);
      pointer-events: auto;
      text-align: center;
    `;
    
    gameInfoDiv.innerHTML = `
      <!-- Desktop: Original stacked layout -->
      <div class="desktop-timer-layout">
        <!-- Round Counter -->
        <div style="
          font-size: 18px;
          font-weight: bold;
          color: #00ffff;
          text-transform: uppercase;
          letter-spacing: 2px;
          margin-bottom: 10px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">ROUND <span id="round-number">1</span></div>
        
        <!-- Timer Display -->
        <div style="
          font-size: 50px;
          font-weight: bold;
          color: #00ff00;
          margin: 5px 0;
          font-family: 'Orbitron', monospace;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        " id="timer-display">30</div>
        <div style="
          font-size: 12px;
          color: #888;
          text-transform: uppercase;
          letter-spacing: 2px;
          margin-bottom: 10px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">SECONDS</div>
      </div>
      
      <!-- Mobile: Single line format -->
      <div class="mobile-timer-round" style="display: none;">
        <span class="round-text">Round <span id="round-number-mobile">1</span>:</span>
        <span class="timer-text"><span id="timer-display-mobile">30</span> Seconds</span>
      </div>
      
      <!-- Control Buttons Column -->
      <div style="
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 10px;
      ">
        <!-- Mute Button -->
        <button id="mute-btn" style="
          width: 100%;
          padding: 8px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          border: 2px solid #9d00ff;
          border-radius: 8px;
          color: white;
          font-weight: bold;
          font-size: 13px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-transform: uppercase;
          letter-spacing: 1px;
          box-shadow: 0 0 15px rgba(157, 0, 255, 0.4);
        ">üîä MUTE</button>
        
        <!-- Chat Button -->
        <button id="chat-btn" style="
          width: 100%;
          padding: 8px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          border: 2px solid #9d00ff;
          border-radius: 8px;
          color: white;
          font-weight: bold;
          font-size: 13px;
          cursor: pointer;
          transition: all 0.3s ease;
          text-transform: uppercase;
          letter-spacing: 1px;
          box-shadow: 0 0 15px rgba(157, 0, 255, 0.4);
        ">üí¨ CHAT</button>
      </div>
    `;
    
    const gameInfoObject = new CSS3DObject(gameInfoDiv);
    gameInfoObject.position.set(0, 200 - (TUBE_HEIGHT / 2) - 160, 0);
    gameInfoObject.scale.set(0.5, 0.5, 0.5);
    scene.add(gameInfoObject);

    // Get element references
    roundCounterElement = gameInfoDiv;
    timerElement = gameInfoDiv;
    const timerDisplay = gameInfoDiv.querySelector('#timer-display');
    const muteBtn = gameInfoDiv.querySelector('#mute-btn');
    const chatBtn = gameInfoDiv.querySelector('#chat-btn');

    // Add hover effects to buttons
    [muteBtn, chatBtn].forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.transform = 'translateY(-2px)';
        btn.style.boxShadow = '0 5px 20px rgba(157, 0, 255, 0.8)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.transform = 'translateY(0)';
        btn.style.boxShadow = '0 0 15px rgba(157, 0, 255, 0.4)';
      });
    });

    // Mute button handler
    muteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const muted = toggleMute();
      
      // Update button text and style
      if (muted) {
        muteBtn.textContent = 'üîá UNMUTE';
        muteBtn.style.background = 'linear-gradient(135deg, #666666, #888888)';
        muteBtn.style.borderColor = '#666666';
      } else {
        muteBtn.textContent = 'üîä MUTE';
        muteBtn.style.background = 'linear-gradient(135deg, #9d00ff, #c44aff)';
        muteBtn.style.borderColor = '#9d00ff';
      }
    });

    chatBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (!gameIdParam) {
        alert('Chat unavailable: missing gameId');
        return;
      }
      // Build overlay
      const overlay = document.createElement('div');
      
      // Check if mobile
      const isMobile = window.innerWidth <= 768;
      
      if (isMobile) {
        // Mobile chat box - smaller and positioned to fit on screen
        overlay.style.cssText = `
          position: fixed;
          right: 10px;
          bottom: 10px;
          width: calc(100vw - 20px);
          max-width: 280px;
          height: 300px;
          max-height: calc(100vh - 20px);
          background: rgba(10, 15, 35, 0.98);
          border: 2px solid #9d00ff;
          border-radius: 12px;
          z-index: 10002;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        `;
      } else {
        // Desktop chat box - original size
        overlay.style.cssText = `
          position: fixed;
          right: 20px;
          bottom: 20px;
          width: 320px;
          height: 420px;
          background: rgba(10, 15, 35, 0.98);
          border: 2px solid #9d00ff;
          border-radius: 12px;
          z-index: 10002;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        `;
      }
      const header = document.createElement('div');
      if (isMobile) {
        // Mobile header - smaller padding and font
        header.style.cssText = `
          padding: 8px 10px; color: #fff; font-weight: bold; font-size: 14px;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          display: flex; align-items: center; justify-content: space-between;
        `;
      } else {
        // Desktop header - original styling
        header.style.cssText = `
          padding: 10px 12px; color: #fff; font-weight: bold;
          background: linear-gradient(135deg, #9d00ff, #c44aff);
          display: flex; align-items: center; justify-content: space-between;
        `;
      }
      header.innerHTML = `<span>Lobby Chat</span><button style="all: unset; cursor: pointer; font-weight: bold;">‚úñ</button>`;
      const closeBtn = header.querySelector('button');
      closeBtn.onclick = () => overlay.remove();
      const list = document.createElement('div');
      if (isMobile) {
        // Mobile list - smaller padding
        list.style.cssText = `flex: 1; overflow-y: auto; padding: 8px; display: flex; flex-direction: column; gap: 6px;`;
      } else {
        // Desktop list - original padding
        list.style.cssText = `flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px;`;
      }
      
      const inputRow = document.createElement('div');
      if (isMobile) {
        // Mobile input row - smaller padding and gap
        inputRow.style.cssText = `display: flex; gap: 4px; padding: 6px; background: rgba(255,255,255,0.05);`;
      } else {
        // Desktop input row - original styling
        inputRow.style.cssText = `display: flex; gap: 6px; padding: 8px; background: rgba(255,255,255,0.05);`;
      }
      
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Type message (read-only for now)';
      input.disabled = true;
      if (isMobile) {
        // Mobile input - smaller padding and font
        input.style.cssText = `flex:1; background: rgba(0,0,0,0.4); border: 1px solid #444; color: #fff; padding: 6px; border-radius: 6px; font-size: 14px;`;
      } else {
        // Desktop input - original styling
        input.style.cssText = `flex:1; background: rgba(0,0,0,0.4); border: 1px solid #444; color: #fff; padding: 8px; border-radius: 8px;`;
      }
      
      const sendBtn = document.createElement('button');
      sendBtn.textContent = 'Send';
      sendBtn.disabled = true;
      if (isMobile) {
        // Mobile send button - smaller padding and font
        sendBtn.style.cssText = `padding: 6px 8px; color: #000; background: #ccc; border-radius: 6px; border: none; cursor: not-allowed; font-size: 12px;`;
      } else {
        // Desktop send button - original styling
        sendBtn.style.cssText = `padding: 8px 10px; color: #000; background: #ccc; border-radius: 8px; border: none; cursor: not-allowed;`;
      }
      inputRow.appendChild(input);
      inputRow.appendChild(sendBtn);
      overlay.appendChild(header);
      overlay.appendChild(list);
      overlay.appendChild(inputRow);
      document.body.appendChild(overlay);

      try {
        const res = await fetch(`/api/chat/${encodeURIComponent(gameIdParam)}?limit=50`);
        if (res.ok) {
          const data = await res.json();
          const messages = data.messages || [];
          messages.forEach(m => {
            const row = document.createElement('div');
            row.style.cssText = `background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px; color:#fff;`;
            const name = m.username || (m.address ? m.address.slice(0,6)+'...'+m.address.slice(-4) : 'User');
            const content = m.message || '';
            row.innerHTML = `<div style="font-weight:bold; color:#9d00ff;">${name}</div><div style="font-size: 0.9rem;">${content}</div>`;
            list.appendChild(row);
          });
          list.scrollTop = list.scrollHeight;
        } else {
          const row = document.createElement('div');
          row.style.cssText = `padding:8px; color:#fff;`;
          row.textContent = 'Failed to load chat history';
          list.appendChild(row);
        }
      } catch (err) {
        const row = document.createElement('div');
        row.style.cssText = `padding:8px; color:#fff;`;
        row.textContent = 'Error loading chat history';
        list.appendChild(row);
      }
    });

    // ===== SERVER-AUTHORITATIVE: NO CLIENT TIMER FUNCTIONS =====
    // All timer management is handled by the server

    function updateTimerDisplay(serverTime) {
      // Pure display - server is single source of truth
      if (timerElement) {
        // Update desktop timer
        const timerDisplay = timerElement.querySelector('#timer-display');
        if (timerDisplay) {
          timerDisplay.textContent = serverTime;
          
          // Change color based on time remaining
          if (serverTime <= 5) {
            timerDisplay.style.color = '#ff0000';
          } else if (serverTime <= 10) {
            timerDisplay.style.color = '#ffaa00';
          } else {
            timerDisplay.style.color = '#00ff00';
          }
        }
        
        // Update mobile timer
        const mobileTimerDisplay = timerElement.querySelector('#timer-display-mobile');
        if (mobileTimerDisplay) {
          mobileTimerDisplay.textContent = serverTime;
          
          // Change color based on time remaining
          if (serverTime <= 5) {
            mobileTimerDisplay.style.color = '#ff0000';
          } else if (serverTime <= 10) {
            mobileTimerDisplay.style.color = '#ffaa00';
          } else {
            mobileTimerDisplay.style.color = '#00ff00';
          }
        }
      }
      
      // Update mobile displays
      if (isMobile()) {
        updateMobileDisplays();
      }
    }

    // SERVER-AUTHORITATIVE: Auto-flip is handled by the server

    // SERVER-AUTHORITATIVE: Round progression managed by server

    // Coin selector modal
    function showCoinSelector(tubeIndex) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 20px;
      `;

      const content = document.createElement('div');
      content.style.cssText = `
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #FFD700;
        border-radius: 15px;
        padding: 40px 50px;
        width: 95%;
        max-width: 1600px;
        max-height: 85vh;
        overflow-y: auto;
      `;

      // Get current player's flip balance and unlocked coins (placeholder for now)
      let playerFlipBalance = 0; // Will be fetched from server
      let unlockedCoins = ['plain']; // Will be fetched from server
      let customCoinHeads = null;
      let customCoinTails = null;

      // Fetch player data from server
      if (isServerSideMode && socket && walletParam) {
        console.log('üîç Fetching profile for wallet:', walletParam);
        
        // Remove any existing listener to avoid duplicates
        socket.off('player_profile_data');
        
        // Set up listener for profile data
        socket.on('player_profile_data', (profileData) => {
          console.log('üìä Received profile data:', profileData);
          playerFlipBalance = profileData.flip_balance || 0;
          unlockedCoins = JSON.parse(profileData.unlocked_coins || '["plain"]');
          customCoinHeads = profileData.custom_coin_heads;
          customCoinTails = profileData.custom_coin_tails;
          console.log('üí∞ Updated FLIP balance:', playerFlipBalance);
          console.log('üîì Updated unlocked coins:', unlockedCoins);
          updateCoinDisplay();
        });
        
        // Request profile
        socket.emit('get_player_profile', { address: walletParam });
      } else {
        console.log('‚ö†Ô∏è Cannot fetch profile - missing:', {
          isServerSideMode,
          hasSocket: !!socket,
          walletParam
        });
      }

      function updateCoinDisplay() {
        const coinGrid = content.querySelector('.coin-grid');
        if (!coinGrid) return;

        // Update FLIP balance display
        const flipBalanceElement = document.getElementById('flip-balance');
        if (flipBalanceElement) {
          flipBalanceElement.textContent = playerFlipBalance;
        }

        coinGrid.innerHTML = `
          ${coinOptions.map(coin => {
            const isUnlocked = unlockedCoins.includes(coin.id);
            const canAfford = playerFlipBalance >= coin.cost;
            const isLocked = !isUnlocked && coin.cost > 0;
            
            let borderColor = 'rgba(255, 215, 0, 0.25)';
            let backgroundColor = 'rgba(255, 215, 0, 0.08)';
            let opacity = '1';
            let cursor = 'pointer';
            
            if (isLocked) {
              borderColor = 'rgba(255, 0, 0, 0.5)';
              backgroundColor = 'rgba(255, 0, 0, 0.1)';
              opacity = '0.6';
              cursor = canAfford ? 'pointer' : 'not-allowed';
            }
            
            return `
              <div class="coin-option" data-coin-id="${coin.id}" data-cost="${coin.cost}" data-unlocked="${isUnlocked}" style="
                background: ${backgroundColor};
                border: 2px solid ${borderColor};
                border-radius: 12px;
                padding: 15px;
                text-align: center;
                cursor: ${cursor};
                transition: all 0.3s ease;
                opacity: ${opacity};
                position: relative;
              ">
                ${isLocked ? `
                  <div style="position: absolute; top: 5px; right: 5px; background: rgba(255, 0, 0, 0.8); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">üîí</div>
                ` : ''}
                <img src="${coin.headsImage}" style="width: 65px; height: 65px; object-fit: contain; margin-bottom: 8px; display: block; margin-left: auto; margin-right: auto;" />
                <div style="color: #FFD700; font-weight: bold; font-family: 'Orbitron', sans-serif; font-size: 0.85rem; margin-bottom: 4px;">${coin.name}</div>
                ${coin.cost > 0 ? `
                  <div style="color: ${isUnlocked ? '#00ff00' : canAfford ? '#FFD700' : '#ff4444'}; font-size: 0.75rem; font-weight: bold;">
                    ${isUnlocked ? 'UNLOCKED' : `${coin.cost} FLIP`}
                  </div>
                ` : '<div style="color: #00ff00; font-size: 0.75rem; font-weight: bold;">FREE</div>'}
              </div>
            `;
          }).join('')}
          
          <!-- Custom Coin Option -->
          ${customCoinHeads && customCoinTails ? `
            <div class="coin-option" data-coin-id="custom" data-cost="0" data-unlocked="true" style="
              background: rgba(255, 215, 0, 0.08);
              border: 2px solid rgba(255, 215, 0, 0.25);
              border-radius: 12px;
              padding: 15px;
              text-align: center;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
            ">
              <img src="${customCoinHeads}" style="width: 65px; height: 65px; object-fit: contain; margin-bottom: 8px; display: block; margin-left: auto; margin-right: auto;" />
              <div style="color: #FFD700; font-weight: bold; font-family: 'Orbitron', sans-serif; font-size: 0.85rem; margin-bottom: 4px;">Custom</div>
              <div style="color: #00ff00; font-size: 0.75rem; font-weight: bold;">YOURS</div>
            </div>
          ` : ''}
        `;
        
        // Re-attach event listeners
        attachCoinEventListeners();
      }

      content.innerHTML = `
        <h2 style="color: #FFD700; text-align: center; margin-bottom: 35px; font-family: 'Orbitron', sans-serif; font-size: 1.8rem;">Customize Your Coin</h2>
        
        <!-- Flip Balance Display -->
        <div style="text-align: center; margin-bottom: 30px; padding: 15px; background: rgba(255, 215, 0, 0.1); border-radius: 10px; border: 1px solid rgba(255, 215, 0, 0.3);">
          <div style="color: #FFD700; font-family: 'Orbitron', sans-serif; font-size: 1.2rem; font-weight: bold;">
            Your FLIP Balance: <span id="flip-balance">Loading...</span>
          </div>
        </div>
        
        <!-- Coin Design Section -->
        <h3 style="color: #FFD700; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; font-size: 1.2rem;">Coin Design</h3>
        <div class="coin-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 15px; margin-bottom: 40px;">
          <!-- Coins will be populated here -->
        </div>
        
        <!-- Material Selection Section -->
        <div style="height: 1px; background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent); margin: 30px 0;"></div>
        <h3 style="color: #FFD700; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; font-size: 1.2rem;">Coin Material</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 30px;">
          ${coinMaterials.map(material => `
            <div class="material-option" data-material-id="${material.id}" style="
              background: rgba(255, 255, 255, 0.05);
              border: 2px solid rgba(255, 255, 255, 0.15);
              border-radius: 12px;
              padding: 18px;
              cursor: pointer;
              transition: all 0.3s ease;
              text-align: center;
            ">
              <div style="
                width: 55px;
                height: 55px;
                border-radius: 50%;
                margin: 0 auto 12px;
                border: 3px solid ${material.edgeColor};
                background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3), rgba(0,0,0,0.2));
                box-shadow: 0 0 15px ${material.edgeColor}60;
              "></div>
              <div style="color: #fff; font-weight: bold; font-size: 1rem; margin-bottom: 6px;">${material.name}</div>
              <div style="color: ${material.edgeColor}; font-size: 0.8rem; margin-bottom: 8px;">${material.description}</div>
              <div style="color: #fff; font-size: 0.7rem; opacity: 0.7; line-height: 1.4;">${material.characteristics}</div>
            </div>
          `).join('')}
        </div>
        
        <button class="close-btn" style="
          width: 100%;
          max-width: 400px;
          margin: 20px auto 0;
          padding: 16px;
          background: linear-gradient(135deg, #ff1493, #ff69b4);
          border: none;
          border-radius: 12px;
          color: white;
          font-weight: bold;
          cursor: pointer;
          font-family: 'Orbitron', sans-serif;
          font-size: 1rem;
          letter-spacing: 1px;
          display: block;
          box-shadow: 0 4px 15px rgba(255, 20, 147, 0.4);
          transition: all 0.3s ease;
        ">APPLY CHANGES</button>
      `;

      modal.appendChild(content);
      document.body.appendChild(modal);
      
      let selectedCoin = tubes[tubeIndex].selectedCoin || coinOptions[0];
      let selectedMaterial = tubes[tubeIndex].selectedMaterial || coinMaterials[0];
      
      // Force reset to Graphite if material is invalid
      if (!selectedMaterial || !selectedMaterial.id || selectedMaterial.id !== 'graphite') {
        selectedMaterial = coinMaterials[0];
        tubes[tubeIndex].selectedMaterial = selectedMaterial;
        console.log(`üîß Forced material reset to: ${selectedMaterial.name}`);
      }
      
      // Initial coin display
      updateCoinDisplay();
      
      function attachCoinEventListeners() {
        content.querySelectorAll('.coin-option').forEach(option => {
          // Use both click and touchstart for better mobile support
          const handleCoinSelection = (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const coinId = option.dataset.coinId;
            const cost = parseInt(option.dataset.cost);
            const isUnlocked = option.dataset.unlocked === 'true';
            
            console.log(`ü™ô Coin selection attempt: ${coinId}, unlocked: ${isUnlocked}, cost: ${cost}`);
            
            if (coinId === 'custom') {
              // Handle custom coin selection
              selectedCoin = {
                id: 'custom',
                name: 'Custom',
                headsImage: customCoinHeads,
                tailsImage: customCoinTails,
                cost: 0,
                category: 'custom'
              };
              console.log(`‚úÖ Custom coin selected`);
            } else {
              const coin = coinOptions.find(c => c.id === coinId);
              if (!coin) {
                console.log(`‚ùå Coin not found: ${coinId}`);
                return;
              }
              
              if (!isUnlocked && cost > 0) {
                // Try to unlock the coin
                if (playerFlipBalance >= cost) {
                  console.log(`üîì Unlocking ${coin.name} for ${cost} FLIP`);
                  
                  // Show loading state
                  const coinElement = content.querySelector(`[data-coin-id="${coinId}"]`);
                  if (coinElement) {
                    coinElement.style.opacity = '0.5';
                    coinElement.style.pointerEvents = 'none';
                  }
                  
                  // Send unlock request to server
                  if (isServerSideMode && socket && walletParam) {
                    console.log(`üîì Requesting unlock: ${coinId} for ${cost} FLIP`);
                    
                    // Remove any existing unlock listener
                    socket.off('coin_unlocked');
                    
                    // Set up response listener BEFORE sending request
                    socket.on('coin_unlocked', (result) => {
                      console.log('üì® Received unlock response:', result);
                      
                      if (result.success) {
                        console.log(`‚úÖ Server confirmed unlock: ${coin.name}`);
                        
                        // Update local state with server response
                        playerFlipBalance = result.newBalance;
                        unlockedCoins = result.unlockedCoins;
                        
                        // Update UI
                        const balanceElement = document.getElementById('flip-balance');
                        if (balanceElement) {
                          balanceElement.textContent = playerFlipBalance;
                        }
                        
                        updateCoinDisplay();
                        selectedCoin = coin;
                        updateCoinSelection();
                        
                        alert(`üéâ ${coin.name} unlocked for ${cost} FLIP!\n\nNew balance: ${playerFlipBalance} FLIP`);
                      } else {
                        console.error(`‚ùå Server unlock failed:`, result.error);
                        alert(`‚ùå Failed to unlock ${coin.name}:\n\n${result.error}`);
                        
                        // Restore coin element
                        if (coinElement) {
                          coinElement.style.opacity = '1';
                          coinElement.style.pointerEvents = 'auto';
                        }
                      }
                    });
                    
                    // Send unlock request
                    socket.emit('unlock_coin', {
                      address: walletParam,
                      coinId: coinId,
                      cost: cost
                    });
                  } else {
                    console.error('‚ùå Cannot unlock - connection issue:', {
                      isServerSideMode,
                      hasSocket: !!socket,
                      hasWallet: !!walletParam
                    });
                    alert(`‚ùå Cannot unlock coin: Server connection required`);
                    
                    // Restore coin element
                    if (coinElement) {
                      coinElement.style.opacity = '1';
                      coinElement.style.pointerEvents = 'auto';
                    }
                  }
                } else {
                  alert(`Not enough FLIP! You need ${cost} FLIP to unlock ${coin.name}.`);
                  return;
                }
              } else {
                selectedCoin = coin;
                console.log(`‚úÖ Coin selected: ${coin.name}`);
              }
            }
            
            // Always update selection visual feedback
            updateCoinSelection();
          };
          
          // Add both click and touchstart for mobile compatibility
          option.addEventListener('click', handleCoinSelection);
          option.addEventListener('touchstart', handleCoinSelection);
          
          // Hover effects
          option.addEventListener('mouseenter', () => {
            if (selectedCoin.id !== option.dataset.coinId) {
              option.style.transform = 'scale(1.05)';
            } else {
              option.style.transform = 'scale(1.1)';
            }
          });
          option.addEventListener('mouseleave', () => {
            if (selectedCoin.id !== option.dataset.coinId) {
              option.style.transform = 'scale(1)';
            } else {
              option.style.transform = 'scale(1.05)';
            }
          });
        });
      }
      
      function updateCoinSelection() {
        console.log(`üé® Updating coin selection visual feedback for: ${selectedCoin.id}`);
        
        // Reset all coin options first
        content.querySelectorAll('.coin-option').forEach(opt => {
          opt.style.background = opt.dataset.unlocked === 'true' ? 'rgba(255, 215, 0, 0.08)' : 'rgba(255, 0, 0, 0.1)';
          opt.style.borderColor = opt.dataset.unlocked === 'true' ? 'rgba(255, 215, 0, 0.25)' : 'rgba(255, 0, 0, 0.5)';
          opt.style.transform = 'scale(1)';
        });
        
        // Highlight the selected coin
        const selectedOption = content.querySelector(`[data-coin-id="${selectedCoin.id}"]`);
        if (selectedOption) {
          selectedOption.style.background = 'rgba(255, 215, 0, 0.4)';
          selectedOption.style.borderColor = '#FFD700';
          selectedOption.style.borderWidth = '3px';
          selectedOption.style.transform = 'scale(1.1)';
          selectedOption.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.6)';
          console.log(`‚úÖ Visual feedback applied to selected coin: ${selectedCoin.name}`);
        } else {
          console.log(`‚ùå Could not find selected coin option for ID: ${selectedCoin.id}`);
        }
      }
      
      // Material selection handlers with mobile support
      content.querySelectorAll('.material-option').forEach(option => {
        const handleMaterialSelection = (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const materialId = option.dataset.materialId;
          selectedMaterial = coinMaterials.find(m => m.id === materialId);
          
          console.log(`üîß Material selection attempt: ${materialId}`);
          
          if (selectedMaterial) {
            // Reset all material options
            content.querySelectorAll('.material-option').forEach(opt => {
              opt.style.background = 'rgba(255, 255, 255, 0.05)';
              opt.style.borderColor = 'rgba(255, 255, 255, 0.2)';
              opt.style.transform = 'scale(1)';
            });
            
            // Highlight selected material
            option.style.background = 'rgba(255, 215, 0, 0.2)';
            option.style.borderColor = '#FFD700';
            option.style.transform = 'scale(1.05)';
            
            console.log(`‚úÖ Material selected: ${selectedMaterial.name}`);
          } else {
            console.log(`‚ùå Material not found: ${materialId}`);
          }
        };
        
        // Add both click and touchstart for mobile compatibility
        option.addEventListener('click', handleMaterialSelection);
        option.addEventListener('touchstart', handleMaterialSelection);
        
        option.addEventListener('mouseenter', () => {
          if (selectedMaterial.id !== option.dataset.materialId) {
            option.style.background = 'rgba(255, 255, 255, 0.1)';
            option.style.transform = 'scale(1.05)';
          } else {
            option.style.background = 'rgba(255, 215, 0, 0.3)';
            option.style.transform = 'scale(1.1)';
          }
        });
        option.addEventListener('mouseleave', () => {
          if (selectedMaterial.id !== option.dataset.materialId) {
            option.style.background = 'rgba(255, 255, 255, 0.05)';
            option.style.transform = 'scale(1)';
          } else {
            option.style.background = 'rgba(255, 215, 0, 0.2)';
            option.style.transform = 'scale(1.05)';
          }
        });
      });
      
      // Apply button handler with mobile support
      const closeBtn = content.querySelector('.close-btn');
      
      // Hover effects (desktop only)
      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.transform = 'translateY(-2px)';
        closeBtn.style.boxShadow = '0 6px 20px rgba(255, 20, 147, 0.6)';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.transform = 'translateY(0)';
        closeBtn.style.boxShadow = '0 4px 15px rgba(255, 20, 147, 0.4)';
      });
      
      // Close button handler with mobile support
      const handleCloseButton = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('üî¥ APPLY CHANGES button clicked - closing modal');
        
        // Store selections in tube
        tubes[tubeIndex].selectedCoin = selectedCoin;
        tubes[tubeIndex].selectedMaterial = selectedMaterial;
        
        // Load both heads and tails textures
        const loader = new THREE.TextureLoader();
        loader.load(selectedCoin.headsImage, (headsTexture) => {
          headsTexture.minFilter = THREE.LinearFilter;
          headsTexture.magFilter = THREE.LinearFilter;
          headsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
          headsTexture.generateMipmaps = false;
          
          loader.load(selectedCoin.tailsImage, (tailsTexture) => {
            tailsTexture.minFilter = THREE.LinearFilter;
            tailsTexture.magFilter = THREE.LinearFilter;
            tailsTexture.anisotropy = webglRenderer.capabilities.getMaxAnisotropy();
            tailsTexture.generateMipmaps = false;
            
            // Update shader uniforms
            tubes[tubeIndex].coin.material[1].uniforms.map.value = headsTexture;
            tubes[tubeIndex].coin.material[1].needsUpdate = true;
            tubes[tubeIndex].coin.material[2].uniforms.map.value = tailsTexture;
            tubes[tubeIndex].coin.material[2].needsUpdate = true;
            
            // Update coin edge color based on material
            const edgeColor = new THREE.Color(selectedMaterial.edgeColor);
            tubes[tubeIndex].coin.material[0].color.copy(edgeColor);
            tubes[tubeIndex].coin.material[0].emissive.copy(edgeColor);
            tubes[tubeIndex].coin.material[0].emissiveIntensity = 0.3;
            tubes[tubeIndex].coin.material[0].needsUpdate = true;
            
            console.log(`‚úÖ Applied ${selectedCoin.name} with ${selectedMaterial.name} material to ${players[tubeIndex].name}'s coin`);
            
            // Send coin update to server
            if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === tubeIndex) {
              socket.emit('physics_update_coin', {
                gameId: gameIdParam,
                address: walletParam,
                coinData: {
                  id: selectedCoin.id,
                  type: selectedCoin.type,
                  name: selectedCoin.name,
                  headsImage: selectedCoin.headsImage,
                  tailsImage: selectedCoin.tailsImage,
                  material: selectedMaterial
                }
              });
              console.log(`üéØ Sent coin update to server: ${selectedCoin.name}`);
            }
          });
        });
        
        // Close the modal
        modal.remove();
      };
      
      // Add both click and touch events for mobile compatibility
      closeBtn.addEventListener('click', handleCloseButton);
      closeBtn.addEventListener('touchend', handleCloseButton);

      // Close on background click/touch - improved mobile support
      const handleModalClose = (e) => {
        console.log('üñ±Ô∏è Background click detected, target:', e.target, 'modal:', modal);
        if (e.target === modal) {
          console.log('‚úÖ Closing modal via background click');
          e.preventDefault();
          e.stopPropagation();
          modal.remove();
        }
      };
      
      // Add multiple event types for better mobile compatibility
      modal.addEventListener('click', handleModalClose);
      modal.addEventListener('touchend', handleModalClose);
      modal.addEventListener('touchstart', (e) => {
        // Prevent touchstart from interfering with content interactions
        if (e.target === modal) {
          e.preventDefault();
        }
      });
      
      // Prevent content clicks from closing modal
      content.addEventListener('click', (e) => {
        e.stopPropagation();
        console.log('üõ°Ô∏è Content click prevented from closing modal');
      });
      content.addEventListener('touchend', (e) => {
        e.stopPropagation();
        console.log('üõ°Ô∏è Content touch prevented from closing modal');
      });
    }

    // ===== GLASS SHATTERING FUNCTION (POWER-BASED) =====
    function shatterGlass(tubeIndex, powerLevel) {
      const tube = tubes[tubeIndex];
      if (tube.isShattered) return;
      
      const powerPercent = powerLevel / 100;
      console.log(`üí• Shattering glass for tube ${tubeIndex + 1} at ${powerLevel.toFixed(0)}% power`);
      
      // Stop power charging sound and play glass breaking sound
      stopSound(powerChargeSound);
      playSound(glassBreakSound);
      
      tube.isShattered = true;
      
      // Hide glass tube, backing, rims, and liquid surface
      tube.tube.visible = false;
      tube.backing.visible = false;
      tube.topRim.visible = false;
      tube.bottomRim.visible = false;
      tube.liquid.visible = false; // Hide the transparent liquid surface mesh
      
      // Show dark shadow behind coin for better visibility
      tube.coinShadow.visible = true;
      
      // REMOVE PHYSICS CONTAINER so particles can escape
      physicsWorld.removeBody(tube.glassBody);
      
      // Shard count scales with power (20-80 shards)
      const shardCount = Math.floor(20 + (powerPercent * 60));
      const tubeY = 200;
      
      for (let s = 0; s < shardCount; s++) {
        // Random triangle shard
        const size = Math.random() * 12 + 5;
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0, 0, 0,
          size, 0, 0,
          size * 0.5, size, 0
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        const material = new THREE.MeshStandardMaterial({
          color: 0xe0e0e0, // Bright silver
          metalness: 0.95, // Very metallic silver
          roughness: 0.1,
          emissive: 0xc0c0c0, // Silver glow
          emissiveIntensity: 0.4,
          side: THREE.DoubleSide
        });
        
        const shard = new THREE.Mesh(geometry, material);
        
        // Position along tube surface
        const angle = (s / shardCount) * Math.PI * 2;
        const heightPos = (Math.random() - 0.5) * TUBE_HEIGHT;
        shard.position.set(
          tube.tube.position.x + Math.cos(angle) * TUBE_RADIUS,
          tubeY + heightPos,
          Math.sin(angle) * TUBE_RADIUS
        );
        
        // Random rotation
        shard.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        // Explode velocity SCALES WITH POWER (2-14 units/frame)
        const baseSpeed = 2 + (powerPercent * 12);
        const velocity = {
          x: Math.cos(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5),
          y: Math.random() * 3 - 1.5,
          z: Math.sin(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5)
        };
        
        const rotVelocity = {
          x: (Math.random() - 0.5) * 0.3,
          y: (Math.random() - 0.5) * 0.3,
          z: (Math.random() - 0.5) * 0.3
        };
        
        scene.add(shard);
        
        tube.glassShards.push({
          mesh: shard,
          velocity,
          rotVelocity,
          lifetime: 0
        });
      }
      
      // EXPLODE LIQUID PARTICLES (FORCE SCALES WITH POWER)
      tube.liquidParticles.forEach((particleBody, idx) => {
        // Calculate outward direction
        const dx = particleBody.position.x - tube.tube.position.x;
        const dz = particleBody.position.z - tube.tube.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz) || 1;
        
        // Explosion force scales with power (2000-18000)
        const baseForce = 2000 + (powerPercent * 16000);
        const explosionForce = baseForce + Math.random() * (baseForce * 0.3);
        
        particleBody.velocity.set(
          (dx / distance) * explosionForce,
          Math.random() * 800 - 400,
          (dz / distance) * explosionForce
        );
        
        // Spinning scales with power
        const spinForce = 15 * powerPercent;
        particleBody.angularVelocity.set(
          Math.random() * spinForce * 2 - spinForce,
          Math.random() * spinForce * 2 - spinForce,
          Math.random() * spinForce * 2 - spinForce
        );
      });
      
      console.log(`üí• Glass shattered! ${shardCount} shards + ${tube.liquidParticles.length} liquid particles at ${powerLevel.toFixed(0)}% power`);
    }

    // ===== FLIP TOKEN REWARD SYSTEM =====
    const FLIP_REWARDS = [
      { amount: 50, color: '#ffffff', weight: 40 },      // White - Very common
      { amount: 100, color: '#87ceeb', weight: 25 },     // Sky blue - Common
      { amount: 250, color: '#ffff00', weight: 15 },     // Yellow - Uncommon
      { amount: 300, color: '#00ff00', weight: 10 },     // Green - Uncommon
      { amount: 500, color: '#ff8800', weight: 5 },      // Orange - Rare
      { amount: 750, color: '#9d00ff', weight: 3 },      // Purple - Very rare
      { amount: 1000, color: '#FFD700', weight: 2 }      // Gold - Extremely rare
    ];

    // Weighted random reward selection
    function getRandomFlipReward() {
      const totalWeight = FLIP_REWARDS.reduce((sum, r) => sum + r.weight, 0);
      let random = Math.random() * totalWeight;
      
      for (const reward of FLIP_REWARDS) {
        random -= reward.weight;
        if (random <= 0) {
          return reward;
        }
      }
      
      return FLIP_REWARDS[0]; // Fallback to 50
    }

    // Show FLIP reward animation as floating box above tube
    function showFlipReward(tubeIndex, serverReward = null) {
      const tube = tubes[tubeIndex];
      const player = players[tubeIndex];
      
      
      // Use server-provided reward if available, otherwise fallback to local generation
      const reward = serverReward || getRandomFlipReward();
      console.log(`üí∞ Player ${tubeIndex + 1} earned ${reward.amount} FLIP!`);
      
      // Award FLIP tokens to player via server
      if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === tubeIndex) {
        socket.emit('award_flip_tokens', {
          gameId: gameIdParam,
          address: walletParam,
          amount: reward.amount,
          reason: 'coin_flip_reward'
        });
        console.log(`üéØ Sent FLIP token award to server: ${reward.amount} tokens`);
        
        // Update XP counter for current player
        updateXPCounter(reward.amount);
      }
      
      // Create floating reward box styled like win/lose boxes
      const rewardBox = document.createElement('div');
      rewardBox.style.cssText = `
        width: 200px;
        padding: 12px 18px;
        background: #0a0f2e;
        border: 3px solid ${reward.color};
        border-radius: 12px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        box-shadow: 0 0 40px ${reward.color}99;
        pointer-events: none;
        transform: scaleY(-1);
        backdrop-filter: blur(10px);
      `;
      
      rewardBox.innerHTML = `
        <div style="
          font-size: 28px;
          font-weight: bold;
          color: ${reward.color};
          text-transform: uppercase;
          letter-spacing: 2px;
          margin-bottom: 3px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          +${reward.amount} FLIP
        </div>
        <div style="
          font-size: 13px;
          color: #ffffff;
          text-transform: uppercase;
          letter-spacing: 1px;
          opacity: 0.9;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          Token Reward
        </div>
      `;
      
      const cssObject = new CSS3DObject(rewardBox);
      // Position ABOVE the tube (matching result box orientation pattern)
      const tubeTopY = 200 + (TUBE_HEIGHT / 2);
      cssObject.position.set(tube.tube.position.x, tubeTopY + 100, 0);
      cssObject.scale.set(0.5, 0.5, 0.5);
      scene.add(cssObject);
      
      tube.rewardBox = cssObject;
      
      // Animate appearance and float up
      rewardBox.style.opacity = '0';
      rewardBox.style.transform = 'scaleY(-1) scale(0.5) translateY(30px)';
      rewardBox.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
      
      // Pop in with bounce
      setTimeout(() => {
        rewardBox.style.opacity = '1';
        rewardBox.style.transform = 'scaleY(-1) scale(1) translateY(0px)';
      }, 50);
      
      // Float up and fade out after 1.5s (stay for 2 seconds total)
      setTimeout(() => {
        rewardBox.style.transition = 'all 0.5s ease-in';
        rewardBox.style.opacity = '0';
        rewardBox.style.transform = 'scaleY(-1) scale(1.1) translateY(-40px)';
      }, 1500);
      
      // Remove from scene after animation completes
      setTimeout(() => {
        scene.remove(cssObject);
      }, 2100);
    }

    // ===== COIN FLIP ANIMATION BASED ON POWER =====
    function flipCoinWithPower(tubeIndex, powerLevel, playerChoice) {
      const tube = tubes[tubeIndex];
      const coin = coins[tubeIndex];
      const powerPercent = powerLevel / 100;
      
      // Show FLIP reward immediately when flip starts
      showFlipReward(tubeIndex);
      
      // Get material multipliers
      const material = tube.selectedMaterial || coinMaterials[2]; // Default to glass
      const speedMult = material.speedMultiplier;
      const durationMult = material.durationMultiplier;
      
      // Duration scales with power (2s - 8s) AND material
      const baseDuration = 2000 + (powerPercent * 6000);
      const flipDuration = baseDuration * durationMult;
      
      // Flip speed scales with power (0.08 - 0.3 rad/frame) AND material
      // Minimum 0.08 to ensure coin always visibly flips
      const basePowerSpeed = Math.max(0.08, 0.05 + (powerPercent * 0.25));
      const baseFlipSpeed = basePowerSpeed * speedMult;
      
      console.log(`ü™ô Material: ${material.name} - Speed: ${speedMult}x, Duration: ${durationMult}x`);
      
      // Random result (50/50 heads or tails)
      const result = Math.random() < 0.5 ? 'heads' : 'tails';
      
      // Check if player won
      const didWin = playerChoice === result;
      
      console.log(`ü™ô Flipping coin ${tubeIndex + 1} for ${flipDuration.toFixed(0)}ms at speed ${baseFlipSpeed.toFixed(3)} - Result: ${result}, Choice: ${playerChoice}, Won: ${didWin}`);
      
      const startTime = Date.now();
      
      // Calculate target rotation - Standing on edge facing camera
      // For heads: rotation.x should be at œÄ/2 (standing on edge, heads facing camera)
      // For tails: rotation.x should be at 3œÄ/2 (standing on edge, tails facing camera)
      const targetRotationX = result === 'heads' ? Math.PI / 2 : (3 * Math.PI / 2);
      
      tube.isFlipping = true;
      
      // PRE-CALCULATE: How many full rotations to do before landing
      const startRotation = coin.rotation.x;
      const rotationsPerSecond = baseFlipSpeed * 60;
      const totalRotations = (rotationsPerSecond * (flipDuration / 1000)) / (Math.PI * 2);
      const fullRotations = Math.floor(totalRotations);
      const finalTarget = startRotation + (fullRotations * Math.PI * 2) + (targetRotationX - (startRotation % (Math.PI * 2)));
      
      const animateFlip = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / flipDuration, 1);
        
        // EASE-OUT CUBIC: Smooth deceleration to exact target
        const easeOutCubic = 1 - Math.pow(1 - progress, 3);
        coin.rotation.x = startRotation + (finalTarget - startRotation) * easeOutCubic;
        
        if (progress < 1) {
          requestAnimationFrame(animateFlip);
        } else {
          // Final landing - ensure exact position
          coin.rotation.x = finalTarget;
          coin.rotation.y = Math.PI / 2;
          coin.rotation.z = 0;
          
          tube.isFlipping = false;
          console.log(`‚úÖ Coin ${tubeIndex + 1} landed on ${result} facing camera`);
          
          // Show result after landing
          showResult(tubeIndex, didWin, result);
        }
      };
      
      animateFlip();
    }

    // ===== UPDATE WINS DISPLAY =====
    function updateWinsDisplay(tubeIndex) {
      const player = players[tubeIndex];
      const tube = tubes[tubeIndex];
      
      if (!tube.cardElement) return;
      
      // Find the wins display element and update the number
      const winsDisplay = tube.cardElement.querySelector('.wins-display span:last-child');
      if (winsDisplay) {
        winsDisplay.textContent = player.wins;
      }
      
      console.log(`üèÜ Updated wins display for player ${tubeIndex + 1}: ${player.wins} wins`);
    }

    // ===== UPDATE PLAYER CARD CHOICE =====
    function updatePlayerCardChoice(tubeIndex, choice) {
      const tube = tubes[tubeIndex];
      if (!tube.cardElement) return;
      
      const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
      const choiceBadge = tube.cardElement.querySelector('.choice-badge');
      
      if (choiceButtons && choiceBadge) {
        // Hide choice buttons and show choice badge
        choiceButtons.style.display = 'none';
        choiceBadge.className = `choice-badge ${choice}`;
        choiceBadge.textContent = choice.toUpperCase();
        choiceBadge.style.display = 'block';
      }
      
      console.log(`üéØ Updated player ${tubeIndex + 1} choice to: ${choice}`);
    }

    // ===== SHOW WIN/LOSE RESULT =====
    function showResult(tubeIndex, didWin, result) {
      const tube = tubes[tubeIndex];
      const coin = coins[tubeIndex];
      const player = players[tubeIndex];
      
      // Add green glow if won
      if (didWin) {
        // Create green point light
        const winLight = new THREE.PointLight(0x00ff00, 8, 200);
        winLight.position.set(0, 0, 0);
        coin.add(winLight);
        tube.winLight = winLight;
        
        // Make coin glow green
        coin.children.forEach(child => {
          if (child.isLight && child !== winLight) {
            child.color.setHex(0x00ff00);
            child.intensity = 6;
          }
        });
        
        // Award win point
        player.wins++;
        console.log(`üéâ Player ${tubeIndex + 1} WON! Wins: ${player.wins}/3`);
        
        // Update wins display
        updateWinsDisplay(tubeIndex);
        
        // Check for game over (first to 3 wins)
        if (player.wins >= 3) {
          console.log(`üèÜ Player ${tubeIndex + 1} reached 3 wins!`);
          // Server will handle tiebreaker logic
        }
      } else {
        // Red glow for loss
        const loseLight = new THREE.PointLight(0xff0000, 6, 200);
        loseLight.position.set(0, 0, 0);
        coin.add(loseLight);
        tube.loseLight = loseLight;
        
        console.log(`‚ùå Player ${tubeIndex + 1} LOST this round`);
      }
      
      // Create result text box (CSS3D)
      const resultBox = document.createElement('div');
      resultBox.style.cssText = `
        width: 300px;
        padding: 20px;
        background: ${didWin ? 'linear-gradient(135deg, #004d00, #003300)' : 'linear-gradient(135deg, #1a0000, #0d0000)'};
        border: 3px solid ${didWin ? '#00ff00' : '#ff0000'};
        border-radius: 16px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        box-shadow: 0 0 30px ${didWin ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 0, 0, 0.6)'};
        pointer-events: none;
      `;
      
      resultBox.innerHTML = `
        <div style="
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
          margin-bottom: 10px;
        ">
          <img src="/images/potion.png" style="width: 40px; height: 40px; object-fit: contain; ${didWin ? '' : 'filter: grayscale(100%) brightness(0.5);'}" />
          <div style="
            font-size: 30px;
            font-weight: bold;
            color: ${didWin ? '#00ff00' : '#ff0000'};
            text-transform: uppercase;
            letter-spacing: 2px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          ">
            ${didWin ? 'ROUND WON!' : 'YOU LOST'}
          </div>
        </div>
        <div style="
          font-size: 20px;
          color: #ffffff;
          text-transform: uppercase;
          letter-spacing: 2px;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        ">
          Result: ${result.toUpperCase()}
        </div>
      `;
      
      const cssObject = new CSS3DObject(resultBox);
      // Position below coin, matching the tube's X position
      cssObject.position.set(tube.tube.position.x, coin.position.y - 100, 0);
      cssObject.scale.set(0.5, 0.5, 0.5);
      scene.add(cssObject);
      
      tube.resultBox = cssObject;
      
      // Animate result box appearing
      resultBox.style.opacity = '0';
      resultBox.style.transition = 'all 0.5s ease-out';
      
      setTimeout(() => {
        resultBox.style.opacity = '1';
        
        // SERVER-AUTHORITATIVE: Game progression managed by server
      }, 50);
    }

    // ===== GAME ENDING LOGIC =====
    // SERVER-AUTHORITATIVE: Game progression is now managed entirely by the server
    
    // SERVER-AUTHORITATIVE: Game ending logic is now managed entirely by the server
    
    // SERVER-AUTHORITATIVE: Winner declaration is now managed entirely by the server
    
    // SERVER-AUTHORITATIVE: Sudden death logic is now managed entirely by the server

    // SERVER-AUTHORITATIVE: Special replay logic is now managed entirely by the server
    
    // SERVER-AUTHORITATIVE: Special replay messages are now managed entirely by the server
    
    // Show choice required message
    function showChoiceRequiredMessage(playerIndex) {
      const player = players[playerIndex];
      const tube = tubes[playerIndex];
      
      // Create message div positioned near the player's card
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = `
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff1493, #ff69b4);
        border: 3px solid #ff1493;
        border-radius: 15px;
        padding: 20px 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
        z-index: 10000;
        animation: bounceIn 0.5s ease-out;
      `;
      
      messageDiv.innerHTML = `
        <div style="margin-bottom: 8px;">‚ö†Ô∏è</div>
        <div>${player.name.toUpperCase()}</div>
        <div style="font-size: 14px; margin-top: 5px; opacity: 0.9;">
          Choose HEADS or TAILS first!
        </div>
      `;
      
      // Add bounce animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes bounceIn {
          0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.1); }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(messageDiv);
      
      // Remove message after 2 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.style.animation = 'bounceOut 0.3s ease-in forwards';
          setTimeout(() => {
            if (messageDiv.parentNode) {
              messageDiv.parentNode.removeChild(messageDiv);
            }
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
          }, 300);
        }
      }, 2000);
      
      // Add bounceOut animation
      if (!document.querySelector('#bounceOutStyle')) {
        const bounceOutStyle = document.createElement('style');
        bounceOutStyle.id = 'bounceOutStyle';
        bounceOutStyle.textContent = `
          @keyframes bounceOut {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
          }
        `;
        document.head.appendChild(bounceOutStyle);
      }
    }
    
    // Show XP award notification
    function showXPAwardNotification(amount, totalXP) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #00ff00;
        border-radius: 15px;
        padding: 20px 25px;
        color: #00ff00;
        font-family: 'Orbitron', sans-serif;
        font-weight: bold;
        font-size: 18px;
        z-index: 10001;
        box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
      `;
      
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <div style="font-size: 24px;">üí∞</div>
          <div>
            <div style="font-size: 20px; margin-bottom: 5px;">+${amount} FLIP</div>
            <div style="font-size: 14px; opacity: 0.8;">Total: ${totalXP}</div>
          </div>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Slide in
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 100);
      
      // Slide out and remove after 3 seconds
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    // Show game phase indicator
    function showGamePhaseIndicator(phase, message) {
      // Remove existing phase indicator
      const existing = document.getElementById('game-phase-indicator');
      if (existing) {
        existing.remove();
      }
      
      const indicator = document.createElement('div');
      indicator.id = 'game-phase-indicator';
      indicator.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid ${phase === 'waiting' ? '#ffaa00' : phase === 'starting' ? '#00ff00' : phase === 'in_progress' ? '#0088ff' : '#ff0000'};
        border-radius: 15px;
        padding: 15px 30px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: #ffffff;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 0 30px ${phase === 'waiting' ? 'rgba(255, 170, 0, 0.5)' : phase === 'starting' ? 'rgba(0, 255, 0, 0.5)' : phase === 'in_progress' ? 'rgba(0, 136, 255, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
        z-index: 9998;
        animation: phaseIndicatorPulse 0.5s ease-out;
      `;
      
      const phaseIcon = phase === 'waiting' ? '‚è≥' : phase === 'starting' ? 'üéÆ' : phase === 'in_progress' ? '‚öîÔ∏è' : 'üèÅ';
      indicator.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 24px;">${phaseIcon}</span>
          <span>${message}</span>
        </div>
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes phaseIndicatorPulse {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(indicator);
    }

    // Show game start notification
    function showGameStartNotification() {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #00ff00, #39ff14);
        border: 3px solid #00ff00;
        border-radius: 20px;
        padding: 40px 60px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: #000;
        font-size: 32px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 3px;
        box-shadow: 0 0 60px rgba(0, 255, 0, 0.8);
        z-index: 10001;
        animation: gameStartPulse 0.5s ease-out;
      `;
      
      notification.innerHTML = `
        <div style="margin-bottom: 10px;">üéÆ</div>
        <div>GAME STARTED!</div>
        <div style="font-size: 18px; margin-top: 10px;">Round 1 Beginning</div>
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes gameStartPulse {
            0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Remove after 3 seconds
      setTimeout(() => {
        notification.style.animation = 'gameStartPulse 0.5s ease-out reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 500);
      }, 3000);
    }

    // Show game over screen
    function showGameOverScreen(winnerIndex, winnerName) {
      console.log('üèÅ GAME OVER - Showing end screen');
      
      // Stop any ongoing game mechanics
      gameOver = true;
      // SERVER-AUTHORITATIVE: Server manages all timing
      
      // Show game ended phase indicator
      showGamePhaseIndicator('ended', 'Game Over - Claim your rewards!');
      
      // Determine if current player won
      const didCurrentPlayerWin = (playerSlot === winnerIndex);
      
      console.log(`üèÅ Game Over Debug:`, {
        playerSlot,
        winnerIndex,
        didCurrentPlayerWin,
        winnerName
      });
      
      // Award FLIP tokens directly via server
      if (isServerSideMode && socket && gameIdParam && walletParam) {
        const gameResult = didCurrentPlayerWin ? 'won' : 'lost';
        
        // Request direct FLIP token award
        socket.emit('award_flip_tokens_final', {
          gameId: gameIdParam,
          address: walletParam,
          gameResult: gameResult,
          finalLives: currentPlayerLives,
          totalFlip: currentPlayerXP
        });
        
        console.log(`üéÅ Awarding FLIP tokens directly: ${gameResult}, ${currentPlayerXP} FLIP`);
      }
      
      // Show immediate game over overlay
      const gameOverDiv = document.createElement('div');
      gameOverDiv.id = 'game-over-overlay';
      gameOverDiv.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        font-family: 'Orbitron', sans-serif;
      `;
      
      const contentDiv = document.createElement('div');
      contentDiv.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 4px solid ${didCurrentPlayerWin ? '#FFD700' : '#ff0000'};
        border-radius: 25px;
        padding: 50px;
        text-align: center;
        box-shadow: 0 0 50px ${didCurrentPlayerWin ? 'rgba(255, 215, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
        max-width: 600px;
        width: 90%;
      `;
      
      // Show different content based on win/lose
      if (didCurrentPlayerWin) {
        contentDiv.innerHTML = `
            <div style="font-size: 80px; margin-bottom: 20px;">üèÜ</div>
            <div style="font-size: 48px; font-weight: bold; color: #FFD700; margin-bottom: 20px;">
                VICTORY!
            </div>
            <div style="font-size: 24px; color: #ffffff; margin-bottom: 30px;">
                You earned ${currentPlayerXP} FLIP tokens!
            </div>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 30px;">
                <button id="claim-nft-btn" style="
                    background: linear-gradient(135deg, #ff0088, #ff1493);
                    border: none;
                    border-radius: 15px;
                    padding: 15px 30px;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 18px;
                    font-weight: bold;
                    color: #fff;
                    cursor: pointer;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                ">
                    üé® Claim NFT Prize
                </button>
            </div>
        `;
      } else {
        contentDiv.innerHTML = `
            <div style="font-size: 60px; margin-bottom: 20px;">üíî</div>
            <div style="font-size: 36px; font-weight: bold; color: #ff0000; margin-bottom: 20px;">
                DEFEATED
            </div>
            <div style="font-size: 24px; color: #ffffff; margin-bottom: 20px;">
                Winner: ${winnerName || 'Unknown'}
            </div>
            <div style="font-size: 20px; color: #00ff00; margin-bottom: 30px;">
                You earned ${currentPlayerXP} FLIP tokens!
            </div>
        `;
      }
      
      // Add return to lobby button
      contentDiv.innerHTML += `
        <button id="return-lobby-btn" style="
            background: linear-gradient(135deg, #666, #888);
            border: none;
            border-radius: 15px;
            padding: 12px 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 20px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        ">
            Return Home
        </button>
      `;
      
      gameOverDiv.appendChild(contentDiv);
      document.body.appendChild(gameOverDiv);
      
      // Add button handlers
      setTimeout(() => {
        const claimNftBtn = document.getElementById('claim-nft-btn');
        const returnLobbyBtn = document.getElementById('return-lobby-btn');
        
        if (claimNftBtn && didCurrentPlayerWin) {
            claimNftBtn.addEventListener('click', () => {
                if (socket && gameIdParam && walletParam) {
                    console.log(`üèÜ Claiming NFT prize for winner ${walletParam} in game ${gameIdParam}`);
                    socket.emit('claim_nft_prize', {
                        gameId: gameIdParam,
                        address: walletParam
                    });
                    claimNftBtn.disabled = true;
                    claimNftBtn.textContent = 'Claiming...';
                } else {
                    console.error('‚ùå Cannot claim NFT: missing socket, gameId, or walletParam');
                }
            });
        }
        
        if (returnLobbyBtn) {
            returnLobbyBtn.addEventListener('click', () => {
                window.location.href = '/';
            });
        }
      }, 100);
    }

    // SERVER-AUTHORITATIVE: Round reset logic is now managed entirely by the server

    // Plasma effects removed - pearls now glow on their own!

    console.log('‚úÖ Game loaded! Hold CHARGE POWER button to fill tubes!');
    console.log('üéÆ Server-authoritative game ready - all game logic managed by server');
    
    // Update player cards with real data after loading
    function updatePlayerCards() {
      console.log('üîÑ Updating player cards with real data...');
      tubes.forEach((tube, index) => {
        const player = players[index];
        console.log(`üîç Tube ${index + 1}:`, { hasCardElement: !!tube.cardElement, player: player?.name });
        if (!tube.cardElement || !player) return;
        
        // Also update mobile player cards
        createMobilePlayerCards();
        
        // TEMPORARILY REMOVED: Button blocking logic for debugging
        // Show buttons for ALL players to debug visibility issues
        const showButtons = !player.isEmpty;
        
        console.log(`üéØ Player ${index + 1} button logic (DEBUGGING MODE):`, {
          playerAddress: player.address,
          isEmpty: player.isEmpty,
          showButtons: showButtons
        });
        
        // Update player name and address
        const playerNameElement = tube.cardElement.querySelector('.player-name');
        const playerAddressElement = tube.cardElement.querySelector('.player-address');
        const playerAvatarElement = tube.cardElement.querySelector('.player-avatar');
        
        console.log(`üìù Updating player ${index + 1}:`, { name: player.name, address: player.address, isEmpty: player.isEmpty });
        
        if (playerNameElement) playerNameElement.textContent = player.name;
        if (playerAddressElement) {
          // Shorten wallet address for display
          const shortAddress = player.address ? `${player.address.slice(0, 6)}...${player.address.slice(-4)}` : '';
          playerAddressElement.textContent = shortAddress;
        }
        if (playerAvatarElement) {
          playerAvatarElement.src = player.isEmpty ? '/images/potion.png' : (player.avatar || '/images/default-avatar.png');
          playerAvatarElement.alt = player.name;
        }
        
        // Update wins display
        const winsDisplay = tube.cardElement.querySelector('.wins-display span:last-child');
        if (winsDisplay) {
          winsDisplay.textContent = player.wins;
        }
        
        // Update empty slot overlay
        const existingOverlay = tube.cardElement.querySelector('.empty-slot-overlay');
        console.log(`üéØ Player ${index + 1} empty slot logic:`, { 
          isEmpty: player.isEmpty, 
          hasExistingOverlay: !!existingOverlay,
          playerName: player.name,
          playerAddress: player.address 
        });
        
        // Always remove existing overlay first to ensure clean state
        if (existingOverlay) {
          console.log(`üßπ Removing existing overlay from player slot ${index + 1}`);
          existingOverlay.remove();
        }
        
        // Add overlay only for truly empty slots
        if (player.isEmpty) {
          console.log(`‚ûï Adding pink X overlay to empty slot ${index + 1}`);
          const overlay = document.createElement('div');
          overlay.className = 'empty-slot-overlay';
          overlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 20, 147, 0.8);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
          `;
          overlay.textContent = '‚úï';
          tube.cardElement.appendChild(overlay);
        }
        
        // Update buttons visibility
        const actionButtons = tube.cardElement.querySelectorAll('.action-btn');
        const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
        
        if (showButtons) {
          actionButtons.forEach(btn => btn.style.display = 'block');
          if (choiceButtons) choiceButtons.style.display = 'flex';
        } else {
          actionButtons.forEach(btn => btn.style.display = 'none');
          if (choiceButtons) choiceButtons.style.display = 'none';
        }
      });
      
      // Update coin rotations based on player choices
      updateCoinRotationsFromPlayerChoices();
    }

    // Fetch participants and map to tubes left-to-right
    async function loadParticipants() {
      try {
        if (!gameIdParam) return;
        const res = await fetch(`/api/battle-royale/${encodeURIComponent(gameIdParam)}`);
        if (!res.ok) throw new Error('Failed to load participants');
        const data = await res.json();
        const parts = (data?.game?.participants || []).slice().sort((a,b) => (a.slot_number||0)-(b.slot_number||0));
        console.log('üîç Raw participants data:', parts);
        
        players = [1,2,3,4].map((slot, idx) => {
          const p = parts[idx];
          if (!p) {
            console.log(`üì≠ Slot ${idx+1}: Empty`);
            return { id: idx+1, name: 'Empty', wins: 0, address: '', choice: null, avatar: '', isEmpty: true };
          }
          
          const playerData = {
            id: idx+1,
            name: p.username || p.name || `Player ${idx+1}`,
            wins: 0,
            address: p.player_address || '',
            choice: null,
            avatar: p.avatar || '/images/default-avatar.png',
            isEmpty: false
          };
          
          console.log(`üë§ Slot ${idx+1}:`, {
            raw: p,
            processed: playerData
          });
          
          return playerData;
        });
        // Update initial wins tracking
        roundStartWins = players.map(player => player.wins);
        console.log('üìä Participants mapped:', players);
        
        // Update player cards with real data
        updatePlayerCards();
        
        // Create mobile player cards
        createMobilePlayerCards();
        
        // Show appropriate phase indicator based on server state
        // The server will send the correct phase via physics_state_update
        // Don't hardcode to 'waiting' - let server control the phase
        
        // SERVER-AUTHORITATIVE: Server manages all timing
        
        // Show game start notification
        if (!gameOver) {
          showGameStartNotification();
        }
      } catch (err) {
        console.warn('Participants load failed:', err);
        // SERVER-AUTHORITATIVE: Server manages all timing
      }
    }
    await loadParticipants();

    // ===== SERVER JOIN (PLAYER) =====
    (async () => {
      try {
        if (!gameIdParam) return;
        if (roleParam === 'spectator') {
          console.log('üëÄ Spectator mode - skipping join');
          return;
        }
        if (!walletParam) {
          console.warn('‚ö†Ô∏è No wallet address provided; cannot join game');
          return;
        }
        const res = await fetch(`/api/battle-royale/${encodeURIComponent(gameIdParam)}/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...(tokenParam ? { Authorization: `Bearer ${tokenParam}` } : {}) },
          body: JSON.stringify({ player_address: walletParam })
        });
        const data = await res.json().catch(() => ({}));
        if (res.ok) {
          console.log('‚úÖ Joined game on server:', data);
        } else {
          console.warn('‚ö†Ô∏è Join failed:', data?.error || res.statusText);
        }
      } catch (err) {
        console.error('‚ùå Join error:', err);
      }
    })();
    
    // ===== POST-INITIALIZATION SETUP =====
    setTimeout(() => {
      // Update player card buttons after all initialization is complete
      if (typeof updatePlayerCardButtons === 'function') {
        updatePlayerCardButtons();
      }
      
      // Update coin rotations based on initial player choices
      if (typeof updateCoinRotationsFromPlayerChoices === 'function') {
        updateCoinRotationsFromPlayerChoices();
      }
    }, 1000); // 1 second delay
    
    // ===== CLEAN MOBILE SYSTEM =====
    
    // Mobile detection
    function isMobile() {
      return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // Haptic feedback
    function triggerHaptic() {
      if (navigator.vibrate) {
        navigator.vibrate(30);
      }
    }

    // Mobile UI Management
    function initializeMobileUI() {
      if (!isMobile()) return;
      
      console.log('üì± Initializing clean mobile UI');
      
      // Setup mobile controls
      setupMobileControls();
      
      // Create player cards
      createMobilePlayerCards();
      
      // Update displays
      updateMobileDisplays();
    }

    // Setup mobile controls
    function setupMobileControls() {
      // Change coin button
      const changeCoinBtn = document.getElementById('mobile-change-coin');
      if (changeCoinBtn) {
        changeCoinBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          // Handle change coin functionality
          console.log('Change coin clicked');
          // Trigger the coin selector
          if (typeof showCoinSelector === 'function') {
            showCoinSelector(playerSlot);
          }
        });
      }
      
      // Chat button
      const chatBtn = document.getElementById('mobile-chat');
      if (chatBtn) {
        chatBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          // Handle chat functionality
          console.log('Chat clicked');
          // Trigger desktop chat if available
          const desktopBtn = document.getElementById('chat-btn');
          if (desktopBtn) desktopBtn.click();
        });
      }
      
      // Fullscreen button
      const fullscreenBtn = document.getElementById('mobile-fullscreen');
      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
          }
        });
      }
      
      // Heads button
      const headsBtn = document.getElementById('mobile-heads');
      if (headsBtn) {
        headsBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (currentPlayer && !currentPlayer.choice) {
            currentPlayer.choice = 'heads';
            updatePlayerChoice(currentPlayer);
            
            // Add visual feedback
            headsBtn.classList.add('selected');
            tailsBtn.classList.remove('selected');
          }
        });
      }

      // Tails button
      const tailsBtn = document.getElementById('mobile-tails');
      if (tailsBtn) {
        tailsBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (currentPlayer && !currentPlayer.choice) {
            currentPlayer.choice = 'tails';
            updatePlayerChoice(currentPlayer);
            
            // Add visual feedback
            tailsBtn.classList.add('selected');
            headsBtn.classList.remove('selected');
          }
        });
      }

      // Power button (hold to charge)
      const powerBtn = document.getElementById('mobile-power');
      if (powerBtn) {
        let powerInterval = null;
        let isCharging = false;
        
        const startCharging = () => {
          if (isCharging) return;
          
          // Find current player slot dynamically
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (!currentPlayer) {
            console.log('‚ùå No current player found for mobile power');
            return;
          }
          
          const playerSlot = players.findIndex(p => p.address === currentPlayer.address);
          if (playerSlot === -1) {
            console.log('‚ùå Current player slot not found');
            return;
          }
          
          triggerHaptic();
          isCharging = true;
          
          // Initialize power charging
          if (tubes[playerSlot]) {
            tubes[playerSlot].isFilling = true;
            tubes[playerSlot].power = 0;
            tubes[playerSlot].chargingStartTime = Date.now();
          }
          
          // Start power charging animation
          powerInterval = setInterval(() => {
            if (tubes[playerSlot] && tubes[playerSlot].isFilling) {
              const elapsed = Date.now() - tubes[playerSlot].chargingStartTime;
              const powerPercent = Math.min(100, (elapsed / 2000) * 100); // 2 second max charge
              
              tubes[playerSlot].power = powerPercent;
              tubes[playerSlot].powerLevel = Math.min(5, Math.max(1, Math.ceil(powerPercent / 20)));
              tubes[playerSlot].foamIntensity = powerPercent / 100;
              
              // Update mobile power bar
              const powerFill = document.getElementById('mobile-power-fill');
              const powerText = document.getElementById('mobile-power-text');
              if (powerFill && powerText) {
                powerFill.style.width = `${powerPercent}%`;
                powerText.textContent = `POWER: ${Math.round(powerPercent)}%`;
              }
              
              // Broadcast power charging to server
              if (isServerSideMode && socket && gameIdParam && walletParam) {
                socket.emit('physics_power_charging', {
                  gameId: gameIdParam,
                  address: walletParam,
                  power: powerPercent,
                  powerLevel: tubes[playerSlot].powerLevel,
                  playerSlot: playerSlot,
                  isFilling: true
                });
              }
            }
          }, 50);
        };
        
        const stopCharging = () => {
          if (!isCharging) return;
          
          // Find current player slot dynamically
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (!currentPlayer) {
            console.log('‚ùå No current player found for mobile power stop');
            return;
          }
          
          const playerSlot = players.findIndex(p => p.address === currentPlayer.address);
          if (playerSlot === -1) {
            console.log('‚ùå Current player slot not found for stop');
            return;
          }
          
          triggerHaptic();
          isCharging = false;
          
          if (powerInterval) {
            clearInterval(powerInterval);
            powerInterval = null;
          }
          
          if (tubes[playerSlot]) {
            const finalPower = tubes[playerSlot].power;
            tubes[playerSlot].isFilling = false;
            
            console.log(`‚ö° Mobile power released at ${finalPower.toFixed(0)}%`);
            
            // Broadcast power stop to server
            if (isServerSideMode && socket && gameIdParam && walletParam) {
              socket.emit('physics_power_charging_stop', {
                gameId: gameIdParam,
                address: walletParam,
                playerSlot: playerSlot,
                finalPower: finalPower
              });
            }
            
            // Trigger spin if power is sufficient
            if (finalPower > 10) { // Minimum 10% power to spin
              if (isServerSideMode && socket && gameIdParam && walletParam) {
                socket.emit('physics_coin_flip', {
                  gameId: gameIdParam,
                  address: walletParam,
                  power: finalPower,
                  playerSlot: playerSlot
                });
              }
            }
          }
        };
        
        powerBtn.addEventListener('touchstart', startCharging);
        powerBtn.addEventListener('touchend', stopCharging);
        powerBtn.addEventListener('mousedown', startCharging);
        powerBtn.addEventListener('mouseup', stopCharging);
      }

      // Action buttons
      const coinBtn = document.getElementById('mobile-coin');
      if (coinBtn) {
        coinBtn.addEventListener('click', (e) => {
          e.preventDefault();
          triggerHaptic();
          const globalBtn = document.getElementById('global-change-coin-btn');
          if (globalBtn) globalBtn.click();
        });
      }


    }

    // Create mobile player cards
    function createMobilePlayerCards() {
      const container = document.getElementById('mobile-player-cards');
      if (!container) {
        console.log('‚ùå Mobile player cards container not found');
        return;
      }

      console.log('üîÑ Creating mobile player cards...', { tubes: tubes.length, players: players.length });
      container.innerHTML = '';
      
      // Create 4 individual player boxes
      for (let i = 0; i < 4; i++) {
        const player = players[i];
        console.log(`üîç Player ${i + 1}:`, { player: player?.name, isEmpty: player?.isEmpty });
        
        const box = document.createElement('div');
        box.className = 'player-box';
        
        if (player && !player.isEmpty) {
          box.innerHTML = `
            <img src="${player.avatar || '/images/default-avatar.png'}" class="player-avatar" alt="${player.name}" />
            <div class="player-info">
              <div class="player-name">${player.name}</div>
              <div class="player-wins">üèÜ ${player.wins}</div>
            </div>
          `;
          console.log(`‚úÖ Created mobile box for ${player.name}`);
        } else {
          box.innerHTML = `
            <div class="player-info">
              <div class="player-name">Empty</div>
              <div class="player-wins">-</div>
            </div>
          `;
          console.log(`‚è≠Ô∏è Created empty box for slot ${i + 1}`);
        }
        
        container.appendChild(box);
      }
      
      console.log(`üì± Mobile player boxes created: ${container.children.length} boxes`);
    }

    // Update mobile displays
    function updateMobileDisplays() {
      // Timer is now handled by the existing game-info div

      // Update earnings
      const earnings = document.getElementById('mobile-earnings');
      if (earnings) {
        earnings.textContent = `${currentPlayerXP} FLIP`;
      }

      // Update power bar
      const powerFill = document.getElementById('mobile-power-fill');
      const powerText = document.getElementById('mobile-power-text');
      if (powerFill && powerText) {
        let totalPower = 0;
        let playerCount = 0;
        
        tubes.forEach(tube => {
          if (tube.power !== undefined) {
            totalPower += tube.power;
            playerCount++;
          }
        });

        const averagePower = playerCount > 0 ? totalPower / playerCount : 0;
        const powerPercentage = Math.min(100, Math.max(0, averagePower));

        powerFill.style.width = `${powerPercentage}%`;
        powerText.textContent = `POWER: ${powerPercentage.toFixed(0)}%`;
      }
    }

    // Fullscreen functionality
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }
    }

    // Initialize mobile UI
    setTimeout(initializeMobileUI, 1000);

    // ===== MOBILE PERFORMANCE OPTIMIZATIONS =====
    
    // Mobile performance optimizations
    function optimizeForMobile() {
      if (!isMobile()) return;
      
      console.log('üì± Applying mobile performance optimizations');
      
      // Optimize renderer for mobile
      webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio for performance
      webglRenderer.antialias = false; // Disable antialiasing for performance
      webglRenderer.shadowMap.enabled = false; // Disable shadows for performance
      
      // Reduce particle count for mobile
      tubes.forEach(tube => {
        if (tube.liquidParticleMeshes) {
          const maxParticles = 30; // Reduced for mobile
          tube.liquidParticleMeshes.slice(maxParticles).forEach(mesh => {
            mesh.visible = false;
          });
        }
      });
      
      // Optimize lighting for mobile
      if (ambientLight) ambientLight.intensity = 0.4;
      if (directionalLight) {
        directionalLight.intensity = 0.6;
        directionalLight.castShadow = false;
      }
      
      console.log('‚úÖ Mobile performance optimizations applied');
    }

    // Apply optimizations
    setTimeout(optimizeForMobile, 2000);
    
    // SERVER-AUTHORITATIVE: No client timer functions to expose

    // Animation loop with physics
    let frameCount = 0;
    const timeStep = 1 / 60; // 60 FPS
    
    function animate() {
      frameCount++;

      // Step physics simulation
      physicsWorld.step(timeStep);

      tubes.forEach((tube, i) => {
        const offset = i * 0.4;
        
        // üéØ REFACTORED: POWER CHARGING SYSTEM - REAL-TIME SYNC
        if (tube.isFilling && !tube.isShattered) {
          // Increase power (0-100 over ~3 seconds) - FOR ALL PLAYERS
          tube.power = Math.min(tube.power + 0.6, 100);
          const powerPercent = tube.power / 100;
          
          // Update foam intensity
          tube.foamIntensity = powerPercent;
          
          // Calculate power level (1-5) based on power percentage
          const powerLevel = Math.min(5, Math.max(1, Math.ceil(tube.power / 20)));
          
          // üéØ FASTER BROADCAST - Every 5 frames = 12 updates/second (was every frame)
          if (isServerSideMode && socket && gameIdParam && walletParam && playerSlot === i) {
            if (frameCount % 5 === 0) { // Changed from every frame to every 5 frames
              socket.emit('physics_power_charging', {
                gameId: gameIdParam,
                address: walletParam,
                power: tube.power,
                powerLevel: powerLevel,
                playerSlot: i,
                isFilling: tube.isFilling
              });
              // Removed console.log to reduce spam - only log on start/stop
            }
          }
          
          // Update UI elements
          if (tube.cardElement) {
            const powerBar = tube.cardElement.querySelector('.power-bar');
            const powerText = tube.cardElement.querySelector('.power-text');
            if (powerBar) powerBar.style.width = `${tube.power}%`;
            if (powerText) powerText.textContent = `POWER: ${tube.power.toFixed(0)}%`;
            
            // Change bar color as it charges (pink theme)
            if (tube.power > 75) {
              powerBar.style.background = 'linear-gradient(90deg, #ff1493, #ff69b4)';
            } else if (tube.power > 50) {
              powerBar.style.background = 'linear-gradient(90deg, #ff69b4, #ffb6c1)';
            }
          }
          
          // üéØ UNIFIED PEARL COLOR UPDATE - Same for local and remote
          updatePearlColors(tube, powerPercent, i);
        }
        
        // üéØ UNIFIED PEARL PHYSICS - Runs for BOTH local charging AND remote viewing
        if ((tube.isFilling || tube.foamIntensity > 0) && !tube.isShattered) {
          updatePearlPhysics(tube, tube.foamIntensity, i, frameCount);
        }
        
        // Sync particle visual meshes with physics bodies
        tube.liquidParticles.forEach((particleBody, idx) => {
          tube.liquidParticleMeshes[idx].position.copy(particleBody.position);
          tube.liquidParticleMeshes[idx].quaternion.copy(particleBody.quaternion);
        });
        
        // Pulsing light during charging
        if (tube.foamIntensity > 0) {
          const lightPulse = Math.sin(frameCount * 0.15 + offset) * 0.5;
          tube.liquidLight.intensity = tube.liquidLight.intensity + lightPulse * tube.foamIntensity;
        }
      });

      // Animate coins - VIBRATE during charge, stay centered
      coins.forEach((coin, i) => {
        const tube = tubes[i];
        
        // Ensure coin is always visible
        coin.visible = true;
        
        if (tube.isFlipping) {
          // Flipping animation handled by flipCoinWithPower function
          // Ensure coin stays centered during flip
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX;
          coin.position.y = 200;
          coin.position.z = 0;
        } else if (tube.isFilling && !tube.isShattered) {
          // VIBRATION increases with power
          const vibIntensity = (tube.power / 100) * 8; // 0 to 8 pixels
          const vibSpeed = (tube.power / 100) * 20; // Speed increases
          
          // Vibrate position
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX + Math.sin(frameCount * vibSpeed) * vibIntensity;
          coin.position.y = 200 + Math.cos(frameCount * vibSpeed * 1.3) * vibIntensity;
          coin.position.z = Math.sin(frameCount * vibSpeed * 0.7) * vibIntensity * 0.5;
          
          // Slight rotation vibration
          coin.rotation.z = Math.sin(frameCount * vibSpeed * 0.5) * (vibIntensity / 50);
        } else if (!tube.isShattered && !tube.isFilling) {
          // Reset to center when idle (like reference)
          const tubeX = tube.tube.position.x;
          coin.position.x = tubeX;
          coin.position.y = 200;
          coin.position.z = 0;
          coin.rotation.z = 0; // Only reset Z rotation, keep X and Y as set
        }
      });
      
      // Animate glass shards
      tubes.forEach((tube, i) => {
        if (tube.glassShards.length > 0) {
          tube.glassShards.forEach(shard => {
            shard.lifetime += 0.016;
            
            // Apply velocity
            shard.mesh.position.x += shard.velocity.x;
            shard.mesh.position.y += shard.velocity.y;
            shard.mesh.position.z += shard.velocity.z;
            
            // Apply gravity to shards
            shard.velocity.y -= 0.3;
            
            // Rotate shards
            shard.mesh.rotation.x += shard.rotVelocity.x;
            shard.mesh.rotation.y += shard.rotVelocity.y;
            shard.mesh.rotation.z += shard.rotVelocity.z;
            
            // Fade out over 2 seconds
            shard.mesh.material.opacity = Math.max(0, 0.6 - (shard.lifetime / 2) * 0.6);
            
            // Remove after 2 seconds
            if (shard.lifetime > 2) {
              shard.mesh.visible = false;
            }
          });
        }
      });

      // ===== SELECTIVE BLOOM - TWO-PASS RENDERING =====
      
      // PASS 1: Render main scene (layer 0) - tubes, coins, background, etc.
      const originalMask = camera.layers.mask; // Save original layer mask
      camera.layers.disableAll(); // Clear all layers
      camera.layers.enable(0); // Only enable layer 0
      
      if (frameCount === 1) {
        console.log('üé¨ Frame 1 - Layer 0 mask:', camera.layers.mask, 'Should be 1 for layer 0');
      }
      
      webglRenderer.autoClear = true;
      webglRenderer.clear(true, true, true); // Clear color, depth, stencil
      webglRenderer.render(scene, camera);
      
      if (frameCount === 1) {
        console.log('‚úÖ Main scene (layer 0) rendered to screen');
      }
      
      // PASS 2: Render pearls (layer 1) with bloom to separate buffer  
      camera.layers.disableAll();
      camera.layers.enable(1); // Only enable layer 1 (pearls + plasma)
      
      if (frameCount === 1) {
        console.log('üé¨ Frame 1 - Layer 1 mask:', camera.layers.mask, 'Should be 2 for layer 1');
      }
      
      // Render to bloom composer's internal render target (NOT to screen!)
      bloomComposer.render();
      
      if (frameCount === 1) {
        console.log('‚úÖ Pearls (layer 1) rendered to bloom buffer');
        console.log('üîç Bloom composer render target:', bloomComposer.renderTarget1 ? 'Found' : 'Missing');
        console.log('üîç Bloom composer read buffer:', bloomComposer.readBuffer ? 'Found' : 'Missing');
      }
      
      // PASS 3: Composite bloomed pearls on top with additive blending
      webglRenderer.autoClear = false; // Don't clear - we want to blend on top!
      
      // Get the bloom result texture from the read buffer
      const bloomTexture = bloomComposer.readBuffer.texture;
      
      if (frameCount === 1) {
        console.log('üé® Bloom texture:', bloomTexture ? 'Found' : 'Missing');
        if (bloomTexture) {
          console.log('üé® Bloom texture details:', {
            width: bloomTexture.image?.width,
            height: bloomTexture.image?.height,
            format: bloomTexture.format,
            type: bloomTexture.type
          });
        }
      }
      
      // Debug: Check if any pearls are visible on layer 1
      if (frameCount === 1) {
        let visiblePearls = 0;
        tubes.forEach((tube, i) => {
          if (tube.liquidParticleMeshes) {
            const tubeVisiblePearls = tube.liquidParticleMeshes.filter(mesh => mesh.visible).length;
            visiblePearls += tubeVisiblePearls;
            console.log(`üîç Tube ${i + 1} has ${tubeVisiblePearls} visible pearls on layer 1`);
          }
        });
        console.log(`üîç Total visible pearls on layer 1: ${visiblePearls}`);
      }
      
      // Create a fullscreen quad to display bloom texture (create once)
      if (!window.bloomQuadMesh) {
        const quadGeometry = new THREE.PlaneGeometry(2, 2);
        const quadMaterial = new THREE.MeshBasicMaterial({
          map: bloomTexture,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          depthWrite: false,
          toneMapped: false // Preserve bloom colors!
        });
        const quadMesh = new THREE.Mesh(quadGeometry, quadMaterial);
        
        const quadScene = new THREE.Scene();
        quadScene.add(quadMesh);
        
        const quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        window.bloomQuadMesh = quadMesh;
        window.bloomQuadScene = quadScene;
        window.bloomQuadCamera = quadCamera;
        
        console.log('‚ú® Bloom composite quad created!');
      }
      
      // Update bloom texture reference and ensure it's properly bound
      if (window.bloomQuadMesh && bloomTexture) {
        window.bloomQuadMesh.material.map = bloomTexture;
        window.bloomQuadMesh.material.needsUpdate = true;
        
        // Force texture update
        if (bloomTexture.needsUpdate !== undefined) {
          bloomTexture.needsUpdate = true;
        }
      }
      
      // Render the bloomed pearls additively on top of the main scene
      if (window.bloomQuadScene && window.bloomQuadCamera && bloomTexture) {
        webglRenderer.render(window.bloomQuadScene, window.bloomQuadCamera);
      } else {
        // Fallback: If bloom fails, render pearls directly to main layer
        console.log('‚ö†Ô∏è Bloom rendering failed, using fallback direct rendering');
        camera.layers.disableAll();
        camera.layers.enable(1); // Enable layer 1
        webglRenderer.render(scene, camera);
        camera.layers.mask = originalMask; // Restore original mask
      }
      
      if (frameCount === 1) {
        console.log('‚úÖ Bloomed pearls composited on top');
        console.log('üéâ Selective bloom rendering complete!');
      }
      
      // Restore renderer settings
      webglRenderer.autoClear = true;
      camera.layers.mask = originalMask; // Restore original layer mask
      
      // Render CSS3D UI on top
      cssRenderer.render(scene, camera);

      requestAnimationFrame(animate);
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;

      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();

      webglRenderer.setSize(newWidth, newHeight);
      cssRenderer.setSize(newWidth, newHeight);
      bloomComposer.setSize(newWidth, newHeight);

      // Mobile-specific resize handling
      if (isMobile()) {
        // Recreate mobile player cards with new positions
        setTimeout(() => {
          // Remove existing mobile cards
          document.querySelectorAll('.mobile-player-card').forEach(card => card.remove());
          // Recreate them with new positions
          createMobilePlayerCards();
        }, 100);
      }

      console.log(`üìê Resized to ${newWidth}x${newHeight}`);
    });

    // Force background refresh on orientation change
    window.addEventListener('orientationchange', function() {
      // Force a reflow/repaint by temporarily changing and restoring a property
      const body = document.body;
      const originalDisplay = body.style.display;
      
      // Trigger reflow
      body.style.display = 'none';
      body.offsetHeight; // Force browser to acknowledge the change
      body.style.display = originalDisplay || '';
      
      // Alternative method: toggle a class that forces background recalculation
      body.classList.add('orientation-changing');
      setTimeout(() => {
        body.classList.remove('orientation-changing');
      }, 50);
      
      console.log('üì± Orientation changed - background refreshed');
    });

    // Also listen for resize events on mobile (some browsers use this instead)
    let resizeTimer;
    if (isMobile()) {
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          // Check if aspect ratio changed significantly (indicates rotation)
          const aspectRatio = window.innerWidth / window.innerHeight;
          if ((aspectRatio > 1 && window.lastAspectRatio < 1) || 
              (aspectRatio < 1 && window.lastAspectRatio > 1)) {
            // Force background refresh
            document.body.style.backgroundImage = document.body.style.backgroundImage || 
              "url('/Images/Background/game room2.png')";
            console.log('üì± Rotation detected via resize - background refreshed');
          }
          window.lastAspectRatio = aspectRatio;
        }, 100);
      });
      window.lastAspectRatio = window.innerWidth / window.innerHeight;
    }
  </script>
</body>
</html>

