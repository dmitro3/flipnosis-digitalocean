<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glass Tube Game - Refactored</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }
    
    body {
      font-family: 'Orbitron', sans-serif;
      background: url('/Images/Background/game room2.png') no-repeat center center fixed;
      background-size: cover;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }

    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: auto;
    }
    
    #container canvas {
      pointer-events: auto;
    }

    /* Player Card Styling */
    .player-card {
      width: 320px;
      background: rgba(10, 15, 35, 0.95);
      border: 3px solid #00ffff;
      border-radius: 16px;
      padding: 15px 20px;
      font-family: 'Orbitron', sans-serif;
      color: white;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
      pointer-events: auto;
      position: relative;
    }

    .card-header {
      margin-bottom: 15px;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .player-avatar {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      object-fit: cover;
      border: 2px solid #00ffff;
      flex-shrink: 0;
    }

    .player-info {
      flex: 1;
      text-align: right;
    }

    .player-name {
      font-size: 22px;
      font-weight: bold;
      color: #00ffff;
      margin-bottom: 5px;
    }

    .player-address {
      font-size: 16px;
      color: #ffffff;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
    }

    .lives-container {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin: 15px 0;
    }

    .life {
      opacity: 0.3;
      filter: grayscale(100%) brightness(0.5);
      transition: all 0.3s ease;
    }

    .life.active {
      opacity: 1;
      filter: grayscale(0%) brightness(1);
      animation: heartbeat 2s ease-in-out infinite;
    }

    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .choice-badge {
      padding: 12px;
      margin: 15px 0;
      border-radius: 8px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .choice-badge.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      border: 2px solid #00ff00;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-badge.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      border: 2px solid #00d4ff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-buttons {
      display: flex;
      gap: 10px;
      margin: 15px 0;
    }

    .choice-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      pointer-events: auto;
    }

    .choice-btn.heads {
      background: linear-gradient(135deg, #00ff00, #39ff14);
      color: #000;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .choice-btn.tails {
      background: linear-gradient(135deg, #00d4ff, #00a3ff);
      color: #fff;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .choice-btn:hover {
      transform: translateY(-3px);
      filter: brightness(1.2);
    }

    .action-btn {
      width: 100%;
      padding: 15px;
      background: white;
      border: 2px solid #ff1493;
      border-radius: 8px;
      color: #ff1493;
      font-weight: bold;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-top: 10px;
      pointer-events: auto;
    }

    .action-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 20, 147, 0.3);
      background: #ffe6f2;
    }

    #info {
      display: none;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="info">üéÆ Glass Tube Game - Refactored<br>Loading Three.js...</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
      }
    }
  </script>
  
  <script src="/socket.io/socket.io.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import * as CANNON from 'cannon-es';

    console.log('üéÆ REFACTORED CLIENT - Server-Authoritative Architecture');
    console.log('‚úÖ Client handles: Visuals, Animations, User Input');
    console.log('‚úÖ Server handles: Game Logic, Timers, Round Progression');

    // ===== CONFIGURATION =====
    const urlParams = new URLSearchParams(window.location.search);
    const gameIdParam = urlParams.get('gameId') || '';
    const roleParam = urlParams.get('role') || 'player';
    const userNameParam = urlParams.get('username') || '';
    let walletParam = urlParams.get('address') || '';
    const avatarParam = urlParams.get('avatar') || '';
    const tokenParam = urlParams.get('token') || '';
    
    // Wallet fallback logic
    if (!walletParam) {
      walletParam = localStorage.getItem('walletAddress') || '';
      if (!walletParam && window.ethereum?.selectedAddress) {
        walletParam = window.ethereum.selectedAddress;
      }
    }

    // ===== GAME STATE (Reactive Only) =====
    let socket = null;
    let playerSlot = -1;
    let currentPlayerXP = 0;
    let gameOver = false;
    
    // Player data (updated by server)
    let players = [
      { id: 1, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 2, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 3, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true },
      { id: 4, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true }
    ];

    // Coin options
    const coinOptions = [
      { id: 'plain', name: 'Classic', headsImage: '/coins/plainh.png', tailsImage: '/coins/plaint.png' },
      { id: 'skull', name: 'Skull', headsImage: '/coins/skullh.png', tailsImage: '/coins/skullt.png' },
      { id: 'trump', name: 'Trump', headsImage: '/coins/trumpheads.webp', tailsImage: '/coins/trumptails.webp' },
      { id: 'mario', name: 'Mario', headsImage: '/coins/mario.png', tailsImage: '/coins/luigi.png' },
      { id: 'jestress', name: 'Jestress', headsImage: '/coins/jestressh.png', tailsImage: '/coins/jestresst.png' },
      { id: 'dragon', name: 'Èæç', headsImage: '/coins/dragonh.png', tailsImage: '/coins/dragont.png' },
      { id: 'stinger', name: 'Stinger', headsImage: '/coins/stingerh.png', tailsImage: '/coins/stingert.png' },
      { id: 'manga', name: 'Heroine', headsImage: '/coins/mangah.png', tailsImage: '/coins/mangat.png' },
      { id: 'pharaoh', name: 'Pharaoh', headsImage: '/coins/pharaohh.png', tailsImage: '/coins/pharaoht.png' },
      { id: 'calavera', name: 'Calavera', headsImage: '/coins/calaverah.png', tailsImage: '/coins/calaverat.png' }
    ];

    // Coin materials
    const coinMaterials = [
      { id: 'graphite', name: 'Graphite', description: 'Ultra-Light & Swift', edgeColor: '#1a1a1a', speedMultiplier: 2.0, durationMultiplier: 0.5 },
      { id: 'penny', name: 'Penny', description: 'Lightweight & Fast', edgeColor: '#CD7F32', speedMultiplier: 1.5, durationMultiplier: 0.7 },
      { id: 'glass', name: 'Glass', description: 'Crystal Clear & Elegant', edgeColor: '#87CEEB', speedMultiplier: 1.3, durationMultiplier: 0.8 },
      { id: 'silver-dollar', name: 'Silver Dollar', description: 'Heavy & Controlled', edgeColor: '#C0C0C0', speedMultiplier: 0.7, durationMultiplier: 1.3 },
      { id: 'titanium', name: 'Titanium', description: 'Ultra-Heavy & Precise', edgeColor: '#2D1B69', speedMultiplier: 0.5, durationMultiplier: 1.6 }
    ];

    // ===== AUDIO SYSTEM =====
    let isMuted = false;
    const glassBreakSound = new Audio('../Sound/glassclipped.mp3');
    glassBreakSound.volume = 0.7;
    
    const powerChargeSound = new Audio('../Sound/powerclipped.mp3');
    powerChargeSound.volume = 0.6;
    powerChargeSound.loop = true;
    
    function playSound(audio) {
      if (!isMuted && audio) {
        audio.currentTime = 0;
        audio.play().catch(err => console.log('Audio play prevented:', err));
      }
    }
    
    function stopSound(audio) {
      if (audio) {
        audio.pause();
        audio.currentTime = 0;
      }
    }
    
    function toggleMute() {
      isMuted = !isMuted;
      glassBreakSound.muted = isMuted;
      powerChargeSound.muted = isMuted;
      return isMuted;
    }

    // ===== SCENE SETUP =====
    THREE.ColorManagement.enabled = true;
    
    const scene = new THREE.Scene();
    scene.background = null;
    
    const width = window.innerWidth;
    const height = window.innerHeight;
    const camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000);
    camera.position.set(0, 150, 1400);
    camera.lookAt(0, 150, 0);
    camera.layers.enable(0);
    camera.layers.enable(1);

    // WebGL Renderer
    const webglRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    webglRenderer.setSize(width, height);
    webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    webglRenderer.setClearColor(0x000000, 0);
    webglRenderer.autoClear = true;
    webglRenderer.toneMapping = THREE.ACESFilmicToneMapping;
    webglRenderer.toneMappingExposure = 1.0;
    webglRenderer.outputColorSpace = THREE.SRGBColorSpace;
    document.getElementById('container').appendChild(webglRenderer.domElement);

    // Bloom setup
    const bloomRenderTarget = new THREE.WebGLRenderTarget(width, height, {
      type: THREE.HalfFloatType,
      format: THREE.RGBAFormat,
      colorSpace: THREE.SRGBColorSpace
    });
    
    const bloomComposer = new EffectComposer(webglRenderer, bloomRenderTarget);
    const bloomRenderPass = new RenderPass(scene, camera);
    bloomComposer.addPass(bloomRenderPass);
    
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(width, height),
      1.0, 0.3, 0.1
    );
    bloomComposer.addPass(bloomPass);
    bloomComposer.renderToScreen = false;

    // CSS3D Renderer
    const cssRenderer = new CSS3DRenderer();
    cssRenderer.setSize(width, height);
    cssRenderer.domElement.style.position = 'absolute';
    cssRenderer.domElement.style.top = '0';
    cssRenderer.domElement.style.pointerEvents = 'auto';
    document.getElementById('container').appendChild(cssRenderer.domElement);

    // ===== LIGHTING =====
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const topLight = new THREE.DirectionalLight(0xffffff, 0.6);
    topLight.position.set(0, 600, 400);
    scene.add(topLight);

    const frontLight = new THREE.DirectionalLight(0xffffff, 1.0);
    frontLight.position.set(0, 200, 1200);
    frontLight.target.position.set(0, 200, 0);
    scene.add(frontLight);
    scene.add(frontLight.target);

    // ===== PHYSICS WORLD =====
    const physicsWorld = new CANNON.World({
      gravity: new CANNON.Vec3(0, -980, 0)
    });
    physicsWorld.defaultContactMaterial.friction = 0.1;
    physicsWorld.defaultContactMaterial.restitution = 0.3;

    // ===== TUBE CONFIGURATION =====
    const NUM_TUBES = 4;
    const TUBE_RADIUS = 80;
    const TUBE_HEIGHT = 350;
    const SPACING = 350;
    const totalWidth = SPACING * (NUM_TUBES - 1);
    const startX = -totalWidth / 2;

    const tubes = [];
    const coins = [];

    // ===== SOCKET.IO SETUP =====
    function initializeSocket() {
      if (typeof io === 'undefined') {
        console.error('‚ùå Socket.io not loaded');
        return;
      }
      
      socket = io();
      
      socket.on('connect', () => {
        console.log('‚úÖ Connected to server');
        if (gameIdParam && walletParam) {
          socket.emit('physics_join_room', {
            roomId: `game_${gameIdParam}`,
            address: walletParam
          });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('‚ùå Disconnected from server');
      });
      
      // ===== PURE REACTIVE STATE UPDATES =====
      socket.on('physics_state_update', (state) => {
        if (!state) return;
        
        // Update timer display (reactive only)
        if (state.roundTimer !== undefined) {
          updateTimerDisplay(state.roundTimer);
        }
        
        // Update round display (reactive only)
        if (state.currentRound !== undefined) {
          updateRoundDisplay(state.currentRound);
        }
        
        // Update player data (reactive only)
        if (state.players && walletParam) {
          const normalizedAddress = walletParam.toLowerCase();
          const player = state.players[normalizedAddress];
          if (player) {
            playerSlot = player.slotNumber;
            
            // Update player cards
            Object.keys(state.players).forEach(address => {
              const serverPlayer = state.players[address];
              if (serverPlayer && serverPlayer.slotNumber >= 0 && serverPlayer.slotNumber < 4) {
                const localPlayer = players[serverPlayer.slotNumber];
                if (localPlayer && !localPlayer.isEmpty) {
                  // Update choice
                  if (serverPlayer.choice && localPlayer.choice !== serverPlayer.choice) {
                    localPlayer.choice = serverPlayer.choice;
                    updatePlayerCardChoice(serverPlayer.slotNumber, serverPlayer.choice);
                  }
                  
                  // Update lives
                  if (serverPlayer.lives !== undefined && localPlayer.lives !== serverPlayer.lives) {
                    localPlayer.lives = serverPlayer.lives;
                    updateLivesDisplay(serverPlayer.slotNumber);
                  }
                }
              }
            });
          }
        }
        
        // Handle game over (reactive only)
        if (state.phase === 'game_over') {
          gameOver = true;
          if (state.winner) {
            const winnerIndex = players.findIndex(p => p.address && p.address.toLowerCase() === state.winner.toLowerCase());
            if (winnerIndex >= 0) {
              showGameOverScreen(winnerIndex, players[winnerIndex].name);
            }
          }
        }
      });
      
      // Visual-only event handlers
      socket.on('physics_coin_flip_start', (data) => {
        startClientCoinFlipAnimation(data);
      });
      
      socket.on('physics_coin_result', (data) => {
        showCoinFlipResult(data);
      });
      
      socket.on('physics_power_charging', (data) => {
        updatePowerChargingVisual(data);
      });
      
      socket.on('physics_power_charging_start', (data) => {
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = true;
            tube.power = 0;
            tube.chargingStartTime = Date.now();
          }
        }
      });
      
      socket.on('physics_power_charging_stop', (data) => {
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          const tube = tubes[data.playerSlot];
          if (tube) {
            tube.isFilling = false;
            tube.power = data.finalPower || tube.power;
          }
        }
      });
      
      socket.on('glass_shatter', (data) => {
        if (data.playerSlot >= 0 && data.playerSlot < 4) {
          shatterGlass(data.playerSlot, data.power);
        }
      });
      
      socket.on('flip_tokens_awarded', (data) => {
        if (data.success) {
          showFloatingMessage(`+${data.amount} FLIP earned!`, '#FFD700', 3000);
        }
      });
    }

    // ===== VISUAL UPDATE FUNCTIONS (Reactive Only) =====
    function updateTimerDisplay(time) {
      const timerDisplay = document.getElementById('timer-display');
      if (timerDisplay) {
        timerDisplay.textContent = time;
        if (time <= 5) {
          timerDisplay.style.color = '#ff0000';
        } else if (time <= 10) {
          timerDisplay.style.color = '#ffaa00';
        } else {
          timerDisplay.style.color = '#00ff00';
        }
      }
    }

    function updateRoundDisplay(round) {
      const roundElement = document.getElementById('round-number');
      if (roundElement) {
        roundElement.textContent = round;
      }
    }

    function updatePlayerCardChoice(tubeIndex, choice) {
      const tube = tubes[tubeIndex];
      if (!tube.cardElement) return;
      
      const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
      const choiceBadge = tube.cardElement.querySelector('.choice-badge');
      
      if (choiceButtons && choiceBadge) {
        choiceButtons.style.display = 'none';
        choiceBadge.className = `choice-badge ${choice}`;
        choiceBadge.textContent = choice.toUpperCase();
        choiceBadge.style.display = 'block';
      }
    }

    function updateLivesDisplay(tubeIndex) {
      const player = players[tubeIndex];
      const tube = tubes[tubeIndex];
      
      if (!tube.cardElement) return;
      
      const lifeElements = tube.cardElement.querySelectorAll('.life');
      lifeElements.forEach((lifeElement, idx) => {
        if (idx < player.lives) {
          lifeElement.classList.add('active');
        } else {
          lifeElement.classList.remove('active');
        }
      });
    }

    function updatePowerChargingVisual(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        if (!tube) return;
        
        tube.power = data.power;
        tube.isFilling = data.isFilling;
        
        const powerPercent = tube.power / 100;
        updatePearlColors(tube, powerPercent, data.playerSlot);
      }
    }

    function updatePearlColors(tube, powerPercent, tubeIndex) {
      const darkPearl = new THREE.Color(0x1a1a1a);
      const neonColors = [
        new THREE.Color(0x00ff00),
        new THREE.Color(0x00ddff),
        new THREE.Color(0xff0088),
        new THREE.Color(0xffff00)
      ];
      
      const neonColor = neonColors[tubeIndex] || neonColors[0];
      const currentColor = darkPearl.clone().lerp(neonColor, powerPercent);
      
      tube.liquidParticleMeshes.forEach(particleMesh => {
        particleMesh.material.color.copy(currentColor);
        particleMesh.material.emissive.copy(currentColor);
        particleMesh.material.emissiveIntensity = 0.2 + (powerPercent * 25.0);
      });
      
      tube.liquidLight.color.copy(currentColor);
      tube.liquidLight.intensity = 0.3 + (powerPercent * 15.0);
    }

    function startClientCoinFlipAnimation(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        if (tube) {
          tube.isFlipping = true;
          animateCoinFlip(data.playerSlot, data.power, data.duration);
        }
      }
    }

    function showCoinFlipResult(data) {
      if (data.playerSlot >= 0 && data.playerSlot < 4) {
        const tube = tubes[data.playerSlot];
        const coin = coins[data.playerSlot];
        
        if (tube && coin) {
          tube.isFlipping = false;
          
          const targetRotationX = data.result === 'heads' ? Math.PI / 2 : (3 * Math.PI / 2);
          const finalCycles = Math.floor(coin.rotation.x / (Math.PI * 2));
          coin.rotation.x = finalCycles * (Math.PI * 2) + targetRotationX;
          coin.rotation.y = Math.PI / 2;
          coin.rotation.z = 0;
          
          showResult(data.playerSlot, data.won, data.result);
        }
      }
    }

    function animateCoinFlip(playerSlot, power, duration) {
      const tube = tubes[playerSlot];
      const coin = coins[playerSlot];
      
      if (!tube || !coin) return;
      
      const powerPercent = power / 100;
      const material = tube.selectedMaterial || coinMaterials[2];
      const speedMult = material.speedMultiplier;
      const durationMult = material.durationMultiplier;
      
      const flipDuration = duration || (2000 + (powerPercent * 6000)) * durationMult;
      const basePowerSpeed = Math.max(0.08, 0.05 + (powerPercent * 0.25));
      const flipSpeed = basePowerSpeed * speedMult;
      
      const startTime = Date.now();
      
      const animateFlip = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / flipDuration, 1);
        
        if (progress < 0.7) {
          coin.rotation.x += flipSpeed;
        } else {
          const decelProgress = (progress - 0.7) / 0.3;
          const currentSpeed = flipSpeed * (1 - decelProgress);
          coin.rotation.x += currentSpeed;
        }
        
        if (progress < 1) {
          requestAnimationFrame(animateFlip);
        }
      };
      
      animateFlip();
    }

    function shatterGlass(tubeIndex, powerLevel) {
      const tube = tubes[tubeIndex];
      if (tube.isShattered) return;
      
      stopSound(powerChargeSound);
      playSound(glassBreakSound);
      
      tube.isShattered = true;
      tube.tube.visible = false;
      tube.backing.visible = false;
      tube.topRim.visible = false;
      tube.bottomRim.visible = false;
      tube.liquid.visible = false;
      tube.coinShadow.visible = true;
      
      physicsWorld.removeBody(tube.glassBody);
      
      const powerPercent = powerLevel / 100;
      const shardCount = Math.floor(20 + (powerPercent * 60));
      
      for (let s = 0; s < shardCount; s++) {
        const size = Math.random() * 12 + 5;
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([0, 0, 0, size, 0, 0, size * 0.5, size, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        const material = new THREE.MeshStandardMaterial({
          color: 0xe0e0e0,
          metalness: 0.95,
          roughness: 0.1,
          emissive: 0xc0c0c0,
          emissiveIntensity: 0.4,
          side: THREE.DoubleSide
        });
        
        const shard = new THREE.Mesh(geometry, material);
        const angle = (s / shardCount) * Math.PI * 2;
        const heightPos = (Math.random() - 0.5) * TUBE_HEIGHT;
        shard.position.set(
          tube.tube.position.x + Math.cos(angle) * TUBE_RADIUS,
          200 + heightPos,
          Math.sin(angle) * TUBE_RADIUS
        );
        
        shard.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        const baseSpeed = 2 + (powerPercent * 12);
        const velocity = {
          x: Math.cos(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5),
          y: Math.random() * 3 - 1.5,
          z: Math.sin(angle) * (Math.random() * baseSpeed + baseSpeed * 0.5)
        };
        
        const rotVelocity = {
          x: (Math.random() - 0.5) * 0.3,
          y: (Math.random() - 0.5) * 0.3,
          z: (Math.random() - 0.5) * 0.3
        };
        
        scene.add(shard);
        tube.glassShards.push({ mesh: shard, velocity, rotVelocity, lifetime: 0 });
      }
    }

    function showResult(tubeIndex, didWin, result) {
      const tube = tubes[tubeIndex];
      const coin = coins[tubeIndex];
      
      if (didWin) {
        const winLight = new THREE.PointLight(0x00ff00, 8, 200);
        coin.add(winLight);
        tube.winLight = winLight;
      } else {
        const loseLight = new THREE.PointLight(0xff0000, 6, 200);
        coin.add(loseLight);
        tube.loseLight = loseLight;
      }
      
      const resultBox = document.createElement('div');
      resultBox.style.cssText = `
        width: 300px;
        padding: 20px;
        background: ${didWin ? 'linear-gradient(135deg, #004d00, #003300)' : 'linear-gradient(135deg, #1a0000, #0d0000)'};
        border: 3px solid ${didWin ? '#00ff00' : '#ff0000'};
        border-radius: 16px;
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        box-shadow: 0 0 30px ${didWin ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 0, 0, 0.6)'};
        pointer-events: none;
      `;
      
      resultBox.innerHTML = `
        <div style="font-size: 30px; font-weight: bold; color: ${didWin ? '#00ff00' : '#ff0000'}; margin-bottom: 10px;">
          ${didWin ? 'ROUND WON!' : 'YOU LOST'}
        </div>
        <div style="font-size: 20px; color: #ffffff;">
          Result: ${result.toUpperCase()}
        </div>
      `;
      
      const cssObject = new CSS3DObject(resultBox);
      cssObject.position.set(tube.tube.position.x, coin.position.y - 100, 0);
      cssObject.scale.set(0.5, 0.5, 0.5);
      scene.add(cssObject);
      tube.resultBox = cssObject;
      
      resultBox.style.opacity = '0';
      resultBox.style.transition = 'all 0.5s ease-out';
      setTimeout(() => { resultBox.style.opacity = '1'; }, 50);
    }

    function showGameOverScreen(winnerIndex, winnerName) {
      console.log('üèÅ GAME OVER');
      gameOver = true;
      
      const gameOverDiv = document.createElement('div');
      gameOverDiv.id = 'game-over-overlay';
      gameOverDiv.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        font-family: 'Orbitron', sans-serif;
      `;
      
      const contentDiv = document.createElement('div');
      const didCurrentPlayerWin = (playerSlot === winnerIndex);
      contentDiv.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 4px solid ${didCurrentPlayerWin ? '#FFD700' : '#ff0000'};
        border-radius: 25px;
        padding: 50px;
        text-align: center;
        box-shadow: 0 0 50px ${didCurrentPlayerWin ? 'rgba(255, 215, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
        max-width: 600px;
        width: 90%;
      `;
      
      contentDiv.innerHTML = `
        <div style="font-size: ${didCurrentPlayerWin ? '80px' : '60px'}; margin-bottom: 20px;">
          ${didCurrentPlayerWin ? 'üèÜ' : 'üíî'}
        </div>
        <div style="font-size: ${didCurrentPlayerWin ? '48px' : '36px'}; font-weight: bold; color: ${didCurrentPlayerWin ? '#FFD700' : '#ff0000'}; margin-bottom: 20px;">
          ${didCurrentPlayerWin ? 'VICTORY!' : 'DEFEATED'}
        </div>
        <div style="font-size: 24px; color: #ffffff; margin-bottom: 30px;">
          ${didCurrentPlayerWin ? `You earned ${currentPlayerXP} FLIP tokens!` : `Winner: ${winnerName || 'Unknown'}`}
        </div>
        <button id="return-lobby-btn" style="
          background: linear-gradient(135deg, #666, #888);
          border: none;
          border-radius: 15px;
          padding: 15px 30px;
          font-family: 'Orbitron', sans-serif;
          font-size: 18px;
          font-weight: bold;
          color: #fff;
          cursor: pointer;
        ">Return Home</button>
      `;
      
      gameOverDiv.appendChild(contentDiv);
      document.body.appendChild(gameOverDiv);
      
      setTimeout(() => {
        const returnBtn = document.getElementById('return-lobby-btn');
        if (returnBtn) {
          returnBtn.addEventListener('click', () => {
            window.location.href = '/';
          });
        }
      }, 100);
    }

    function showFloatingMessage(message, color, duration = 3000) {
      const floatingMsg = document.createElement('div');
      floatingMsg.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: ${color};
        padding: 15px 25px;
        border-radius: 12px;
        border: 2px solid ${color};
        font-family: 'Orbitron', sans-serif;
        font-size: 18px;
        font-weight: bold;
        z-index: 10000;
        text-align: center;
        box-shadow: 0 0 40px ${color}99;
        pointer-events: none;
      `;
      
      floatingMsg.textContent = message;
      document.body.appendChild(floatingMsg);
      
      setTimeout(() => {
        if (floatingMsg.parentNode) {
          floatingMsg.parentNode.removeChild(floatingMsg);
        }
      }, duration);
    }

    // ===== USER INPUT HANDLERS =====
    function setupPlayerControls(tubeIndex) {
      const tube = tubes[tubeIndex];
      if (!tube.cardElement) return;
      
      // Choice buttons
      const choiceButtons = tube.cardElement.querySelectorAll('.choice-btn');
      choiceButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          const choice = button.classList.contains('heads') ? 'heads' : 'tails';
          
          players[tubeIndex].choice = choice;
          updatePlayerCardChoice(tubeIndex, choice);
          
          if (socket && gameIdParam && walletParam) {
            socket.emit('physics_set_choice', {
              gameId: gameIdParam,
              address: walletParam,
              choice: choice
            });
          }
        });
      });
      
      // Power button
      const powerButton = tube.cardElement.querySelectorAll('.action-btn')[1];
      if (powerButton) {
        let isCharging = false;
        
        powerButton.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          
          if (players[tubeIndex].lives <= 0) return;
          if (!players[tubeIndex].choice) return;
          if (tube.hasUsedPower) return;
          
          isCharging = true;
          tube.isFilling = true;
          tube.power = 0;
          playSound(powerChargeSound);
          
          if (socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_start', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: tubeIndex
            });
          }
        });
        
        powerButton.addEventListener('mouseup', (e) => {
          e.stopPropagation();
          const finalPower = tube.power;
          isCharging = false;
          tube.isFilling = false;
          stopSound(powerChargeSound);
          
          if (socket && gameIdParam && walletParam) {
            socket.emit('physics_power_charging_stop', {
              gameId: gameIdParam,
              address: walletParam,
              playerSlot: tubeIndex,
              finalPower: finalPower
            });
          }
          
          if (finalPower >= 5) {
            if (socket && gameIdParam && walletParam) {
              socket.emit('physics_flip_coin', {
                gameId: gameIdParam,
                address: walletParam,
                power: finalPower,
                angle: 0
              });
            }
            
            powerButton.disabled = true;
            powerButton.style.opacity = '0.5';
            tube.hasUsedPower = true;
          }
        });
      }
    }

    // ===== CREATE TUBES (Visual Only) =====
    async function createTubes() {
      const textureLoader = new THREE.TextureLoader();
      
      for (let i = 0; i < NUM_TUBES; i++) {
        const x = startX + (i * SPACING);
        
        // Create tube geometry
        const tubeGeometry = new THREE.CylinderGeometry(TUBE_RADIUS, TUBE_RADIUS, TUBE_HEIGHT, 64, 1, true);
        const glassMaterial = new THREE.MeshStandardMaterial({
          color: 0xd0d0d0,
          transparent: true,
          opacity: 0.15,
          roughness: 0.2,
          metalness: 1.0,
          side: THREE.DoubleSide
        });
        const tube = new THREE.Mesh(tubeGeometry, glassMaterial);
        tube.position.set(x, 200, 0);
        tube.rotation.y = Math.PI;
        scene.add(tube);
        
        // Create backing
        const backingGeometry = new THREE.CylinderGeometry(TUBE_RADIUS + 5, TUBE_RADIUS + 5, TUBE_HEIGHT + 20, 32, 1, false);
        const backingMaterial = new THREE.MeshStandardMaterial({
          color: 0xe0e0e0,
          roughness: 0.1,
          metalness: 0.98,
          side: THREE.BackSide
        });
        const backing = new THREE.Mesh(backingGeometry, backingMaterial);
        backing.position.set(x, 200, -10);
        scene.add(backing);
        
        // Create coin
        const coinRadius = 65;
        const coinThickness = 16;
        const coinGeometry = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);
        
        const headsTexture = textureLoader.load('/coins/plainh.png');
        const tailsTexture = textureLoader.load('/coins/plaint.png');
        
        const coinMaterials = [
          new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8, roughness: 0.2 }),
          new THREE.ShaderMaterial({
            uniforms: { map: { value: headsTexture } },
            vertexShader: 'varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }',
            fragmentShader: 'uniform sampler2D map; varying vec2 vUv; void main() { gl_FragColor = texture2D(map, vUv); }'
          }),
          new THREE.ShaderMaterial({
            uniforms: { map: { value: tailsTexture } },
            vertexShader: 'varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }',
            fragmentShader: 'uniform sampler2D map; varying vec2 vUv; void main() { gl_FragColor = texture2D(map, vUv); }'
          })
        ];
        
        const coin = new THREE.Mesh(coinGeometry, coinMaterials);
        coin.rotation.x = Math.PI / 2;
        coin.rotation.y = Math.PI / 2;
        coin.position.set(x, 200, 0);
        scene.add(coin);
        coins.push(coin);
        
        // Create coin shadow
        const shadowGeometry = new THREE.CircleGeometry(coinRadius * 1.5, 64);
        const shadowMaterial = new THREE.MeshBasicMaterial({ color: 0x0a0a2e, transparent: true, opacity: 0.85 });
        const coinShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
        coinShadow.position.set(x, 200, -8);
        coinShadow.visible = false;
        scene.add(coinShadow);
        
        // Create physics particles (pearls)
        const liquidParticles = [];
        const liquidParticleMeshes = [];
        const particleRadius = 7;
        const maxLayers = 80;
        
        for (let p = 0; p < maxLayers; p++) {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * (TUBE_RADIUS - 25);
          const pearlX = x + Math.cos(angle) * radius;
          const pearlZ = Math.sin(angle) * radius;
          const pearlY = 200 - (TUBE_HEIGHT / 2) + 30 + Math.random() * 60;
          
          const particleShape = new CANNON.Sphere(particleRadius);
          const particleBody = new CANNON.Body({
            mass: 0.3,
            position: new CANNON.Vec3(pearlX, pearlY, pearlZ)
          });
          particleBody.addShape(particleShape);
          physicsWorld.addBody(particleBody);
          
          const particleGeometry = new THREE.SphereGeometry(particleRadius, 32, 32);
          const particleMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x1a1a1a,
            metalness: 0.0,
            roughness: 0.3,
            transparent: true,
            opacity: 0.7,
            emissive: 0x0a0a0a,
            emissiveIntensity: 0.2,
            toneMapped: false
          });
          const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
          particleMesh.layers.set(1);
          scene.add(particleMesh);
          
          liquidParticles.push(particleBody);
          liquidParticleMeshes.push(particleMesh);
        }
        
        // Create liquid mesh
        const liquidHeight = TUBE_HEIGHT - 20;
        const liquidGeometry = new THREE.CylinderGeometry(TUBE_RADIUS - 6, TUBE_RADIUS - 6, liquidHeight, 32, 32);
        const liquidMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x1a1a2e,
          transparent: true,
          opacity: 0.25
        });
        const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
        const liquidY = 200 - (TUBE_HEIGHT / 2) + (liquidHeight / 2);
        liquid.position.set(x, liquidY, 0);
        scene.add(liquid);
        
        const liquidLight = new THREE.PointLight(0x1a1a2e, 0.3, 400);
        liquid.add(liquidLight);
        
        // Create player card
        const cardElement = document.createElement('div');
        cardElement.className = 'player-card';
        cardElement.innerHTML = `
          <div class="card-header">
            <img src="/images/potion.png" class="player-avatar" />
            <div class="player-info">
              <div class="player-name">Empty</div>
              <div class="lives-container">
                ${Array.from({ length: 3 }, () => '<div class="life">‚ù§Ô∏è</div>').join('')}
              </div>
            </div>
          </div>
          <div class="choice-buttons" style="display: none;">
            <button class="choice-btn heads">HEADS</button>
            <button class="choice-btn tails">TAILS</button>
          </div>
          <div style="margin: 15px 0;">
            <div style="height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; margin-bottom: 8px;">
              <div class="power-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #00ff00, #39ff14);"></div>
            </div>
            <div class="power-text" style="color: #00ff00; font-size: 14px; text-align: center;">POWER: 0%</div>
          </div>
          <button class="action-btn" style="display: none;">CHANGE COIN</button>
          <button class="action-btn" style="display: none;">CHARGE POWER</button>
        `;
        
        const cssObject = new CSS3DObject(cardElement);
        cssObject.position.set(x, 200 - (TUBE_HEIGHT / 2) - 140, 0);
        cssObject.scale.set(0.6, 0.45, 0.6);
        scene.add(cssObject);
        
        // Store tube data
        tubes.push({
          tube, backing, liquid, liquidLight, liquidParticles, liquidParticleMeshes,
          coin, coinShadow, cardElement,
          power: 0, isFilling: false, isShattered: false, isFlipping: false,
          glassShards: [], selectedCoin: coinOptions[0], selectedMaterial: coinMaterials[0],
          hasUsedPower: false, topRim: null, bottomRim: null
        });
        
        // Setup controls for this tube
        setupPlayerControls(i);
      }
    }

    // ===== UI ELEMENTS =====
    function createUIElements() {
      // XP Counter
      const xpCounter = document.createElement('div');
      xpCounter.id = 'xp-counter';
      xpCounter.style.cssText = `
        position: fixed;
        top: 16px;
        right: 16px;
        z-index: 10001;
        padding: 12px 18px;
        background: #0a0f2e;
        border: 2px solid #00ff88;
        border-radius: 12px;
        font-family: 'Orbitron', sans-serif;
        color: #00ff88;
      `;
      xpCounter.innerHTML = `
        <div style="font-size: 12px;">Total Earnings</div>
        <div style="font-size: 18px;">${currentPlayerXP} FLIP</div>
      `;
      document.body.appendChild(xpCounter);
      
      // Game Info
      const gameInfoDiv = document.createElement('div');
      gameInfoDiv.style.cssText = `
        width: 200px;
        background: rgba(10, 15, 35, 0.95);
        border: 3px solid #9d00ff;
        border-radius: 16px;
        padding: 15px;
        font-family: 'Orbitron', sans-serif;
        color: white;
        text-align: center;
      `;
      
      gameInfoDiv.innerHTML = `
        <div style="font-size: 18px; font-weight: bold; color: #00ffff;">
          ROUND <span id="round-number">1</span>
        </div>
        <div id="timer-display" style="font-size: 50px; font-weight: bold; color: #00ff00; margin: 5px 0;">30</div>
        <div style="font-size: 12px; color: #888;">SECONDS</div>
        <button id="mute-btn" style="width: 100%; padding: 8px; margin-top: 10px; cursor: pointer;">üîä MUTE</button>
      `;
      
      const gameInfoObject = new CSS3DObject(gameInfoDiv);
      gameInfoObject.position.set(0, 200 - (TUBE_HEIGHT / 2) - 160, 0);
      gameInfoObject.scale.set(0.5, 0.5, 0.5);
      scene.add(gameInfoObject);
      
      // Mute button handler
      const muteBtn = gameInfoDiv.querySelector('#mute-btn');
      muteBtn.addEventListener('click', () => {
        const muted = toggleMute();
        muteBtn.textContent = muted ? 'üîá UNMUTE' : 'üîä MUTE';
      });
      
      // Leave button
      const leaveBtn = document.createElement('button');
      leaveBtn.textContent = 'Leave Game';
      leaveBtn.style.cssText = `
        position: fixed;
        top: 16px;
        left: 16px;
        z-index: 10001;
        padding: 10px 14px;
        font-family: 'Orbitron', sans-serif;
        background: linear-gradient(135deg, #ff4444, #cc0000);
        color: #fff;
        border: none;
        border-radius: 10px;
        cursor: pointer;
      `;
      leaveBtn.onclick = () => {
        window.location.href = '/';
      };
      document.body.appendChild(leaveBtn);
    }

    // ===== LOAD PARTICIPANTS =====
    async function loadParticipants() {
      try {
        if (!gameIdParam) return;
        const res = await fetch(`/api/battle-royale/${encodeURIComponent(gameIdParam)}`);
        if (!res.ok) throw new Error('Failed to load participants');
        const data = await res.json();
        const parts = (data?.game?.participants || []).slice().sort((a,b) => (a.slot_number||0)-(b.slot_number||0));
        
        players = [1,2,3,4].map((slot, idx) => {
          const p = parts[idx];
          if (!p) {
            return { id: idx+1, name: 'Empty', lives: 0, address: '', choice: null, avatar: '', isEmpty: true };
          }
          
          return {
            id: idx+1,
            name: p.username || p.name || `Player ${idx+1}`,
            lives: 3,
            address: p.player_address || '',
            choice: null,
            avatar: p.avatar || '/images/default-avatar.png',
            isEmpty: false
          };
        });
        
        console.log('üìä Participants loaded:', players);
        updatePlayerCardsData();
      } catch (err) {
        console.warn('Participants load failed:', err);
      }
    }

    function updatePlayerCardsData() {
      tubes.forEach((tube, index) => {
        const player = players[index];
        if (!tube.cardElement || !player) return;
        
        const playerNameElement = tube.cardElement.querySelector('.player-name');
        const playerAvatarElement = tube.cardElement.querySelector('.player-avatar');
        
        if (playerNameElement) playerNameElement.textContent = player.name;
        if (playerAvatarElement) {
          playerAvatarElement.src = player.isEmpty ? '/images/potion.png' : (player.avatar || '/images/default-avatar.png');
        }
        
        // Show/hide controls based on player slot
        const actionButtons = tube.cardElement.querySelectorAll('.action-btn');
        const choiceButtons = tube.cardElement.querySelector('.choice-buttons');
        
        if (playerSlot === index && !player.isEmpty) {
          actionButtons.forEach(btn => btn.style.display = 'block');
          if (choiceButtons) choiceButtons.style.display = 'flex';
        }
      });
    }

    // ===== ANIMATION LOOP =====
    let frameCount = 0;
    const timeStep = 1 / 60;
    
    function animate() {
      frameCount++;
      physicsWorld.step(timeStep);
      
      tubes.forEach((tube, i) => {
        // Update power charging visuals
        if (tube.isFilling && !tube.isShattered) {
          tube.power = Math.min(tube.power + 0.6, 100);
          
          const powerBar = tube.cardElement.querySelector('.power-bar');
          const powerText = tube.cardElement.querySelector('.power-text');
          if (powerBar) powerBar.style.width = `${tube.power}%`;
          if (powerText) powerText.textContent = `POWER: ${tube.power.toFixed(0)}%`;
          
          // Broadcast power updates (throttled)
          if (socket && gameIdParam && walletParam && playerSlot === i && frameCount % 5 === 0) {
            socket.emit('physics_power_charging', {
              gameId: gameIdParam,
              address: walletParam,
              power: tube.power,
              playerSlot: i,
              isFilling: tube.isFilling
            });
          }
        }
        
        // Sync particle visuals with physics
        tube.liquidParticles.forEach((particleBody, idx) => {
          tube.liquidParticleMeshes[idx].position.copy(particleBody.position);
          tube.liquidParticleMeshes[idx].quaternion.copy(particleBody.quaternion);
        });
        
        // Animate glass shards
        tube.glassShards.forEach(shard => {
          shard.lifetime += 0.016;
          shard.mesh.position.x += shard.velocity.x;
          shard.mesh.position.y += shard.velocity.y;
          shard.mesh.position.z += shard.velocity.z;
          shard.velocity.y -= 0.3;
          shard.mesh.rotation.x += shard.rotVelocity.x;
          shard.mesh.rotation.y += shard.rotVelocity.y;
          shard.mesh.rotation.z += shard.rotVelocity.z;
          shard.mesh.material.opacity = Math.max(0, 0.6 - (shard.lifetime / 2) * 0.6);
        });
      });
      
      // Render
      camera.layers.disableAll();
      camera.layers.enable(0);
      webglRenderer.autoClear = true;
      webglRenderer.render(scene, camera);
      
      camera.layers.disableAll();
      camera.layers.enable(1);
      bloomComposer.render();
      
      if (bloomComposer.readBuffer) {
        if (!window.bloomQuadMesh) {
          const quadGeometry = new THREE.PlaneGeometry(2, 2);
          const quadMaterial = new THREE.MeshBasicMaterial({
            map: bloomComposer.readBuffer.texture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            toneMapped: false
          });
          window.bloomQuadMesh = new THREE.Mesh(quadGeometry, quadMaterial);
          window.bloomQuadScene = new THREE.Scene();
          window.bloomQuadScene.add(window.bloomQuadMesh);
          window.bloomQuadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        }
        
        webglRenderer.autoClear = false;
        webglRenderer.render(window.bloomQuadScene, window.bloomQuadCamera);
      }
      
      cssRenderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // ===== INITIALIZATION =====
    async function init() {
      console.log('üéÆ Initializing refactored game...');
      await createTubes();
      createUIElements();
      initializeSocket();
      await loadParticipants();
      animate();
      console.log('‚úÖ Game initialized!');
    }

    init();

    // Resize handler
    window.addEventListener('resize', () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      webglRenderer.setSize(newWidth, newHeight);
      cssRenderer.setSize(newWidth, newHeight);
      bloomComposer.setSize(newWidth, newHeight);
    });
  </script>
</body>
</html>